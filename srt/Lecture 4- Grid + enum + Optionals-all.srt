1
00:00:01,219 --> 00:00:03,802
 （柔和的音乐） 

2
00:00:04,940 --> 00:00:06,589
 -[旁白]斯坦福大学。 

3
00:00:08,169 --> 00:00:10,580
 -[讲师]我们回来了，第四节课。 

4
00:00:10,580 --> 00:00:15,160
斯坦福CS193p，2020年春季。 

5
00:00:15,160 --> 00:00:18,210
今天，我将从一个大型演示开始， 

6
00:00:18,210 --> 00:00:20,670
这将是制作我们的纸牌游戏

7
00:00:20,670 --> 00:00:23,980
排成一排，而不是排成一排， 

8
00:00:23,980 --> 00:00:27,280
毫无疑问，这将使我们的游戏变得更好

9
00:00:27,280 --> 00:00:29,640
但这也将是一个很好的例子

10
00:00:29,640 --> 00:00:32,429
使用协议进行泛型的过程， 

11
00:00:32,429 --> 00:00:34,729
并用作类型。 

12
00:00:34,729 --> 00:00:37,039
我们将学习更多有关成为容器的信息

13
00:00:37,039 --> 00:00:38,469
因为我们要建立自己的

14
00:00:38,469 --> 00:00:41,969
行和列容器查看我们的卡。 

15
00:00:41,969 --> 00:00:44,820
演示之后，我们将跳回到此处的幻灯片。 

16
00:00:44,820 --> 00:00:47,299
我们将进一步讨论Swift类型的系统， 

17
00:00:47,299 --> 00:00:51,049
特别是类型枚举。 

18
00:00:51,049 --> 00:00:53,779
然后在那之后，我们将继续幻灯片

19
00:00:53,780 --> 00:00:56,590
并讨论最重要的类型之一

20
00:00:56,590 --> 00:00:59,583
在所有Swift中，Optional是一个枚举。 

21
00:01:01,000 --> 00:01:03,649
可选非常重要，我要去

22
00:01:03,649 --> 00:01:05,439
之后立即返回演示

23
00:01:05,439 --> 00:01:08,390
并向您展示两个非常重要的例子

24
00:01:08,390 --> 00:01:12,393
在Swift中使用Optional设计代码的过程。 

25
00:01:13,379 --> 00:01:15,852
因此，让我们开始该演示。 

26
00:01:16,920 --> 00:01:20,549
好吧，这是修复此主要缺陷的类型

27
00:01:20,549 --> 00:01:23,019
在我们的游戏中，这是所有的牌

28
00:01:23,019 --> 00:01:24,409
在一排， 

29
00:01:24,409 --> 00:01:26,899
而且我们知道我们可以更有效率

30
00:01:26,900 --> 00:01:30,280
如果我们有行和列，请使用此空间。 

31
00:01:30,280 --> 00:01:33,930
我们将通过在此处替换HStack来做到这一点

32
00:01:33,930 --> 00:01:35,569
与网格。 

33
00:01:35,769 --> 00:01:39,769
现在，从这个班级的录音开始， 

34
00:01:39,769 --> 00:01:42,579
 SwiftUI中没有Grid之类的东西， 

35
00:01:42,579 --> 00:01:44,016
所以我们要写些。 

36
00:01:44,016 --> 00:01:47,159
它实际上为我们提供了一个绝佳的机会

37
00:01:47,159 --> 00:01:51,569
了解有关ZStack之类的工作原理的大量信息。 

38
00:01:51,569 --> 00:01:55,079
因此，我们知道ZStack就在这里接受此参数， 

39
00:01:55,079 --> 00:01:56,829
这是一个功能。 

40
00:01:56,829 --> 00:01:58,396
花括号表示它是一个功能。 

41
00:01:58,397 --> 00:02:00,920
这个函数不带参数， 

42
00:02:00,920 --> 00:02:05,420
与ForEach不同，它创建视图的功能

43
00:02:05,420 --> 00:02:06,759
吵架

44
00:02:06,959 --> 00:02:09,900
但是ZStack，这里构建的View 

45
00:02:09,900 --> 00:02:11,000
非常强大。 

46
00:02:11,199 --> 00:02:13,959
它可能是其他视图的列表。 

47
00:02:13,960 --> 00:02:17,800
可以是如果-则是其组合。 

48
00:02:17,800 --> 00:02:20,990
所以这个可以建立的特殊功能

49
00:02:20,990 --> 00:02:24,783
这些复杂的View称为ViewBuilder。 

50
00:02:25,830 --> 00:02:28,300
而且我们还不会使用ViewBuilder。 

51
00:02:28,300 --> 00:02:30,400
我们最终将了解ViewBuilder。 

52
00:02:30,599 --> 00:02:34,419
所以我们的网格只会有一个简单的视图

53
00:02:34,419 --> 00:02:38,019
它将使用ForEach复制， 

54
00:02:38,020 --> 00:02:39,750
与ForEach完全相同， 

55
00:02:39,949 --> 00:02:42,789
在每个位置放一个特定的视图

56
00:02:42,789 --> 00:02:44,530
在行和列中。 

57
00:02:44,530 --> 00:02:49,240
因此，我们的Grid确实将像Grid一样组合HStack， 

58
00:02:49,240 --> 00:02:51,780
除了2D HStack，如果您想考虑一下， 

59
00:02:51,979 --> 00:02:54,479
像这样的ForEach。 

60
00:02:54,479 --> 00:02:59,109
我们将采取一系列可识别的事物， 

61
00:02:59,110 --> 00:03:03,620
像这些卡片，然后我们将传递一个函数

62
00:03:03,620 --> 00:03:07,259
以可识别事物之一作为论据， 

63
00:03:07,259 --> 00:03:09,289
并返回要使用的视图

64
00:03:09,289 --> 00:03:11,819
在网格中的该位置绘制。 

65
00:03:11,819 --> 00:03:13,432
这里很简单。 

66
00:03:14,460 --> 00:03:15,893
因此，让我们创建该视图。 

67
00:03:15,893 --> 00:03:17,719
我们将在这里转到“新建文件”。 

68
00:03:17,719 --> 00:03:20,530
我们将其放入自己的文件中，因为这确实

69
00:03:20,530 --> 00:03:23,379
一个非常强大的可重用对象。 

70
00:03:23,379 --> 00:03:26,689
我们可以在需要网格的所有应用程序中使用它。 

71
00:03:26,689 --> 00:03:29,500
这是一个SwiftUI视图，所以我要单击此处。 

72
00:03:29,500 --> 00:03:31,069
我将其称为Grid。 

73
00:03:31,069 --> 00:03:33,259
要仔细检查它是其中之一

74
00:03:33,259 --> 00:03:36,109
黄色的文件夹在这里，这个内容

75
00:03:36,110 --> 00:03:39,650
有点匹配，而且确实如此，所以我们很好。 

76
00:03:39,849 --> 00:03:43,500
这是我们的网格，当然，我们会得到“ Hello，World！” 

77
00:03:43,500 --> 00:03:46,270
您会记得下面的这段代码

78
00:03:46,270 --> 00:03:50,270
是为了把我们吸引到我们的画布上。 

79
00:03:50,270 --> 00:03:53,159
但是这个网格是完全通用的。 

80
00:03:53,159 --> 00:03:55,949
因此，如果我们要使该预览工作正常进行， 

81
00:03:55,949 --> 00:03:59,389
我们需要为此提供一些测试数据。 

82
00:03:59,389 --> 00:04:01,699
而且在本演示中我们不会这样做

83
00:04:01,699 --> 00:04:04,269
但将来有一天，也许你可以做到

84
00:04:04,270 --> 00:04:05,689
作为练习。 

85
00:04:05,689 --> 00:04:08,329
但是，如果您删除了它并需要它， 

86
00:04:08,330 --> 00:04:11,862
在画布上会在此处说“创建预览”。 

87
00:04:13,000 --> 00:04:16,019
好吧，所以我们必须开始使用Grid。 

88
00:04:16,019 --> 00:04:19,000
我们要做的第一件事是它的两个论点。 

89
00:04:19,000 --> 00:04:23,879
第一个参数是此可识别数组， 

90
00:04:23,879 --> 00:04:25,860
第二个参数是这个函数

91
00:04:25,860 --> 00:04:28,480
它采用一个Identifiables并提供一个View。 

92
00:04:28,480 --> 00:04:31,980
因此，让我们将这两个参数作为vars获取。 

93
00:04:31,980 --> 00:04:36,980
因此，第一个变量是“项目”，即“项目数组”。 

94
00:04:38,310 --> 00:04:41,639
 Grid中对我们来说这一项是无关紧要的。 

95
00:04:41,639 --> 00:04:45,750
我们真的不在乎那个东西是什么。 

96
00:04:45,750 --> 00:04:46,583
可能是任何东西。 

97
00:04:46,583 --> 00:04:50,230
这将是一张卡片，但是没有理由

98
00:04:50,230 --> 00:04:51,600
因为它是任何特殊的东西， 

99
00:04:51,600 --> 00:04:53,430
所以这对我们来说不在乎。 

100
00:04:53,430 --> 00:04:56,379
同样，第二个论点

101
00:04:56,379 --> 00:04:59,240
 viewForItem我将其称为函数。 

102
00:04:59,240 --> 00:05:02,420
这个函数需要一个Item作为参数， 

103
00:05:02,420 --> 00:05:05,500
它返回一些ItemView， 

104
00:05:05,500 --> 00:05:07,459
这是另一个我们不在乎的。 

105
00:05:07,459 --> 00:05:10,539
我们真的不在乎您提供哪种视图

106
00:05:10,540 --> 00:05:13,956
对于每个项目，都不必关心ItemView。 

107
00:05:14,980 --> 00:05:19,060
一个好的开始，我们实际上可以在这里解决。 

108
00:05:19,060 --> 00:05:23,000
不幸的是，我们必须在此命名该项目。 

109
00:05:23,000 --> 00:05:27,029
这真的是viewForItem， 

110
00:05:27,029 --> 00:05:29,169
放在那边

111
00:05:29,170 --> 00:05:32,860
但这是此函数的最后一个参数， 

112
00:05:32,860 --> 00:05:35,350
所以我们知道当最后一个参数

113
00:05:35,350 --> 00:05:38,120
一个功能是另一个功能， 

114
00:05:38,319 --> 00:05:41,629
那么我们就可以删除该标签，将其关闭， 

115
00:05:41,629 --> 00:05:44,939
并让我们的功能有点浮在外面。 

116
00:05:44,939 --> 00:05:48,360
因此，这是我们网格的最后一个参数。 

117
00:05:48,360 --> 00:05:52,000
这就是它的两个变量，这个变量和viewForItem。 

118
00:05:52,000 --> 00:05:54,319
就像我们在这里叫CardView一样

119
00:05:54,319 --> 00:05:58,379
我们必须将其变量初始化为这个Card变量， 

120
00:05:58,379 --> 00:06:00,000
网格在这里也是一样。 

121
00:06:00,000 --> 00:06:02,029
我们正在初始化它的两个变量。 

122
00:06:03,250 --> 00:06:05,850
现在可能是谈论它的好时机

123
00:06:05,850 --> 00:06:09,050
 ForEach不必具有此标签项？ 

124
00:06:09,050 --> 00:06:13,509
当我们有了ForEach时，它就有了可迭代的东西

125
00:06:13,509 --> 00:06:15,279
里面有可识别的东西

126
00:06:15,279 --> 00:06:16,969
怎么没有争论呢？ 

127
00:06:16,970 --> 00:06:20,410
好吧，它使用的是您熟知的技术。 

128
00:06:20,410 --> 00:06:22,240
所以我们也要在Grid中做

129
00:06:22,240 --> 00:06:24,259
这只是一个初始化。 

130
00:06:24,459 --> 00:06:27,779
所以通常你可能会有你的init说项目

131
00:06:27,779 --> 00:06:32,779
是Item的数组，viewForItem是一个函数

132
00:06:32,910 --> 00:06:36,353
它接受一个I​​tem并返回一些ItemView。 

133
00:06:37,245 --> 00:06:38,846
那将是正常的初始化。 

134
00:06:38,846 --> 00:06:41,019
在这里，您只想

135
00:06:41,019 --> 00:06:43,209
初始化您的变量，例如项。 

136
00:06:43,209 --> 00:06:45,789
好吧，这等于传入的项目。 

137
00:06:45,790 --> 00:06:49,329
然后是viewForItem，它等于viewForItem 

138
00:06:49,529 --> 00:06:50,929
这已经过去了。 

139
00:06:50,930 --> 00:06:53,959
顺便说一句，斯威夫特在这里会很困惑

140
00:06:53,959 --> 00:06:58,239
因为它不知道这是什么

141
00:06:58,240 --> 00:06:59,680
以及这是什么项目。 

142
00:06:59,680 --> 00:07:02,569
我们对该函数有一个局部参数，称为items， 

143
00:07:02,569 --> 00:07:05,759
然后我们有一个称为项的属性。 

144
00:07:05,759 --> 00:07:08,519
这样您就可以在这里轻松解决Swift的困惑

145
00:07:08,519 --> 00:07:13,519
通过说出self.items和self.viewForItem。 

146
00:07:13,569 --> 00:07:15,812
这是不得不将自己放在这里的另一个原因

147
00:07:15,812 --> 00:07:20,699
比我们看到的明确的自我blah-blah命中修复方法要好。 

148
00:07:20,699 --> 00:07:22,159
但这在这里有意义，对吗？ 

149
00:07:22,160 --> 00:07:24,970
通过执行self.items，现在Swift知道我们在说

150
00:07:24,970 --> 00:07:26,009
关于绿色的， 

151
00:07:26,209 --> 00:07:28,262
而且这个一定是黑色的。 

152
00:07:29,620 --> 00:07:33,230
现在，这使我们可以将这个限制

153
00:07:33,230 --> 00:07:34,550
作为外部名称。 

154
00:07:34,550 --> 00:07:36,509
记住下标是外部名称

155
00:07:36,709 --> 00:07:40,259
表示不提供外部名称， 

156
00:07:40,259 --> 00:07:42,877
而这正是这里发生的事情。 

157
00:07:42,877 --> 00:07:45,980
如果我重建，你会看到

158
00:07:45,980 --> 00:07:48,300
这段代码在这里，非常好。 

159
00:07:49,589 --> 00:07:53,569
但是，我们的网格仍然存在问题。 

160
00:07:53,569 --> 00:07:55,269
这个错误就在这里。 

161
00:07:55,269 --> 00:07:58,156
它说：“分配非转义参数

162
00:07:58,156 --> 00:08:02,500
 “将'viewForItem'转换为@转义的闭包。” 

163
00:08:02,500 --> 00:08:05,449
所以我将尝试解释这种逃逸的关闭

164
00:08:05,449 --> 00:08:06,839
在短短几分钟内。 

165
00:08:06,839 --> 00:08:10,096
通常，我实际上可能会有幻灯片。 

166
00:08:10,096 --> 00:08:14,269
我本季将跳过该季度，因为在SwiftUI中， 

167
00:08:14,269 --> 00:08:16,189
由于我们正在执行函数式编程， 

168
00:08:16,189 --> 00:08:18,269
几乎所有东西都是价值类型

169
00:08:18,269 --> 00:08:21,560
以及这个逃逸的东西关闭的问题

170
00:08:21,560 --> 00:08:23,660
试图在这里解决

171
00:08:23,660 --> 00:08:26,310
在SwiftUI中确实非常罕见。 

172
00:08:26,509 --> 00:08:30,617
当我们进行面向对象编程时，发生了很多事情

173
00:08:30,617 --> 00:08:31,450
在UIkit中。 

174
00:08:32,570 --> 00:08:34,719
所以，这就是发生的事情。 

175
00:08:34,919 --> 00:08:37,089
这里传递的这个功能

176
00:08:37,090 --> 00:08:39,600
为给定项目创建视图

177
00:08:39,600 --> 00:08:42,779
在此初始值设定项中未实际使用。 

178
00:08:42,779 --> 00:08:46,089
我们将其盐腌入var中，稍后再调用。 

179
00:08:46,090 --> 00:08:47,950
我们要在我们体内称呼它

180
00:08:47,950 --> 00:08:49,849
当我们需要实际创建视图时

181
00:08:50,049 --> 00:08:52,120
对于我们所有的物品。 

182
00:08:52,120 --> 00:08:56,350
因此，我们必须标记这种功能@escaping。 

183
00:08:57,980 --> 00:09:00,139
您可以将其视为此功能

184
00:09:00,139 --> 00:09:04,189
将从这个初始化程序中逃脱

185
00:09:04,190 --> 00:09:05,703
没有被叫。 

186
00:09:06,549 --> 00:09:08,329
现在，Swift必须要小心， 

187
00:09:08,330 --> 00:09:10,230
它实际上非常强大

188
00:09:10,230 --> 00:09:12,269
并且知道如何处理这些功能

189
00:09:12,269 --> 00:09:14,250
以后可能会打电话给您。 

190
00:09:14,250 --> 00:09:15,990
为什么会是一个问题？ 

191
00:09:15,990 --> 00:09:18,419
好吧，让我们回顾这里

192
00:09:18,419 --> 00:09:20,169
传递此功能。 

193
00:09:20,169 --> 00:09:24,979
无论此处包含什么代码，都必须稍后才能调用。 

194
00:09:24,980 --> 00:09:27,609
因此，如果我们使用任何变量，尤其是如果我们使用

195
00:09:27,809 --> 00:09:31,149
局部变量或此函数中的某些内容， 

196
00:09:31,149 --> 00:09:34,419
将来必须存在

197
00:09:34,419 --> 00:09:36,562
该函数执行时。 

198
00:09:37,409 --> 00:09:41,039
现在，斯威夫特如何完成这项奇妙的壮举

199
00:09:41,039 --> 00:09:45,439
把所有东西都留在这里直到将来？ 

200
00:09:45,440 --> 00:09:48,199
好吧，它是通过创建函数类型来实现的

201
00:09:48,399 --> 00:09:50,149
是参考类型。 

202
00:09:50,149 --> 00:09:55,079
就像类一样，我们的ViewModel是引用类型， 

203
00:09:55,080 --> 00:09:56,469
他们住在堆里。 

204
00:09:56,669 --> 00:09:57,750
它们存储在内存中。 

205
00:09:57,750 --> 00:09:59,139
人们有指向他们的指针。 

206
00:09:59,139 --> 00:10:02,679
这些功能相同，可以稍后调用。 

207
00:10:02,679 --> 00:10:06,159
它们生活在堆中，并且有指向它们的指针。 

208
00:10:06,159 --> 00:10:11,159
现在，这里的东西也可能存在于堆中。 

209
00:10:11,549 --> 00:10:15,289
例如，如果这里的任何东西都是类， 

210
00:10:15,289 --> 00:10:18,339
那么这里的自我将成为一个指针

211
00:10:18,340 --> 00:10:19,759
堆中的东西。 

212
00:10:19,759 --> 00:10:23,490
而我们试图在Swift中避免的问题

213
00:10:23,490 --> 00:10:27,960
在自我中有一些变种

214
00:10:27,960 --> 00:10:30,480
实际指向此功能

215
00:10:30,480 --> 00:10:34,879
因为我们知道这个功能在这里指向自我。 

216
00:10:34,879 --> 00:10:36,429
他们俩都会在堆里。 

217
00:10:36,429 --> 00:10:37,629
该函数保存在堆中

218
00:10:37,629 --> 00:10:39,519
因为它将稍后执行。 

219
00:10:39,519 --> 00:10:42,210
函数内部的所有内容都保留在堆中

220
00:10:42,210 --> 00:10:44,720
以便以后可以正确执行。 

221
00:10:44,720 --> 00:10:47,440
因此，如果这里有任何提示， 

222
00:10:47,440 --> 00:10:49,609
我们遇到了堆中有两件事的情况

223
00:10:49,809 --> 00:10:51,839
互相指向。 

224
00:10:51,840 --> 00:10:54,469
以及Swift清理内存的方式

225
00:10:54,669 --> 00:10:57,059
当没有人指出某事时

226
00:10:57,059 --> 00:10:59,009
它清理内存并释放它

227
00:10:59,009 --> 00:11:00,389
供其他人使用。 

228
00:11:00,389 --> 00:11:02,519
好吧，如果两件事互相指向

229
00:11:02,519 --> 00:11:03,799
他们都在堆里， 

230
00:11:03,799 --> 00:11:05,870
他们永远也不会消失

231
00:11:05,870 --> 00:11:07,740
因为它们总是相互之间有一个指针。 

232
00:11:07,740 --> 00:11:10,750
这就是所谓的记忆周期。 

233
00:11:10,750 --> 00:11:14,440
所以，这整个过程就是要努力做到

234
00:11:14,440 --> 00:11:17,210
这样我们就可以检测到记忆周期

235
00:11:17,210 --> 00:11:20,590
通过查看这些转义功能。 

236
00:11:20,590 --> 00:11:25,590
令人惊讶的是，这也是为什么您会收到关于自我的警告。 

237
00:11:26,190 --> 00:11:28,590
你知道我们什么时候不放点

238
00:11:28,590 --> 00:11:30,359
在我们的onTapGesture函数中

239
00:11:30,559 --> 00:11:32,359
我们将得到这个错误，说

240
00:11:32,360 --> 00:11:34,659
这需要明确的自我

241
00:11:34,659 --> 00:11:37,399
使捕获语义明确。 

242
00:11:37,399 --> 00:11:40,139
捕获语义意味着事实

243
00:11:40,139 --> 00:11:42,720
捕捉这里的一切， 

244
00:11:42,720 --> 00:11:46,009
在此onTapGesture函数中， 

245
00:11:46,009 --> 00:11:48,509
并将其保留在堆中，以便在onTapGesture 

246
00:11:48,509 --> 00:11:52,500
将来在有人点击此即时贴时执行

247
00:11:52,500 --> 00:11:54,600
这些东西仍然存在。 

248
00:11:54,600 --> 00:11:55,720
好吧，如果您看这段代码， 

249
00:11:55,720 --> 00:11:58,219
您在想，“哦，我想它捕获了ViewModel，” 

250
00:11:58,419 --> 00:12:02,120
但实际上它必须捕获自己。 

251
00:12:02,120 --> 00:12:04,120
所以它让你输入自我

252
00:12:04,120 --> 00:12:05,950
让你意识到，哦，是的， 

253
00:12:05,950 --> 00:12:08,797
这个功能将使自己成为记忆。 

254
00:12:08,797 --> 00:12:10,959
然后您可以验证自己实际上并没有

255
00:12:11,159 --> 00:12:13,870
以某种方式直接或间接地回来

256
00:12:13,870 --> 00:12:16,820
并指向此功能， 

257
00:12:16,820 --> 00:12:19,719
在这种情况下它不会执行此操作，因为在这里， 

258
00:12:19,919 --> 00:12:22,269
我们的ViewModel从不指向我们的视图。 

259
00:12:22,269 --> 00:12:24,899
视图指向ViewModel，但不指向反向， 

260
00:12:24,899 --> 00:12:26,159
所以没问题

261
00:12:26,159 --> 00:12:29,579
但更重要的是，因为这个自我点

262
00:12:29,580 --> 00:12:31,209
反正不存在于堆中。 

263
00:12:31,409 --> 00:12:35,259
这个自我点就是这个结构，自我就是这个结构。 

264
00:12:35,259 --> 00:12:36,950
结构是值类型。 

265
00:12:36,950 --> 00:12:38,099
他们不住在堆里。 

266
00:12:38,299 --> 00:12:41,079
因此，无论如何都没有必要。 

267
00:12:41,080 --> 00:12:45,129
这就是已经公开批准的解决方案， 

268
00:12:45,129 --> 00:12:47,220
你可能会看到几个月

269
00:12:47,220 --> 00:12:49,120
制作完这段视频之后。 

270
00:12:49,120 --> 00:12:52,109
所以这部影片很快就会过时了。 

271
00:12:52,309 --> 00:12:55,529
但解决方法基本上是自我，在这种情况下， 

272
00:12:55,529 --> 00:12:57,990
这些转义功能之一的内部

273
00:12:57,990 --> 00:12:59,620
会被堆在堆里

274
00:12:59,620 --> 00:13:01,679
如果自我不生活在堆里， 

275
00:13:01,679 --> 00:13:05,599
换句话说，它是一个值类型，一个结构或一个枚举， 

276
00:13:05,600 --> 00:13:09,009
那么您不需要出现此错误

277
00:13:09,009 --> 00:13:11,746
并警告您：“嘿，在上面加点

278
00:13:11,746 --> 00:13:13,806
 “因此，请确保您没有记忆周期

279
00:13:13,807 --> 00:13:15,187
 “自我指向此功能的地方， 

280
00:13:15,187 --> 00:13:16,620
 “这个功能指向自我。” 

281
00:13:16,620 --> 00:13:19,230
那不可能发生，因为没有两件事

282
00:13:19,230 --> 00:13:20,470
在可能指向对方的堆中

283
00:13:20,470 --> 00:13:22,279
因为自我是一种结构。 

284
00:13:22,279 --> 00:13:24,529
这是一个值类型，不存在于堆中。 

285
00:13:26,000 --> 00:13:29,600
因此，您只需要快速了解一下

286
00:13:29,600 --> 00:13:32,349
所有这些转义，你甚至现在都明白

287
00:13:32,549 --> 00:13:34,059
这个自我点是什么。 

288
00:13:34,059 --> 00:13:36,479
如果你听不懂我说的话

289
00:13:36,480 --> 00:13:40,539
关于这些转义功能和这个自圆点， 

290
00:13:40,539 --> 00:13:43,279
真的，我认为您不必为此担心

291
00:13:43,279 --> 00:13:44,112
有几个原因。 

292
00:13:44,113 --> 00:13:46,440
一，这周的读物，你会读

293
00:13:46,440 --> 00:13:48,349
关于这些闭包，这些功能

294
00:13:48,549 --> 00:13:51,870
在线捕捉他们需要的东西

295
00:13:51,870 --> 00:13:53,669
以便以后执行。 

296
00:13:53,669 --> 00:13:56,089
因此，当您阅读该书时，也许您会理解的。 

297
00:13:56,090 --> 00:13:57,440
当然，您始终可以选择

298
00:13:57,440 --> 00:14:01,090
进入课堂论坛，询问更多有关澄清的信息。 

299
00:14:01,090 --> 00:14:04,959
最后，使用SwiftUI并不是那么重要

300
00:14:05,159 --> 00:14:09,110
因为这么多的自我点只是值类型。 

301
00:14:09,110 --> 00:14:12,840
例如，视图中的所有内容都是值类型。 

302
00:14:12,840 --> 00:14:14,969
我们的ViewModel，是一个类。 

303
00:14:15,169 --> 00:14:17,729
它有可能。 

304
00:14:17,730 --> 00:14:20,070
但是由于ViewModel从不指向任何东西

305
00:14:20,070 --> 00:14:21,959
在视图中，我们永远不必担心

306
00:14:22,159 --> 00:14:25,719
关于视图中创建这些内存周期的任何内容。 

307
00:14:25,720 --> 00:14:26,552
这将是非常罕见的。 

308
00:14:26,552 --> 00:14:28,840
可以做，但是非常非常罕见。 

309
00:14:28,840 --> 00:14:30,599
所以最重要的是，我认为您不必担心

310
00:14:30,799 --> 00:14:31,889
这么多。 

311
00:14:31,889 --> 00:14:33,240
唯一会困扰你的事情

312
00:14:33,240 --> 00:14:36,159
是你总是要把自我点

313
00:14:36,159 --> 00:14:37,500
在这些事情面前， 

314
00:14:37,500 --> 00:14:39,909
否则您将不得不处理此错误

315
00:14:39,909 --> 00:14:44,360
并执行此操作，单击它，然后一直进行修复。 

316
00:14:44,360 --> 00:14:47,289
同样，这只是您要做的事情

317
00:14:47,289 --> 00:14:49,750
直到这个公开事物的beta发布， 

318
00:14:49,750 --> 00:14:51,850
并希望在几个月内。 

319
00:14:51,850 --> 00:14:53,889
但是，最坏的情况是几个月。 

320
00:14:53,889 --> 00:14:56,379
在那之后，您将不必为此担心

321
00:14:56,379 --> 00:14:58,460
完全是因为不把自己放在这里

322
00:14:58,460 --> 00:15:02,120
当self是一个值类型时，不会生成此警告。 

323
00:15:02,120 --> 00:15:04,062
那就是建议的解决方法。 

324
00:15:05,330 --> 00:15:07,600
好吧，仅此而已。 

325
00:15:07,600 --> 00:15:10,089
这一切都是因为我们收到了这个警告

326
00:15:10,289 --> 00:15:12,179
告诉我们我们必须在这里逃跑

327
00:15:12,179 --> 00:15:16,287
因为确实，此函数确实会从此init逃脱

328
00:15:16,288 --> 00:15:18,529
因为我们把它放在这个变量中。 

329
00:15:18,529 --> 00:15:19,852
让我们做自己的身体。 

330
00:15:21,500 --> 00:15:24,179
我们的身体不是“你好，世界！”明显。 

331
00:15:24,179 --> 00:15:25,629
我们的身体实际上很简单。 

332
00:15:25,629 --> 00:15:28,985
这只是我们所有产品的前身。 

333
00:15:28,985 --> 00:15:31,993
对于我们的每个项目，我们将返回

334
00:15:31,993 --> 00:15:35,070
该Item的viewForItem。 

335
00:15:35,070 --> 00:15:37,345
我们将调用我们的函数viewForItem。 

336
00:15:37,345 --> 00:15:39,927
这是一个变量，这就是我们要称之为的函数。 

337
00:15:39,927 --> 00:15:41,480
当然，我们想要ForEach。 

338
00:15:41,480 --> 00:15:44,519
它还具有用于视图的转义功能， 

339
00:15:44,519 --> 00:15:46,663
所以我们必须说点自我。 

340
00:15:48,250 --> 00:15:52,049
这给我们带来了一些错误，让我们来看一下。 

341
00:15:52,049 --> 00:15:54,826
第一个说：“无法转换类型的值

342
00:15:54,826 --> 00:15:58,879
 “预期参数类型为“ Range of Int”的项目数组。” 

343
00:15:58,879 --> 00:16:01,879
哦，不，我们看到了这个确切的论点问题

344
00:16:01,879 --> 00:16:05,230
当我们第一次在这里做ForEach时。 

345
00:16:05,230 --> 00:16:06,769
我们正在通过这一系列卡片

346
00:16:06,769 --> 00:16:09,079
而且我们就像，哦，我以为我可以做到。 

347
00:16:09,080 --> 00:16:11,469
我们过去传递的零点数少于

348
00:16:11,669 --> 00:16:14,349
我们去了Array，我告诉过你

349
00:16:14,350 --> 00:16:16,109
此ForEach采用一个数组。 

350
00:16:16,309 --> 00:16:18,059
但是我们了解到这是一个数组

351
00:16:18,059 --> 00:16:21,159
只有可识别的事物。 

352
00:16:21,159 --> 00:16:23,579
所以我们在这里有同样的问题。 

353
00:16:23,580 --> 00:16:26,859
该项目的这个ForEach必须是一个数组

354
00:16:27,059 --> 00:16:29,289
可识别的事物。 

355
00:16:29,289 --> 00:16:33,730
嗯，这对我们来说是个问题，因为Item是无关紧要的。 

356
00:16:33,730 --> 00:16:36,259
我们不知道这是什么东西。 

357
00:16:36,259 --> 00:16:39,590
但是，这是我们在行为中获得约束和收获的地方。 

358
00:16:39,590 --> 00:16:44,590
我们要说项目在哪里可识别。 

359
00:16:44,639 --> 00:16:47,360
所以现在我们创建了一个仅适用于

360
00:16:47,360 --> 00:16:50,750
当您不在乎时，可以忽略此内容。 

361
00:16:50,750 --> 00:16:52,600
因此，这仍然可以是任何东西。 

362
00:16:52,600 --> 00:16:54,500
但是它必须是可识别的。 

363
00:16:54,500 --> 00:16:56,970
这就是我在幻灯片中所说的， 

364
00:16:56,970 --> 00:16:59,269
有点关心的事情。 

365
00:16:59,269 --> 00:17:00,909
我们有点关心Item。 

366
00:17:00,909 --> 00:17:02,832
我们关心它是可识别的。 

367
00:17:03,779 --> 00:17:05,904
所以现在我们这里有一个不同的错误。 

368
00:17:05,904 --> 00:17:07,287
这个ForEach错误是说

369
00:17:07,287 --> 00:17:10,967
 “归还财产'身体'的类型”，这就是我们的身体， 

370
00:17:10,967 --> 00:17:15,680
 “要求'ItemView'符合'View'。” 

371
00:17:15,680 --> 00:17:17,230
那么什么是ItemView？ 

372
00:17:17,230 --> 00:17:19,846
这是此函数的返回类型。 

373
00:17:19,846 --> 00:17:21,670
当然，这很有意义

374
00:17:21,670 --> 00:17:26,119
因为ForEach只能使用视图来拥有视图

375
00:17:26,319 --> 00:17:27,153
这些物品。 

376
00:17:27,153 --> 00:17:29,039
这必须是一个视图。 

377
00:17:29,039 --> 00:17:32,589
因此，这里的ViewForItem返回类型是ItemView， 

378
00:17:32,589 --> 00:17:33,679
它必须是一个视图。 

379
00:17:33,680 --> 00:17:34,930
那是什么类型？ 

380
00:17:34,930 --> 00:17:37,240
这也不在乎。 

381
00:17:37,240 --> 00:17:38,549
我们将在这里做同样的事情。 

382
00:17:38,549 --> 00:17:41,522
 ItemView必须是一个View。 

383
00:17:42,549 --> 00:17:45,549
大家都看到了我们如何连接泛型， 

384
00:17:45,549 --> 00:17:50,549
这是带有协议的非常通用的结构。 

385
00:17:50,750 --> 00:17:55,420
这些是协议，我们正在使用它们来约束

386
00:17:55,420 --> 00:17:57,623
这些无关紧要的工作。 

387
00:18:00,140 --> 00:18:03,399
我们在这里要做的下一件事是我们是一个容器。 

388
00:18:03,599 --> 00:18:05,980
网格包含所有这些视图。 

389
00:18:05,980 --> 00:18:07,450
它将它们放在行和列中。 

390
00:18:07,450 --> 00:18:08,769
它包含它们。 

391
00:18:08,769 --> 00:18:11,529
而且我们知道容器的工作就是占用空间

392
00:18:11,529 --> 00:18:14,259
提供给他们并划分

393
00:18:14,259 --> 00:18:16,269
里面的东西。 

394
00:18:16,269 --> 00:18:18,660
这意味着我们需要找出多少空间

395
00:18:18,660 --> 00:18:19,997
已分配给我们。 

396
00:18:19,997 --> 00:18:21,379
我们知道该怎么做。 

397
00:18:21,579 --> 00:18:23,586
那就是GeometryReader。 

398
00:18:23,586 --> 00:18:24,883
好的，GeometryReader。 

399
00:18:26,049 --> 00:18:28,710
几何形状将允许我们

400
00:18:28,710 --> 00:18:31,149
找出给网格多少空间， 

401
00:18:31,349 --> 00:18:34,642
然后我们将要交给这些家伙。 

402
00:18:36,410 --> 00:18:37,593
所以，把它放在这里。 

403
00:18:38,619 --> 00:18:40,729
现在，一旦放在这里， 

404
00:18:40,730 --> 00:18:43,779
当然，我们会遇到物品的自残问题。 

405
00:18:43,779 --> 00:18:46,829
我将使用与上次相同的解决方案， 

406
00:18:46,829 --> 00:18:48,419
我要在这里创建一个名为

407
00:18:48,420 --> 00:18:49,570
主体（尺寸：CGSize）。 

408
00:18:51,329 --> 00:18:54,259
当然会返回一些视图。 

409
00:18:54,259 --> 00:18:58,906
我要把我的代码放在这里。 

410
00:18:58,906 --> 00:19:01,807
在这里，我要做一个self.body（for：geometry.size）。 

411
00:19:04,200 --> 00:19:05,819
再说一次，这纯粹是为了做到这一点

412
00:19:05,819 --> 00:19:08,950
因此我不必在此体内做自我标记。 

413
00:19:08,950 --> 00:19:11,409
就像GeometryReader逃逸一样

414
00:19:11,609 --> 00:19:13,419
所以我们做了这个self.body， 

415
00:19:13,420 --> 00:19:16,409
 ForEach也正在逃避， 

416
00:19:16,609 --> 00:19:18,009
所以我要在这里做同样的事情

417
00:19:18,009 --> 00:19:19,559
 self.body（用于商品，大小）。 

418
00:19:22,374 --> 00:19:23,819
我要搬到

419
00:19:25,539 --> 00:19:30,349
另一个小功能主体（用于物品，尺寸） 

420
00:19:30,349 --> 00:19:31,462
打开一些视图。 

421
00:19:33,049 --> 00:19:35,960
现在，我不需要在这里加点。 

422
00:19:35,960 --> 00:19:37,002
只需退还。 

423
00:19:38,779 --> 00:19:41,660
因此，我们在这里很好地安排了代码。 

424
00:19:41,660 --> 00:19:43,759
我们剩下要做的，信不信由你， 

425
00:19:43,759 --> 00:19:48,069
实际上是在我们的某些空间中提供这些视图， 

426
00:19:48,069 --> 00:19:49,439
然后定位它们。 

427
00:19:49,440 --> 00:19:50,529
这就是容器的作用。 

428
00:19:50,529 --> 00:19:53,177
提供空间，他们就位。 

429
00:19:53,178 --> 00:19:54,970
为此，我们需要做一些数学运算

430
00:19:54,970 --> 00:19:56,549
因为我们得到了这个空间， 

431
00:19:56,549 --> 00:20:00,250
现在我们需要将其除以许多项

432
00:20:00,250 --> 00:20:01,839
我们在这里。 

433
00:20:01,839 --> 00:20:05,149
为了做那个数学，我实际上写了一些代码

434
00:20:05,150 --> 00:20:07,772
我给你的，我们将在这里使用。 

435
00:20:07,972 --> 00:20:09,349
让我们将其拖入。 

436
00:20:09,349 --> 00:20:11,409
顺便说一下，当您拖入代码时， 

437
00:20:11,410 --> 00:20:13,660
如果需要，请务必执行此操作。 

438
00:20:13,660 --> 00:20:15,169
几乎总是您想要的。 

439
00:20:15,369 --> 00:20:18,519
您希望将该代码的副本放入您的项目中。 

440
00:20:18,519 --> 00:20:21,250
否则，它将指向您的桌面

441
00:20:21,250 --> 00:20:22,849
或从何处拖动它。 

442
00:20:23,829 --> 00:20:25,429
好的，我们完成了。 

443
00:20:25,430 --> 00:20:27,109
因此，在这里让我们看一下这一点。 

444
00:20:27,309 --> 00:20:28,859
这是数学，这是GridLayout。 

445
00:20:28,859 --> 00:20:30,439
数学，它会进行此计算， 

446
00:20:30,440 --> 00:20:32,170
让我们来看一下。 

447
00:20:32,170 --> 00:20:37,170
现在，我在这里折叠了init和这两个var和func 

448
00:20:38,519 --> 00:20:41,680
因为我们不会看这些的实现。 

449
00:20:41,680 --> 00:20:44,529
在这堂课之后，我确实鼓励你， 

450
00:20:44,529 --> 00:20:47,190
去看看实现， 

451
00:20:47,190 --> 00:20:48,700
看看是否可以解决。 

452
00:20:48,700 --> 00:20:51,549
您需要本讲义的其余部分来掌握相关知识

453
00:20:51,549 --> 00:20:54,009
才能真正了解它在做什么， 

454
00:20:54,009 --> 00:20:56,379
但是尝试并理解这是一个很好的练习。 

455
00:20:56,380 --> 00:20:57,710
大约只有10行代码， 

456
00:20:57,710 --> 00:21:00,059
因此您应该不会有太多麻烦。 

457
00:21:00,910 --> 00:21:02,759
但是，这是GridLayout的作用。 

458
00:21:02,759 --> 00:21:07,759
其初始值设定项包含许多项目和一个大小， 

459
00:21:08,089 --> 00:21:10,509
然后将其除以这些项目。 

460
00:21:10,509 --> 00:21:12,650
它完全符合Grid的要求。 

461
00:21:12,650 --> 00:21:17,109
现在，它甚至还允许您指定所需的宽高比。 

462
00:21:17,309 --> 00:21:20,200
它不能保证，但是可以尝试接近它。 

463
00:21:20,200 --> 00:21:23,149
就是这样，我们只需创建一个做到这一点的GridLayout。 

464
00:21:23,349 --> 00:21:25,529
然后我们在这里有一个变量，它将告诉我们大小

465
00:21:25,529 --> 00:21:27,180
大小相同的商品中， 

466
00:21:27,180 --> 00:21:28,680
所以这就是大小。 

467
00:21:28,680 --> 00:21:31,639
然后还将每个项目的位置作为一个点。 

468
00:21:31,839 --> 00:21:34,029
这是每个项目的中心， 

469
00:21:34,029 --> 00:21:36,119
同样，这正是Grid想要的。 

470
00:21:36,119 --> 00:21:38,599
所以GridLayout绝对是考虑到Grid的， 

471
00:21:38,599 --> 00:21:43,059
但这几乎是CGSize的通用划分

472
00:21:43,910 --> 00:21:46,710
一定数量的项目。 

473
00:21:46,710 --> 00:21:48,450
因此，让我们创建此GridLayout 

474
00:21:48,450 --> 00:21:50,279
通过在此处调用此初始化程序。 

475
00:21:50,279 --> 00:21:53,430
我要在我的GeometryReader中完成它。 

476
00:21:53,430 --> 00:21:56,930
实际上，我将更改此尺寸的传递

477
00:21:56,930 --> 00:21:59,890
而是传递GridLayout。 

478
00:21:59,890 --> 00:22:03,000
而itemCount只是Items的数量

479
00:22:03,000 --> 00:22:03,859
我们有。 

480
00:22:03,859 --> 00:22:07,179
这是我们的项目Array，在这里，其数量。 

481
00:22:07,180 --> 00:22:10,419
我将跳过所需的宽高比的东西。 

482
00:22:10,619 --> 00:22:13,259
我们将使用任何默认值。 

483
00:22:13,259 --> 00:22:15,410
希望您在阅读中看到可以

484
00:22:15,410 --> 00:22:18,839
函数的默认参数，并且GridLayout使用它。 

485
00:22:19,039 --> 00:22:20,349
但是你一定要有尺寸

486
00:22:20,349 --> 00:22:24,057
这当然是在geometry.size中。 

487
00:22:24,057 --> 00:22:26,309
而且我们仍然在这里的GeometryReader 

488
00:22:26,309 --> 00:22:29,129
所以这个项目必须是self.items。 

489
00:22:29,130 --> 00:22:31,103
这是一个实例变量。 

490
00:22:32,220 --> 00:22:33,519
因此，我更改了此正文。 

491
00:22:33,519 --> 00:22:37,962
现在不再是尺寸的主体，而是布局的主体。 

492
00:22:39,450 --> 00:22:40,773
 GridLayout在这里。 

493
00:22:42,079 --> 00:22:44,679
同样，我将不得不通过

494
00:22:44,680 --> 00:22:46,830
所以现在是body（for：项目，in：布局）。 

495
00:22:49,383 --> 00:22:52,389
所以这也使它成为布局， 

496
00:22:52,589 --> 00:22:54,452
沿线向下传递。 

497
00:22:56,140 --> 00:22:58,460
现在我们在这里，我们有了这个布局， 

498
00:22:58,460 --> 00:23:01,970
并且我们已经按照尺寸大小列出了商品的数量。 

499
00:23:01,970 --> 00:23:06,660
因此，我们可以轻松地进行诸如为这些视图提供空间， 

500
00:23:06,660 --> 00:23:08,470
我们用框架来做。 

501
00:23:08,470 --> 00:23:10,269
所以我们要说框架的宽度

502
00:23:10,269 --> 00:23:13,599
是布局的itemSize.width， 

503
00:23:13,599 --> 00:23:18,132
框架的高度为layout.itemSize.height。 

504
00:23:18,133 --> 00:23:21,490
我们将提供相同的小空间

505
00:23:21,490 --> 00:23:25,329
每个物品的空间。 

506
00:23:25,329 --> 00:23:28,679
这就是GridLayout中的itemSize。 

507
00:23:28,680 --> 00:23:31,369
再次，GridLayout创建了这么多项目

508
00:23:31,569 --> 00:23:33,439
在提供给我们的尺寸上。 

509
00:23:33,440 --> 00:23:35,509
这就是我们将其划分的方式。 

510
00:23:35,509 --> 00:23:37,859
然后我们必须定位视图

511
00:23:37,859 --> 00:23:39,409
所以我们按位置来做。 

512
00:23:39,410 --> 00:23:41,380
这就是我们要做的功能。 

513
00:23:41,380 --> 00:23:45,369
我们将其放置在版面的位置

514
00:23:45,569 --> 00:23:48,000
 ofItemAt索引。 

515
00:23:48,000 --> 00:23:51,630
因此，这已被索引，就像我们使用卡片时一样。 

516
00:23:51,630 --> 00:23:55,230
所以我们必须找到该项目的索引

517
00:23:55,230 --> 00:23:57,173
在我们的商品数组中。 

518
00:23:58,039 --> 00:23:59,460
没问题，我们有点知道该怎么做。 

519
00:23:59,460 --> 00:24:01,649
我们说让索引相等， 

520
00:24:01,849 --> 00:24:03,689
嗯，我知道该怎么做。 

521
00:24:03,690 --> 00:24:08,620
我要在此商品的自我索引上创建一个函数。 

522
00:24:09,460 --> 00:24:12,777
我要去这里说（项的）func索引。 

523
00:24:14,540 --> 00:24:18,319
并且它将返回一个Int，即数组的索引。 

524
00:24:18,319 --> 00:24:20,569
我们先在这里返回零， 

525
00:24:20,569 --> 00:24:23,339
然后我们马上填写。 

526
00:24:23,339 --> 00:24:25,779
现在，这将再次让Swift感到困惑

527
00:24:25,779 --> 00:24:28,079
因为您有索引，此局部变量， 

528
00:24:28,079 --> 00:24:30,639
然后索引此函数。 

529
00:24:30,640 --> 00:24:34,259
因此，我们可以用相同的方法再次修复该问题。 

530
00:24:34,259 --> 00:24:37,710
现在知道该索引是函数， 

531
00:24:37,710 --> 00:24:40,890
这个索引是我们正在创建的局部变量。 

532
00:24:40,890 --> 00:24:43,000
因此，我们实际上使用了自我点。 

533
00:24:43,000 --> 00:24:46,869
即使他们使用值类型进行更改

534
00:24:46,869 --> 00:24:49,349
自我标记不会像这样被标记

535
00:24:49,349 --> 00:24:51,599
我们有时还是想使用自点

536
00:24:51,599 --> 00:24:56,409
定义属性之间的区别

537
00:24:56,410 --> 00:24:58,480
或函数与局部变量

538
00:24:58,480 --> 00:25:00,173
或函数的参数。 

539
00:25:01,660 --> 00:25:04,410
好吧，在这里的索引中，我们如何找到该项目

540
00:25:04,410 --> 00:25:05,042
在数组中？ 

541
00:25:05,242 --> 00:25:06,269
好吧，你猜怎么着？ 

542
00:25:06,269 --> 00:25:09,000
这些项目是可识别的。 

543
00:25:09,000 --> 00:25:10,386
也许你们当中有些像

544
00:25:10,386 --> 00:25:12,529
 “嗯，这似乎太熟悉了。” 

545
00:25:12,529 --> 00:25:15,160
是的，我们要做索引

546
00:25:15,160 --> 00:25:19,470
以零点表示的点数小于items.count 

547
00:25:19,470 --> 00:25:20,539
我们有。 

548
00:25:20,539 --> 00:25:24,589
如果该[index] .id中的项目

549
00:25:24,589 --> 00:25:27,589
等于该商品的ID， 

550
00:25:27,589 --> 00:25:30,984
然后我们将返回该索引。 

551
00:25:30,984 --> 00:25:33,119
否则我们将返回零， 

552
00:25:33,119 --> 00:25:38,119
这与我们上次这样做一样虚假。 

553
00:25:38,319 --> 00:25:41,899
现在，此功能有点双重伪造。 

554
00:25:41,900 --> 00:25:44,649
这是虚假的，因为我们仍在执行此返回零。 

555
00:25:44,849 --> 00:25:47,059
换句话说，如果我们找不到项目

556
00:25:47,059 --> 00:25:50,069
在我们的商品中，我们将只退回第一件商品， 

557
00:25:50,069 --> 00:25:51,386
索引为零。 

558
00:25:51,386 --> 00:25:52,799
真是假

559
00:25:52,799 --> 00:25:56,220
但是，还有一个错误是，这段代码是完全一样的， 

560
00:25:56,220 --> 00:26:01,220
是的，因为此代码在我们的模型中。 

561
00:26:01,519 --> 00:26:03,769
所以，伙计，你永远不想写

562
00:26:03,769 --> 00:26:06,160
完全一样的代码，像这样两次。 

563
00:26:06,160 --> 00:26:09,400
那只是糟糕的编程。 

564
00:26:09,400 --> 00:26:11,649
好吧，我们将在一分钟内解决该问题。 

565
00:26:11,849 --> 00:26:13,819
但是首先让我们看看我们的网格是否有效。 

566
00:26:13,819 --> 00:26:16,200
信不信由你，这就是我们网格所需要的。 

567
00:26:16,200 --> 00:26:16,832
没有别的了。 

568
00:26:17,032 --> 00:26:19,389
因此，我们得到了提供给我们的空间。 

569
00:26:19,390 --> 00:26:21,640
我们使用此GridLayout对其进行划分， 

570
00:26:21,640 --> 00:26:25,599
然后我们将其提供给其中的小子视图， 

571
00:26:25,799 --> 00:26:28,369
然后我们将它们放置在那些位置

572
00:26:28,369 --> 00:26:29,870
在GridLayout中。 

573
00:26:29,871 --> 00:26:33,000
这就是所需要的，所以让我们在这里进行一下测试。 

574
00:26:33,000 --> 00:26:34,022
看看是否有效。 

575
00:26:35,478 --> 00:26:36,450
嗯，确实如此。 

576
00:26:36,450 --> 00:26:39,410
瞧瞧，我们的六张卡已不再连续。 

577
00:26:39,410 --> 00:26:43,190
让我们去风景，看看，它调整了卡片的大小

578
00:26:43,190 --> 00:26:44,399
以更好地适应空间。 

579
00:26:44,599 --> 00:26:46,699
现在，我想要一点填充

580
00:26:46,700 --> 00:26:50,000
卡之间，但这是回事

581
00:26:50,000 --> 00:26:52,039
当我们创建CardView时

582
00:26:52,039 --> 00:26:55,460
我们可以在上面放一些填充物。 

583
00:26:55,460 --> 00:26:57,990
如果我们在这些CardView周围放置一些填充

584
00:26:57,990 --> 00:27:00,789
在网格内部，嗯，我们得到了填充。 

585
00:27:00,789 --> 00:27:01,899
很好。 

586
00:27:01,900 --> 00:27:03,670
也许我们不需要太多填充。 

587
00:27:03,670 --> 00:27:06,639
也许我们只想填充五个。 

588
00:27:06,839 --> 00:27:07,742
运行它。 

589
00:27:10,179 --> 00:27:11,829
呵呵，看起来不错。 

590
00:27:12,970 --> 00:27:15,819
好的，既然我们的网格正在工作， 

591
00:27:15,819 --> 00:27:19,109
让我们去修复我们这里存在的虚假代码， 

592
00:27:19,109 --> 00:27:21,509
这是项目的索引。 

593
00:27:21,509 --> 00:27:23,460
这是假的，因为这完全重复了

594
00:27:23,460 --> 00:27:24,809
这另一件事。 

595
00:27:24,809 --> 00:27:26,932
让我们考虑一下这里发生的事情。 

596
00:27:26,932 --> 00:27:30,809
在这两种情况下，我们实际上是在要求什么？ 

597
00:27:30,809 --> 00:27:34,659
我们有一系列可识别的事物， 

598
00:27:34,660 --> 00:27:38,009
希望我们有其中之一。 

599
00:27:38,009 --> 00:27:40,500
我们知道它也是可识别的。 

600
00:27:40,500 --> 00:27:42,869
我们想看看是否可以找到它。 

601
00:27:42,869 --> 00:27:46,822
因此，听起来更像是Array。 

602
00:27:48,630 --> 00:27:51,460
让我们向Array添加一个执行此操作的函数。 

603
00:27:51,460 --> 00:27:53,123
扩展数组。 

604
00:27:54,190 --> 00:27:59,190
但仅限于数组中的元素

605
00:27:59,730 --> 00:28:01,390
是可识别的。 

606
00:28:01,390 --> 00:28:03,873
因此，它又再次成为制约和收获。 

607
00:28:04,890 --> 00:28:07,930
此扩展仅将添加此功能

608
00:28:07,930 --> 00:28:10,483
我们想要添加到此类数组中的内容。 

609
00:28:11,380 --> 00:28:12,700
因此，它是相同的功能。 

610
00:28:12,700 --> 00:28:14,250
实际上，我只是要复制并粘贴

611
00:28:14,250 --> 00:28:16,819
我们将对其进行修改，甚至剪切并粘贴。 

612
00:28:16,819 --> 00:28:18,072
切掉那边。 

613
00:28:19,180 --> 00:28:20,169
将此粘贴在这里。 

614
00:28:20,369 --> 00:28:21,739
这里不一样

615
00:28:21,740 --> 00:28:23,883
因为我们在这里看物品。 

616
00:28:24,779 --> 00:28:27,420
显然，这是一个数组函数， 

617
00:28:27,420 --> 00:28:29,789
所以现在物品是自我。 

618
00:28:29,789 --> 00:28:30,909
还有同样的事情。 

619
00:28:30,910 --> 00:28:32,119
这不是物品的计数。 

620
00:28:32,319 --> 00:28:34,163
这是自我的计数。 

621
00:28:35,311 --> 00:28:39,469
这个项目的类型，项目的索引，不是项目。 

622
00:28:39,470 --> 00:28:42,539
这是元素，因为这就是我们要寻找的

623
00:28:42,539 --> 00:28:43,373
在一个数组。 

624
00:28:43,373 --> 00:28:46,170
我们有一个数组，其元素都是可识别的

625
00:28:46,170 --> 00:28:48,630
我们在这里说的是获取索引

626
00:28:48,630 --> 00:28:51,809
可识别的此数组的元素之一

627
00:28:52,009 --> 00:28:52,972
通过查找。 

628
00:28:54,269 --> 00:28:57,410
现在，这是正确的，这做对了， 

629
00:28:57,410 --> 00:29:01,129
但实际上我不喜欢在这里选择的命名。 

630
00:29:01,329 --> 00:29:03,980
关于这一点的一件事是它实际上并没有返回

631
00:29:03,980 --> 00:29:06,309
该项目的索引。 

632
00:29:06,309 --> 00:29:10,119
它返回找到的第一个。 

633
00:29:10,119 --> 00:29:12,869
从零开始遍历数组， 

634
00:29:12,869 --> 00:29:15,279
当找到一个时，将其返回。 

635
00:29:15,279 --> 00:29:19,742
因此，这确实是此项的第一个索引。 

636
00:29:20,779 --> 00:29:22,859
我也不喜欢这个词。 

637
00:29:22,859 --> 00:29:25,229
项目在网格中有意义

638
00:29:25,230 --> 00:29:26,259
因为我们有物品。 

639
00:29:26,259 --> 00:29:28,140
 “项目”一词遍地都是。 

640
00:29:28,140 --> 00:29:31,690
但实际上在Array中，Item不是一回事。 

641
00:29:31,690 --> 00:29:34,269
有元素，但没有项目。 

642
00:29:34,269 --> 00:29:37,470
实际上，这是第一个索引

643
00:29:37,470 --> 00:29:40,220
匹配该元素。 

644
00:29:40,220 --> 00:29:44,169
所以我将使用firstIndex匹配作为我的名字。 

645
00:29:44,369 --> 00:29:47,099
感觉更像是Array函数， 

646
00:29:47,099 --> 00:29:49,102
 firstIndex与此元素匹配。 

647
00:29:50,099 --> 00:29:52,079
那么，我们如何在这里使用它呢？ 

648
00:29:52,079 --> 00:29:53,730
而不是self.index， 

649
00:29:53,730 --> 00:29:57,289
我们只是要说项目，数组， 

650
00:29:57,289 --> 00:30:02,289
点firstIndex匹配项。 

651
00:30:03,720 --> 00:30:06,150
因此，我们要求Array立即执行此操作， 

652
00:30:06,150 --> 00:30:09,089
去找到与该项目匹配的第一个索引。 

653
00:30:09,289 --> 00:30:11,609
我们可以在这里做完全相同的事情。 

654
00:30:11,609 --> 00:30:14,259
我们甚至不再需要此功能。 

655
00:30:14,259 --> 00:30:17,740
我们在这里得到它是因为我们知道我们的卡阵列

656
00:30:17,740 --> 00:30:22,740
在这里可以做与Card匹配的firstIndex。 

657
00:30:26,000 --> 00:30:27,700
因此，我们正在重用此代码。 

658
00:30:27,700 --> 00:30:31,029
看看我们的模型有多小。 

659
00:30:31,029 --> 00:30:33,307
它很小，这里几乎没有任何代码。 

660
00:30:33,307 --> 00:30:35,670
其中一些是因为我们刚刚制作了Array 

661
00:30:35,670 --> 00:30:38,140
查找此功能的功能更强大。 

662
00:30:38,140 --> 00:30:39,380
与网格相同。 

663
00:30:39,380 --> 00:30:42,180
网格的代码很少

664
00:30:42,180 --> 00:30:44,379
因为我们利用了这个数组。 

665
00:30:44,579 --> 00:30:47,319
现在，这与Grid无关。 

666
00:30:47,319 --> 00:30:50,039
因此它不属于Grid.swift。 

667
00:30:50,039 --> 00:30:53,409
因此，我将其剪切为Grid.swift。 

668
00:30:53,410 --> 00:30:56,803
我将其放入自己的文件中。 

669
00:30:58,150 --> 00:30:59,349
它不是SwiftUI视图。 

670
00:30:59,549 --> 00:31:01,359
这只是一个普通的Swift文件。 

671
00:31:01,359 --> 00:31:04,139
现在，当我们进行这样的扩展时， 

672
00:31:04,140 --> 00:31:08,009
我们通常将文件扩展名为Array，我们正在扩展的东西， 

673
00:31:08,009 --> 00:31:10,500
加上某种描述符

674
00:31:10,500 --> 00:31:12,210
是什么样的东西

675
00:31:12,210 --> 00:31:16,079
因此，这是可识别的

676
00:31:16,079 --> 00:31:17,962
数组+可识别。 

677
00:31:19,220 --> 00:31:20,539
因此，让我们进入这里。 

678
00:31:20,539 --> 00:31:21,609
在那里。 

679
00:31:21,609 --> 00:31:22,729
粘贴进去。 

680
00:31:22,730 --> 00:31:26,720
请注意，这是导入基金会， 

681
00:31:26,720 --> 00:31:28,200
很好。 

682
00:31:28,200 --> 00:31:28,832
这不是UI问题。 

683
00:31:29,032 --> 00:31:32,509
这纯粹是数组和可标识的。 

684
00:31:32,509 --> 00:31:34,192
这些都不是UI的东西。 

685
00:31:35,500 --> 00:31:37,359
所以我们回到网格。 

686
00:31:37,359 --> 00:31:40,436
在这里进行构建，以便它注意到所有这些东西。 

687
00:31:40,436 --> 00:31:44,829
并确保我们的模型也可以正常工作。 

688
00:31:44,829 --> 00:31:47,480
没有错误，实际上，我们整个程序都没有错误。 

689
00:31:47,480 --> 00:31:50,863
让我们运行，确保数组确实正在执行。 

690
00:31:53,769 --> 00:31:58,019
好吧，再一次，我们正在使用整个概念

691
00:31:58,019 --> 00:31:59,279
的约束和收获。 

692
00:31:59,279 --> 00:32:04,059
在这里，我们限制了数组的无关类型

693
00:32:04,059 --> 00:32:05,500
这样就可以识别它们

694
00:32:05,500 --> 00:32:07,970
这样我们就可以使用此功能。 

695
00:32:07,970 --> 00:32:11,640
对于所有标识了元素的数组，它们都会得到此结果。 

696
00:32:11,640 --> 00:32:14,859
没有没有可识别元素的数组， 

697
00:32:15,059 --> 00:32:17,222
他们甚至看不到此功能。 

698
00:32:17,222 --> 00:32:19,309
甚至在Xcode中也无法完全逃脱。 

699
00:32:19,309 --> 00:32:20,312
甚至不在那里。 

700
00:32:21,740 --> 00:32:22,650
而且我们正在做同样的事情

701
00:32:22,650 --> 00:32:24,079
在这里有限制和收获

702
00:32:24,279 --> 00:32:27,099
使其成为我们的网格始终是网格

703
00:32:27,099 --> 00:32:31,669
可识别的事物，将两个事物匹配为视图。 

704
00:32:31,670 --> 00:32:32,899
本演示就是这样。 

705
00:32:33,099 --> 00:32:35,859
所以我要回到幻灯片， 

706
00:32:35,859 --> 00:32:37,929
我们将解决此问题。 

707
00:32:37,930 --> 00:32:40,700
我们需要Swift中称为Optional的类型， 

708
00:32:40,700 --> 00:32:43,539
一个非常非常重要的类型，它是一个枚举。 

709
00:32:43,539 --> 00:32:46,059
因此，让我们快速回顾一下枚举是什么， 

710
00:32:46,059 --> 00:32:47,359
然后我们将讨论

711
00:32:47,359 --> 00:32:49,784
这个非常重要的类型，可选。 

712
00:32:49,785 --> 00:32:53,250
枚举只是另一种类型，例如struct或class， 

713
00:32:53,250 --> 00:32:57,319
但是对于枚举，该值是离散的。 

714
00:32:57,319 --> 00:33:01,119
这里的好例子，FastFoodMenuItem是一个汉堡包

715
00:33:01,119 --> 00:33:03,349
还是薯条，饮料或饼干。 

716
00:33:03,349 --> 00:33:04,259
别无其他。 

717
00:33:04,259 --> 00:33:05,900
要成为这四件事之一。 

718
00:33:05,900 --> 00:33:07,480
那是菜单上唯一的东西， 

719
00:33:07,480 --> 00:33:10,682
它必须是其中之一，并且只是其中之一。 

720
00:33:11,900 --> 00:33:15,149
像结构一样，枚举是一种值类型。 

721
00:33:15,349 --> 00:33:17,289
传递时被复制。 

722
00:33:17,289 --> 00:33:18,399
它不存在于堆中。 

723
00:33:18,400 --> 00:33:19,970
没有指向它的指针。 

724
00:33:19,970 --> 00:33:21,252
这是一个值类型。 

725
00:33:22,410 --> 00:33:25,690
现在，Swift中的枚举最酷的地方是

726
00:33:25,690 --> 00:33:27,639
与大多数其他语言不同， 

727
00:33:27,839 --> 00:33:30,240
是每个离散值

728
00:33:30,240 --> 00:33:32,267
可以有一些相关的数据

729
00:33:32,267 --> 00:33:35,639
这是特定于特定离散值的。 

730
00:33:35,839 --> 00:33:39,569
例如，我们这里有汉堡包。 

731
00:33:39,569 --> 00:33:41,669
如果FastFoodMenuItem是一个汉堡包， 

732
00:33:41,670 --> 00:33:43,380
我们要说多少馅饼？ 

733
00:33:43,380 --> 00:33:46,159
这是两倍还是三倍还是单倍？ 

734
00:33:46,359 --> 00:33:49,909
如果是薯条，这是大薯条还是小薯条？ 

735
00:33:49,910 --> 00:33:53,909
如果是饮料，您会在那看到，您有饮料， 

736
00:33:54,109 --> 00:33:57,079
是可乐，胡椒博士等等。 

737
00:33:57,079 --> 00:33:59,099
请注意，这里没有为String命名， 

738
00:33:59,099 --> 00:34:01,679
所以这些东西不必一定要有名字。 

739
00:34:01,680 --> 00:34:04,980
您在这里看到的这种黄色语法

740
00:34:04,980 --> 00:34:07,990
从阅读中可能看起来很熟悉。 

741
00:34:07,990 --> 00:34:09,702
这只是一个元组。 

742
00:34:11,059 --> 00:34:15,190
因此，所有元组规则都允许您使用标签

743
00:34:15,190 --> 00:34:18,599
或没有标签，并在这里有您想要的数量， 

744
00:34:18,599 --> 00:34:20,440
全部完全有效

745
00:34:20,440 --> 00:34:23,023
作为此处的关联数据值。 

746
00:34:25,170 --> 00:34:28,039
那么如何设置枚举的值呢？ 

747
00:34:28,039 --> 00:34:29,550
非常简单

748
00:34:29,550 --> 00:34:31,769
你只说枚举的名字， 

749
00:34:31,969 --> 00:34:35,750
如FastFoodMenuItem，点，离散值， 

750
00:34:35,750 --> 00:34:38,829
汉堡或饼干，例如这里。 

751
00:34:38,829 --> 00:34:41,889
现在，当然，如果有关联的数据， 

752
00:34:41,889 --> 00:34:44,629
您必须提供相关数据。 

753
00:34:44,630 --> 00:34:47,365
在这种情况下，汉堡（馅饼：2）。 

754
00:34:47,565 --> 00:34:51,232
它无法制造汉堡包

755
00:34:51,233 --> 00:34:53,220
如果不知道有多少馅饼

756
00:34:54,159 --> 00:34:56,230
现在Swift可以在这里进行类型推断

757
00:34:56,230 --> 00:34:58,750
这样您就不必键入FastFoodMenuItem 

758
00:34:58,750 --> 00:35:01,130
双方平等。 

759
00:35:01,130 --> 00:35:02,670
但是您必须小心一点。 

760
00:35:02,670 --> 00:35:04,769
你必须把它放在平等的一面

761
00:35:04,769 --> 00:35:06,559
因为如果你只是说

762
00:35:06,559 --> 00:35:09,029
 var yetAnotherItem等于Cookie， 

763
00:35:09,030 --> 00:35:10,750
 Swift没有足够的信息

764
00:35:10,949 --> 00:35:14,029
推断我们在这里谈论快餐菜单项。 

765
00:35:14,030 --> 00:35:16,355
可能是任何有cookie的东西。 

766
00:35:16,355 --> 00:35:20,210
所以你必须在某个地方出现FastFoodMenuItem 

767
00:35:20,210 --> 00:35:22,123
以便Swift可以推断。 

768
00:35:23,659 --> 00:35:25,759
我们如何检查值？ 

769
00:35:25,760 --> 00:35:27,630
您可能会认为这就像一个假设。 

770
00:35:27,829 --> 00:35:30,942
你知道，如果这个菜单项等于一个汉堡， 

771
00:35:30,943 --> 00:35:32,250
然后做点什么。 

772
00:35:32,250 --> 00:35:33,710
但是我们不使用if枚举。 

773
00:35:33,710 --> 00:35:36,510
我们使用此表达式开关。 

774
00:35:36,510 --> 00:35:38,400
现在，开关以其他语言存在。 

775
00:35:38,599 --> 00:35:40,230
它在Swift中非常强大

776
00:35:40,230 --> 00:35:43,409
不仅用于检查您将要看到的枚举， 

777
00:35:43,409 --> 00:35:45,170
但是它有正则表达式匹配

778
00:35:45,170 --> 00:35:46,003
和各种各样的东西。 

779
00:35:46,003 --> 00:35:48,309
再一次，你希望读到

780
00:35:48,309 --> 00:35:49,682
在阅读作业中。 

781
00:35:50,960 --> 00:35:53,670
因此，如果我想检查menuItem的值， 

782
00:35:53,670 --> 00:35:55,099
我要打开menuItem， 

783
00:35:55,099 --> 00:35:57,339
然后有一个案例陈述

784
00:35:57,340 --> 00:35:59,547
对于每个可能的menuItem。 

785
00:35:59,547 --> 00:36:02,860
它必须是每一个。 

786
00:36:02,860 --> 00:36:05,349
现在，我不在这里

787
00:36:05,349 --> 00:36:08,849
关联的数据，在这里我可以忽略它。 

788
00:36:08,849 --> 00:36:12,319
我仍然可以使用Case FastFoodMenuItem.hamburger 

789
00:36:12,320 --> 00:36:13,750
打印单词burger。 

790
00:36:13,949 --> 00:36:15,649
我不能说是多少馅饼

791
00:36:15,650 --> 00:36:17,519
因为我没有看相关的数据。 

792
00:36:17,719 --> 00:36:19,079
我要告诉你一秒钟。 

793
00:36:19,079 --> 00:36:21,773
但是我仍然可以在这里打印汉堡。 

794
00:36:23,349 --> 00:36:25,429
斯威夫特当然可以推断

795
00:36:25,429 --> 00:36:27,089
这些都是快餐菜单项， 

796
00:36:27,090 --> 00:36:28,050
所以你不必说

797
00:36:28,050 --> 00:36:31,190
每次都是FastFoodMenuItem.hamburger。 

798
00:36:31,389 --> 00:36:32,969
您可以仅打开menuItem。 

799
00:36:32,969 --> 00:36:35,189
使用.hamburger，.fries和.drink。 

800
00:36:35,190 --> 00:36:38,472
在这种情况下，它知道menuItem是FastFoodMenuItem。 

801
00:36:40,260 --> 00:36:42,230
顺便说一句，开关要求您遮盖

802
00:36:42,429 --> 00:36:44,109
每一个可能的情况。 

803
00:36:44,110 --> 00:36:46,309
因此，您可能会有一个案例，例如汉堡包， 

804
00:36:46,309 --> 00:36:47,179
你不在乎的

805
00:36:47,179 --> 00:36:49,449
您不想打印出汉堡包。 

806
00:36:49,449 --> 00:36:51,379
在这种情况下，您可以说休息一下。 

807
00:36:51,380 --> 00:36:53,980
因此，突破突围， 

808
00:36:53,980 --> 00:36:57,119
并说案子.hamburger中断意味着它将无能为力

809
00:36:57,119 --> 00:37:00,000
如果菜单项是汉堡包。 

810
00:37:00,000 --> 00:37:03,309
同样，如果您真的只关心几种情况

811
00:37:03,309 --> 00:37:06,119
其他所有，您都可以执行一些默认行为， 

812
00:37:06,119 --> 00:37:08,789
您可以使用特殊关键字default。 

813
00:37:08,789 --> 00:37:12,009
因此，如果您未列出，则会发生默认情况

814
00:37:12,010 --> 00:37:13,690
一个特定的情况。 

815
00:37:13,889 --> 00:37:15,049
但是您必须做另一件事。 

816
00:37:15,050 --> 00:37:17,210
要么你有所有的情况

817
00:37:17,210 --> 00:37:19,269
而那些你不在乎的人会爆发出来， 

818
00:37:19,469 --> 00:37:21,089
或者你只能有一些情况， 

819
00:37:21,090 --> 00:37:22,663
但是您必须提供此默认情况。 

820
00:37:22,862 --> 00:37:24,869
通常在交换机中是必需的。 

821
00:37:24,869 --> 00:37:27,069
不只是枚举，而且在Swift中， 

822
00:37:27,070 --> 00:37:29,650
开关需要完全覆盖

823
00:37:29,849 --> 00:37:31,272
所有的可能性。 

824
00:37:33,349 --> 00:37:35,150
那相关的数据呢？ 

825
00:37:35,150 --> 00:37:37,280
好吧，我们也可以在切换中做到这一点。 

826
00:37:37,280 --> 00:37:39,900
我们只在这里以黄色添加您看到的内容

827
00:37:40,099 --> 00:37:41,819
当我们说案例。汉堡时， 

828
00:37:41,820 --> 00:37:44,570
我们说括号，让pattyCount。 

829
00:37:44,570 --> 00:37:47,380
这将获取与汉堡相关的数据

830
00:37:47,380 --> 00:37:51,289
并将其分配给这个很小的局部变量pattyCount 

831
00:37:51,489 --> 00:37:54,069
仅对此打印语句有效

832
00:37:54,070 --> 00:37:57,130
或这个汉堡之后发生的一切。 

833
00:37:57,130 --> 00:37:59,059
炸薯条也是一样。 

834
00:37:59,059 --> 00:38:01,349
例如，这种饮料很有趣。 

835
00:38:01,349 --> 00:38:04,639
因此，饮料将抢占品牌和盎司。 

836
00:38:04,639 --> 00:38:08,319
请注意，盎司在我声明时曾经带有标签， 

837
00:38:08,320 --> 00:38:11,016
但是我没有在那做，没关系

838
00:38:11,016 --> 00:38:11,849
因为这是元组。 

839
00:38:11,849 --> 00:38:15,559
元组，如果要在两面都可以使用标签， 

840
00:38:15,559 --> 00:38:16,880
声明和使用它。 

841
00:38:16,880 --> 00:38:20,059
因此，这是完全相同的事情

842
00:38:20,059 --> 00:38:22,849
您可以在其中获取相关值

843
00:38:22,849 --> 00:38:24,583
但是，您想抓住它。 

844
00:38:26,500 --> 00:38:28,599
好吧，让我们看看。 

845
00:38:28,599 --> 00:38:32,730
方法，是的，您可以在枚举上使用方法。 

846
00:38:32,730 --> 00:38:36,000
无论您想做什么，它几乎都是无限的。 

847
00:38:36,000 --> 00:38:39,349
属性，您可以计算出属性， 

848
00:38:39,349 --> 00:38:41,909
但是您不能有任何存储的属性。 

849
00:38:41,909 --> 00:38:44,719
带有枚举的所有存储

850
00:38:44,719 --> 00:38:47,259
仅在这些关联的值中， 

851
00:38:47,260 --> 00:38:50,000
有点意思，因为一个枚举是一个离散的事情。 

852
00:38:50,199 --> 00:38:52,899
拥有其他数据真的没有任何意义

853
00:38:52,900 --> 00:38:54,110
适用于所有这些。 

854
00:38:54,110 --> 00:38:55,410
那不是离散的。 

855
00:38:56,402 --> 00:38:58,992
因此，这就是为什么您必须这样做。 

856
00:39:02,250 --> 00:39:03,170
开启自我。 

857
00:39:03,170 --> 00:39:07,190
好吧，如果您的枚举中包含函数， 

858
00:39:07,190 --> 00:39:09,869
它实际上应该告诉你一些东西

859
00:39:09,869 --> 00:39:12,210
关于枚举，这是很常见的

860
00:39:12,210 --> 00:39:13,519
具有这些功能。 

861
00:39:13,519 --> 00:39:17,340
这里我有这个函数isIncludedInSpecialOrder号， 

862
00:39:17,340 --> 00:39:20,610
会说这个FastFoodMenuItem 

863
00:39:20,610 --> 00:39:22,710
包含在特定的特殊顺序中。 

864
00:39:22,909 --> 00:39:25,829
为此，我必须打开自己

865
00:39:25,829 --> 00:39:28,469
看看我是什么，看看我是否被包括在内

866
00:39:28,469 --> 00:39:29,789
以这种特殊的顺序。 

867
00:39:29,789 --> 00:39:32,400
这样您就可以看到我有很多示例。 

868
00:39:32,400 --> 00:39:35,619
我想更仔细地研究这些例子之一， 

869
00:39:35,619 --> 00:39:37,609
这是这个饮料的例子。 

870
00:39:37,610 --> 00:39:41,480
请注意，它正在开关中获取关联的值

871
00:39:41,480 --> 00:39:43,909
盎司，但它忽略了

872
00:39:43,909 --> 00:39:45,279
无论是可乐还是胡椒博士。 

873
00:39:45,280 --> 00:39:46,289
我们不在乎。 

874
00:39:46,489 --> 00:39:48,569
是否包含在内都没有关系

875
00:39:48,570 --> 00:39:49,690
以特殊的顺序。 

876
00:39:49,889 --> 00:39:54,289
因此，此下标是无需关注的地方， 

877
00:39:54,289 --> 00:39:56,329
本质上我不感兴趣。 

878
00:39:56,329 --> 00:39:58,139
就像我们有功能一样

879
00:39:58,139 --> 00:40:00,769
它具有带有外部名称的参数

880
00:40:00,769 --> 00:40:03,159
和内部名称，我们使用下划线表示

881
00:40:03,159 --> 00:40:05,609
我们对外部名称不感兴趣，请勿使用它。 

882
00:40:05,610 --> 00:40:07,289
这也是这里的意思。 

883
00:40:07,289 --> 00:40:10,739
所以这就是如果您有一些相关的价值

884
00:40:10,739 --> 00:40:12,259
作为具有多个要素的元组， 

885
00:40:12,260 --> 00:40:13,820
您可以忽略其中一些

886
00:40:14,019 --> 00:40:15,570
当您获得价值时。 

887
00:40:19,889 --> 00:40:22,139
枚举可以通过协议来约束和收获

888
00:40:22,139 --> 00:40:24,319
就像结构和类一样。 

889
00:40:24,320 --> 00:40:27,120
有一个非常有趣的协议，称为CaseIterable。 

890
00:40:28,179 --> 00:40:32,045
 CaseIterable，您将获得一个名为allCases的变量。 

891
00:40:32,045 --> 00:40:34,569
它是静态var，因此您将其发送给类型， 

892
00:40:34,570 --> 00:40:37,650
就像这里，在这里看到的TeslaModel.allCases。 

893
00:40:37,849 --> 00:40:42,489
这只会给您带来麻烦

894
00:40:42,489 --> 00:40:46,206
在所有情况下，您都可以做一些事情。 

895
00:40:46,206 --> 00:40:47,730
那可能是非常有价值的。 

896
00:40:47,730 --> 00:40:50,090
在作业三中，您可能要去

897
00:40:50,090 --> 00:40:51,980
需要使用它。 

898
00:40:51,980 --> 00:40:53,920
现在我们知道了一个枚举， 

899
00:40:53,920 --> 00:40:57,550
我们可以谈论最重要的枚举

900
00:40:57,550 --> 00:41:02,333
在所有Swift中，这称为Optional。 

901
00:41:03,869 --> 00:41:07,000
因此，一个Optional基本上看起来像这样。 

902
00:41:07,000 --> 00:41:09,869
它有两个离散值。 

903
00:41:09,869 --> 00:41:14,759
一种情况是没有情况，一种情况是一些情况。 

904
00:41:14,760 --> 00:41:17,900
在某些情况下，它具有关联的价值， 

905
00:41:17,900 --> 00:41:19,077
不在乎。 

906
00:41:19,077 --> 00:41:21,590
因此，可选，可选适用于任何类型。 

907
00:41:21,590 --> 00:41:24,570
不管它是什么类型。 

908
00:41:24,570 --> 00:41:26,420
因此从本质上讲，Optional是

909
00:41:26,619 --> 00:41:29,559
是一个固定的情况，就是这样， 

910
00:41:29,559 --> 00:41:33,099
或没有设置的情况，就是没有。 

911
00:41:33,099 --> 00:41:34,889
这就是可选的。 

912
00:41:34,889 --> 00:41:36,349
本质上是一种类型。 

913
00:41:36,349 --> 00:41:38,369
您将拥有Optional类型的变量。 

914
00:41:38,369 --> 00:41:40,449
他们将被设置或未设置。 

915
00:41:40,449 --> 00:41:43,369
如果设置了它们，它们将具有关联的价值

916
00:41:43,369 --> 00:41:48,369
某种类型，而Optional不在乎是什么类型。 

917
00:41:48,940 --> 00:41:50,070
那么我们在哪里使用Optional？ 

918
00:41:50,070 --> 00:41:53,090
好吧，您可以想象我们会随时使用它

919
00:41:53,090 --> 00:41:55,460
我们有一个变量，其值

920
00:41:55,460 --> 00:42:00,019
可能未设置，未指定或不确定， 

921
00:42:00,019 --> 00:42:01,402
诸如此类的东西。 

922
00:42:02,449 --> 00:42:03,319
有什么例子？ 

923
00:42:03,320 --> 00:42:07,880
好吧，该假返回的firstIndex匹配类型。 

924
00:42:08,079 --> 00:42:10,269
如果匹配的东西不在数组中， 

925
00:42:10,269 --> 00:42:12,280
我们目前返回零。 

926
00:42:12,280 --> 00:42:13,840
那是数组中的第一个元素。 

927
00:42:13,840 --> 00:42:15,039
那是完全错误的。 

928
00:42:15,039 --> 00:42:17,449
因此，我们将拥有firstIndex匹配的

929
00:42:17,449 --> 00:42:19,460
返回类型为Optional。 

930
00:42:19,460 --> 00:42:24,039
这将是一个Optional，而相关的值为Int。 

931
00:42:24,039 --> 00:42:26,190
因此，它要么返回设置，要么不设置。 

932
00:42:26,190 --> 00:42:29,190
如果能够的话，它将返回设置

933
00:42:30,420 --> 00:42:32,230
关联的值将是索引。 

934
00:42:32,429 --> 00:42:36,179
否则它将返回未设置状态

935
00:42:36,179 --> 00:42:40,269
如果它在那里找不到匹配的东西。 

936
00:42:40,269 --> 00:42:43,769
普通变量的另一个很好的例子

937
00:42:43,769 --> 00:42:47,250
假设是在模型的配对游戏中

938
00:42:47,250 --> 00:42:49,340
如果我有一个像这样的变量怎么办

939
00:42:49,340 --> 00:42:52,440
当前面朝上卡的索引？ 

940
00:42:52,440 --> 00:42:55,530
好的，当游戏开始时，没有面朝上的卡片。 

941
00:42:55,530 --> 00:42:56,750
那么那个索引是什么呢？ 

942
00:42:56,750 --> 00:42:58,360
就像，它没有设置。 

943
00:42:58,360 --> 00:43:01,460
因此，我们将使用Optional来存储它。 

944
00:43:01,659 --> 00:43:04,864
该var不会是索引的Int类型。 

945
00:43:04,864 --> 00:43:06,569
它的类型将为Optional。 

946
00:43:06,570 --> 00:43:07,960
现在关联的值将是一个Int 

947
00:43:08,159 --> 00:43:10,019
当然，如果已设置， 

948
00:43:10,019 --> 00:43:12,070
我们想知道Int是什么。 

949
00:43:12,070 --> 00:43:14,070
我要展示几个很好的例子

950
00:43:14,070 --> 00:43:15,653
在此之后的演示中。 

951
00:43:17,019 --> 00:43:18,619
因此，这种情况经常发生

952
00:43:18,619 --> 00:43:22,989
您需要一些有时未设置的变量， 

953
00:43:22,989 --> 00:43:24,349
未指定。 

954
00:43:24,349 --> 00:43:27,172
您想返回一个值，说我做不到， 

955
00:43:27,172 --> 00:43:28,849
这样的东西。 

956
00:43:28,849 --> 00:43:33,219
因此，Swift引入了很多语法糖， 

957
00:43:33,219 --> 00:43:37,279
基本上是特殊的语法，以便使其变得真正容易

958
00:43:37,280 --> 00:43:39,230
使用Optional，以至于您会认为

959
00:43:39,429 --> 00:43:42,989
在Swift中，Optionals只是一种魔术类型。 

960
00:43:42,989 --> 00:43:45,149
但是，所有这一切都只是这个枚举。 

961
00:43:45,150 --> 00:43:48,230
确实没有什么比这更多的了。 

962
00:43:48,230 --> 00:43:51,500
因此，让我们看一下所有这些语法糖。 

963
00:43:51,500 --> 00:43:55,659
第一个是我们如何声明或说

964
00:43:55,659 --> 00:43:57,219
我们想要这种类型？ 

965
00:43:57,219 --> 00:44:00,589
所以在这里以黄色显示，您看到的是String ？。 

966
00:44:00,590 --> 00:44:03,940
那就是说你好，这个var你好， 

967
00:44:04,139 --> 00:44:06,549
是Optional类型的

968
00:44:06,550 --> 00:44:09,769
一个可选的，其关联值为字符串。 

969
00:44:09,769 --> 00:44:12,360
我们将其称为Optional String。 

970
00:44:12,360 --> 00:44:14,579
当学生第一次接触到这一点时， 

971
00:44:14,579 --> 00:44:18,219
他们认为hello的类型是String 

972
00:44:18,219 --> 00:44:21,409
以某种方式修改为可选。 

973
00:44:21,409 --> 00:44:24,730
不，您好的类型是可选的。 

974
00:44:24,730 --> 00:44:27,559
它的关联值是一个字符串，但它是可选的。 

975
00:44:27,559 --> 00:44:29,119
这就是我们声明的方式。 

976
00:44:29,119 --> 00:44:32,009
这就是我们键入类型的方式， 

977
00:44:32,010 --> 00:44:36,083
我们如何用手指键入“可选字符串”类型。 

978
00:44:37,199 --> 00:44:38,879
现在如何设置值？ 

979
00:44:38,880 --> 00:44:41,480
很好记住，一个可选的字符串，它是一个可选的。 

980
00:44:41,480 --> 00:44:43,760
它只有两种情况，没有和一些。 

981
00:44:43,760 --> 00:44:47,289
因此，我们只说等于nil就设置了none。 

982
00:44:47,489 --> 00:44:52,239
因此，Swift中的关键字nil表示Optional.none。 

983
00:44:52,239 --> 00:44:55,982
这意味着未设置Optional的情况为nil。 

984
00:44:57,340 --> 00:45:00,320
同样，我们可以说，你好， 

985
00:45:00,320 --> 00:45:02,420
此Optional String等于String hello。 

986
00:45:02,619 --> 00:45:04,859
斯威夫特足够聪明，知道那意味着

987
00:45:04,860 --> 00:45:07,130
将此情况设置为Optional 

988
00:45:07,130 --> 00:45:10,023
并使用hello作为关联值。 

989
00:45:11,329 --> 00:45:14,500
这样就设置了String（在这种情况下，您好）， 

990
00:45:14,500 --> 00:45:17,922
并且它的关联值是hello。 

991
00:45:19,690 --> 00:45:23,150
请注意，Optionals总是开始

992
00:45:23,150 --> 00:45:25,920
隐式等于nil。 

993
00:45:25,920 --> 00:45:28,940
很好，因为请记住在结构和类中， 

994
00:45:28,940 --> 00:45:31,110
所有变量必须具有初始值。 

995
00:45:31,110 --> 00:45:32,190
我们跳了很多圈

996
00:45:32,389 --> 00:45:33,799
尝试获取我们所有的var 

997
00:45:33,800 --> 00:45:36,000
到目前为止具有初始值。 

998
00:45:36,000 --> 00:45:38,219
好吧，可选，没有任何障碍

999
00:45:38,219 --> 00:45:40,469
因为它得到一个隐式等于nil， 

1000
00:45:40,469 --> 00:45:45,349
或在枚举世界中，对于所有var来说，都为无。 

1001
00:45:45,349 --> 00:45:47,719
没错，对，因为这里有一个Optional。 

1002
00:45:47,719 --> 00:45:48,869
它已设置或未设置。 

1003
00:45:48,869 --> 00:45:50,889
好吧，它将开始没有设置。 

1004
00:45:50,889 --> 00:45:54,389
如果您愿意，可以将其初始化为“ hello”， 

1005
00:45:54,389 --> 00:45:56,549
但是您可以不对其进行初始化， 

1006
00:45:56,550 --> 00:45:58,070
但是它并不是真正未初始化的。 

1007
00:45:58,070 --> 00:46:00,593
确实将其初始化为none。 

1008
00:46:01,510 --> 00:46:03,070
那么如何访问值呢？ 

1009
00:46:03,269 --> 00:46:06,070
假设我有一个像你好一样的变种， 

1010
00:46:06,070 --> 00:46:08,690
这是一个Optional，Optional String， 

1011
00:46:08,889 --> 00:46:10,679
我想要的字符串。 

1012
00:46:10,679 --> 00:46:12,690
如何获得字符串？ 

1013
00:46:12,690 --> 00:46:14,010
我如何获得相关的价值？ 

1014
00:46:14,010 --> 00:46:16,190
我要做什么，就像您在右边看到的那样， 

1015
00:46:16,389 --> 00:46:18,529
打开它，然后做这种情况？ 

1016
00:46:18,530 --> 00:46:19,670
当然不是。 

1017
00:46:19,670 --> 00:46:22,349
有一种简单的方法可以打开它。 

1018
00:46:22,349 --> 00:46:23,299
实际上有两种方式。 

1019
00:46:23,300 --> 00:46:25,070
一是感叹号。 

1020
00:46:25,070 --> 00:46:27,710
如果您在变数后面加上感叹号

1021
00:46:27,909 --> 00:46:31,000
这是一个可选的，它将假设

1022
00:46:31,000 --> 00:46:33,500
在某些情况下，固定的情况下， 

1023
00:46:33,500 --> 00:46:35,650
并获得相关的价值。 

1024
00:46:35,650 --> 00:46:38,630
但是，如果不是这样，它将导致程序崩溃。 

1025
00:46:38,630 --> 00:46:40,820
感叹号是真的，我们称之为

1026
00:46:40,820 --> 00:46:44,130
强制展开，因为您要强制展开

1027
00:46:44,130 --> 00:46:45,750
被解开，给我那个字符串。 

1028
00:46:45,949 --> 00:46:47,099
但是如果那个字符串不存在

1029
00:46:47,099 --> 00:46:49,009
因为在未设置的情况下是Optional， 

1030
00:46:49,010 --> 00:46:50,237
然后它会使您的程序崩溃。 

1031
00:46:50,436 --> 00:46:51,980
我们将在演示中看到

1032
00:46:51,980 --> 00:46:54,248
这听起来像啊，我永远都不会使用。 

1033
00:46:54,248 --> 00:46:55,819
我永远不会希望我的程序崩溃。 

1034
00:46:55,820 --> 00:46:57,210
但这实际上可能非常有用

1035
00:46:57,210 --> 00:46:59,039
如果您知道这是绝对不应该的

1036
00:46:59,039 --> 00:47:00,179
确实如此。 

1037
00:47:00,179 --> 00:47:03,549
您可以轻松找到开发中的错误以及所有这些

1038
00:47:03,550 --> 00:47:05,039
通过使事情崩溃并说， 

1039
00:47:05,039 --> 00:47:07,349
 “哇，那本不应该崩溃的。” 

1040
00:47:07,349 --> 00:47:09,929
但是有一种安全的方法

1041
00:47:09,929 --> 00:47:12,980
就是将其分配给另一个变量， 

1042
00:47:12,980 --> 00:47:14,090
一个安全的变量。 

1043
00:47:14,090 --> 00:47:16,039
如果允许，您可以这样做。 

1044
00:47:16,039 --> 00:47:18,320
所以你在这里的左下角看到

1045
00:47:18,320 --> 00:47:20,940
如果让路，所有黄色都围绕着。 

1046
00:47:21,139 --> 00:47:23,969
你说，如果允许的话，一些安全的版本， 

1047
00:47:23,969 --> 00:47:27,169
等于Optional，hello是Optional， 

1048
00:47:27,170 --> 00:47:31,159
那么那个safehello将是String类型的。 

1049
00:47:31,159 --> 00:47:34,019
如果可选，它将获得值

1050
00:47:34,019 --> 00:47:35,259
在某些情况下。 

1051
00:47:35,260 --> 00:47:37,610
然后在里面的花括号里面， 

1052
00:47:37,610 --> 00:47:39,670
如果让safehello等于打开花括号， 

1053
00:47:39,869 --> 00:47:43,089
在那个大括号中，safehello将存在于其中， 

1054
00:47:43,090 --> 00:47:44,579
这将是一个字符串。 

1055
00:47:44,579 --> 00:47:45,666
不是可选的。 

1056
00:47:45,666 --> 00:47:50,250
它安全地从Optional中获取了相关的值

1057
00:47:50,250 --> 00:47:51,320
并正在执行。 

1058
00:47:51,320 --> 00:47:54,230
现在，如果在未设置的情况下打个招呼， 

1059
00:47:54,429 --> 00:47:56,889
那么它甚至不会执行该代码

1060
00:47:56,889 --> 00:47:58,465
那说print（safehello）。 

1061
00:47:58,465 --> 00:47:59,599
甚至不会被执行。 

1062
00:47:59,599 --> 00:48:02,690
它会做一些其他的事情。 

1063
00:48:02,690 --> 00:48:05,369
就像在右下角， 

1064
00:48:05,369 --> 00:48:06,599
打个招呼。 

1065
00:48:06,599 --> 00:48:08,869
如果是在未设置的情况下， 

1066
00:48:08,869 --> 00:48:11,519
你会做那别的。 

1067
00:48:11,519 --> 00:48:13,000
否则，在某些情况下， 

1068
00:48:13,000 --> 00:48:15,360
那么你将要把字符串放到那边

1069
00:48:15,360 --> 00:48:17,963
并在那里进行打印（safehello）。 

1070
00:48:18,920 --> 00:48:22,260
这就是我们获取价值的方法，语法糖

1071
00:48:22,260 --> 00:48:23,590
用于获取Optional的值。 

1072
00:48:23,789 --> 00:48:25,509
要么强行从那里抓起

1073
00:48:25,510 --> 00:48:26,980
如果我们找不到它就会崩溃

1074
00:48:27,179 --> 00:48:30,169
或做一个安全变量

1075
00:48:30,170 --> 00:48:31,682
一个安全的着陆点。 

1076
00:48:32,610 --> 00:48:34,670
另一个很酷的小语法糖

1077
00:48:34,670 --> 00:48:36,780
是Optional默认值。 

1078
00:48:36,780 --> 00:48:40,900
因此，这可以让您真正简单地提供一个默认

1079
00:48:40,900 --> 00:48:43,300
当您访问可选项时

1080
00:48:43,300 --> 00:48:45,677
如果在未设置的情况下是Optional， 

1081
00:48:45,677 --> 00:48:47,630
所以等于零

1082
00:48:47,630 --> 00:48:50,610
这里我有一个叫做x的常数

1083
00:48:50,610 --> 00:48:54,570
类型为“可选字符串”，“可选字符串”。 

1084
00:48:54,570 --> 00:48:56,039
我可能已经将其设置为某些内容。 

1085
00:48:56,039 --> 00:48:58,779
也许我将其设置为nil，也许我将其设置为某些东西。 

1086
00:48:58,780 --> 00:49:02,630
但是现在我要说的是y等于x。 

1087
00:49:02,829 --> 00:49:05,719
但是，如果x为零，请使用foo。 

1088
00:49:05,719 --> 00:49:07,339
那就是那个问号-问号

1089
00:49:07,340 --> 00:49:08,210
就是在那里

1090
00:49:08,409 --> 00:49:12,029
因此，在这种情况下，y始终为String类型。 

1091
00:49:12,030 --> 00:49:15,467
因为如果x是可选情况，则在设定的情况下

1092
00:49:15,666 --> 00:49:18,849
并且它具有关联的值，y会得到它。 

1093
00:49:18,849 --> 00:49:21,989
但是如果x在未设置的情况下， 

1094
00:49:21,989 --> 00:49:24,529
然后这个问号-问号会让你

1095
00:49:24,530 --> 00:49:25,743
获得foo的值。 

1096
00:49:26,679 --> 00:49:27,969
好吧，所以显示在右边

1097
00:49:27,969 --> 00:49:30,362
那里的枚举形式会是什么样子。 

1098
00:49:31,780 --> 00:49:35,460
好的，因此最好在实践中了解可选方案， 

1099
00:49:35,659 --> 00:49:38,009
所以我们要做两件事

1100
00:49:38,010 --> 00:49:39,182
在此演示中带有Optionals。 

1101
00:49:39,182 --> 00:49:41,570
一个，我们要修复匹配的firstIndex 

1102
00:49:41,570 --> 00:49:42,380
如我所说。 

1103
00:49:42,579 --> 00:49:44,739
第二，我们要创造自己的游戏， 

1104
00:49:44,739 --> 00:49:48,569
实际玩记忆游戏，开始匹配卡片。 

1105
00:49:48,570 --> 00:49:51,269
而要做到这一点， 

1106
00:49:51,469 --> 00:49:53,719
要有一个跟踪的变量

1107
00:49:53,719 --> 00:49:55,949
这张卡面朝上。 

1108
00:49:55,949 --> 00:49:57,119
因为当卡片正面朝上时， 

1109
00:49:57,119 --> 00:49:59,690
当有人拿起另一张卡时，我必须匹配它。 

1110
00:49:59,690 --> 00:50:02,253
因此，让我们深入研究该演示。 

1111
00:50:03,929 --> 00:50:06,739
好吧，既然我们知道什么是可选的， 

1112
00:50:06,739 --> 00:50:09,599
我们可以用它来修复这个假的东西

1113
00:50:09,599 --> 00:50:11,110
我们就在这里。 

1114
00:50:11,110 --> 00:50:12,940
这是什么假的？ 

1115
00:50:12,940 --> 00:50:16,349
好吧，我们有这个功能找到了第一个索引

1116
00:50:16,349 --> 00:50:19,569
与可识别数组中的某些元素匹配。 

1117
00:50:19,570 --> 00:50:20,202
它做到了。 

1118
00:50:20,402 --> 00:50:22,399
它通过并找到了第一个。 

1119
00:50:22,400 --> 00:50:26,320
但是，如果找不到它，它将返回零。 

1120
00:50:26,320 --> 00:50:29,630
零表示数组中第一件事的索引， 

1121
00:50:29,829 --> 00:50:32,840
如果此Array为空，则尤其假， 

1122
00:50:32,840 --> 00:50:34,289
可能是这样。 

1123
00:50:34,289 --> 00:50:35,769
那么我们该如何解决呢？ 

1124
00:50:35,769 --> 00:50:37,739
我们将通过返回类型来解决此问题， 

1125
00:50:37,739 --> 00:50:41,549
而不是Int，它将是可选的。 

1126
00:50:41,550 --> 00:50:45,043
注意，我说这个表达式是可选的。 

1127
00:50:45,242 --> 00:50:48,159
这是一个Optional，其关联值为Int， 

1128
00:50:48,159 --> 00:50:50,329
但这是可选的。 

1129
00:50:50,329 --> 00:50:52,389
人们一开始有时会感到困惑

1130
00:50:52,389 --> 00:50:54,489
认为这是一个Int 

1131
00:50:54,489 --> 00:50:56,099
加上一些修饰符。 

1132
00:50:56,099 --> 00:50:57,972
不，这是与Int不同的类型。 

1133
00:50:57,972 --> 00:51:00,550
这是一个名为Optional的类型。 

1134
00:51:00,550 --> 00:51:03,539
我们可以将其称为Optional Int， 

1135
00:51:03,539 --> 00:51:06,699
让我们在这里返回零， 

1136
00:51:06,699 --> 00:51:11,379
或在找不到时设置未设置的可选值。 

1137
00:51:11,380 --> 00:51:13,590
而且非常擅长与任何人交流

1138
00:51:13,590 --> 00:51:16,610
谁叫这个，“我找不到这个。” 

1139
00:51:16,610 --> 00:51:19,480
我们正常的回报是返回一个Int， 

1140
00:51:19,679 --> 00:51:21,809
 Swift当然很聪明

1141
00:51:21,809 --> 00:51:25,239
如果您有一个可选的Int并返回一个Int， 

1142
00:51:25,239 --> 00:51:27,859
它将在设置状态下返回Optional 

1143
00:51:27,860 --> 00:51:29,980
关联值为Int， 

1144
00:51:29,980 --> 00:51:31,362
正是您想要的。 

1145
00:51:32,219 --> 00:51:33,052
就是这样。 

1146
00:51:33,052 --> 00:51:36,339
现在，无论如何它不再是虚假的功能， 

1147
00:51:36,340 --> 00:51:38,769
这是一个非常好的功能。 

1148
00:51:38,769 --> 00:51:42,599
我们可以在我们称之为的两个地方使用它。 

1149
00:51:42,599 --> 00:51:43,659
让我们转到网格。 

1150
00:51:43,659 --> 00:51:45,079
让我们从这个开始。 

1151
00:51:45,079 --> 00:51:47,269
所以这是使用firstIndex的Grid。 

1152
00:51:47,269 --> 00:51:48,679
正在获取索引。 

1153
00:51:48,679 --> 00:51:50,739
这个局部变量就在这里， 

1154
00:51:50,739 --> 00:51:52,699
如果我们现在选择单击它， 

1155
00:51:52,699 --> 00:51:55,449
现在为Optional Int类型。 

1156
00:51:55,449 --> 00:51:58,039
好吧，这将是一个问题

1157
00:51:58,039 --> 00:51:59,809
我们会看到一个错误出现在这里， 

1158
00:51:59,809 --> 00:52:03,356
这是“必须解开可选类型Int的值

1159
00:52:03,356 --> 00:52:04,960
 “达到Int的值。” 

1160
00:52:04,960 --> 00:52:08,369
实际上，ItemAt的layout.location 

1161
00:52:08,369 --> 00:52:11,059
不以Optional作为其参数。 

1162
00:52:11,059 --> 00:52:12,690
它需要一个Int。 

1163
00:52:12,690 --> 00:52:15,349
现在我们可以接受这件事的建议

1164
00:52:15,349 --> 00:52:17,679
说好吧，让我们打开它。 

1165
00:52:17,679 --> 00:52:20,489
这就是我们解开Optional的方式。 

1166
00:52:20,489 --> 00:52:23,689
这需要一个处于设置状态的Optional， 

1167
00:52:23,690 --> 00:52:25,663
并获取其关联值。 

1168
00:52:26,610 --> 00:52:30,539
但是，当Optional处于未设置状态时， 

1169
00:52:30,539 --> 00:52:32,820
这会使您的程序崩溃。 

1170
00:52:32,820 --> 00:52:33,757
现在有些人可能会说

1171
00:52:33,956 --> 00:52:37,487
 “哇，我们为什么要使用感叹号？ 

1172
00:52:37,487 --> 00:52:40,789
 “这太可怕了，有时会使我的程序崩溃。” 

1173
00:52:40,989 --> 00:52:44,049
是的，但是在这种情况下，可能实际上是很好的

1174
00:52:44,050 --> 00:52:46,230
离开这里的感叹号。 

1175
00:52:46,230 --> 00:52:48,369
因为永远不会这样

1176
00:52:48,369 --> 00:52:51,359
我们查找其中一项的第一个索引， 

1177
00:52:51,360 --> 00:52:55,070
我们只能通过项目数组通过ForEaching获得。 

1178
00:52:55,070 --> 00:52:56,460
这绝对不能为零。 

1179
00:52:56,659 --> 00:52:59,809
如果没有，那就出了什么问题了

1180
00:52:59,809 --> 00:53:03,199
我的代码中的某个地方，我有点希望它崩溃

1181
00:53:03,199 --> 00:53:04,782
所以我发现了这个问题。 

1182
00:53:05,800 --> 00:53:07,400
但是也许我真的很保守

1183
00:53:07,599 --> 00:53:09,869
当我将代码发送给客户时， 

1184
00:53:09,869 --> 00:53:12,079
我真的想确保，无论如何

1185
00:53:12,079 --> 00:53:15,670
它不会因为这些惊叹号之一而崩溃。 

1186
00:53:15,670 --> 00:53:18,590
因此，我可以保护客户

1187
00:53:18,590 --> 00:53:21,480
通过保护此代码，并说是否索引

1188
00:53:21,679 --> 00:53:25,409
不等于nil，则执行此操作。 

1189
00:53:25,409 --> 00:53:27,750
这将保护此代码

1190
00:53:27,750 --> 00:53:29,202
这样它就不会崩溃。 

1191
00:53:29,202 --> 00:53:33,880
因为如果index不为nil，则在此处展开​​它

1192
00:53:33,880 --> 00:53:36,000
总是会上班。 

1193
00:53:36,000 --> 00:53:38,052
但这没有建立。 

1194
00:53:39,159 --> 00:53:41,899
为什么不构建此代码？ 

1195
00:53:41,900 --> 00:53:44,077
它说：“缺少函数返回

1196
00:53:44,077 --> 00:53:47,210
 “预期会返回“某些视图”。” 

1197
00:53:47,210 --> 00:53:50,889
确实，该函数应该返回“某些视图”。 

1198
00:53:50,889 --> 00:53:54,319
在索引的情况下，它确实会返回“ some View” 

1199
00:53:54,320 --> 00:53:56,960
不是nil，但是如果index为nil， 

1200
00:53:56,960 --> 00:53:58,853
当前，它什么也不返回。 

1201
00:53:59,800 --> 00:54:01,320
那是个问题。 

1202
00:54:01,320 --> 00:54:03,143
我什至不确定我们要返回什么

1203
00:54:03,342 --> 00:54:05,609
在这种情况下。 

1204
00:54:05,610 --> 00:54:07,980
所以，我们将不得不采取一些不同的策略

1205
00:54:07,980 --> 00:54:11,039
返回具有条件的“某些视图”。 

1206
00:54:11,239 --> 00:54:13,079
而且我们之前已经看过。 

1207
00:54:13,079 --> 00:54:17,730
在我们的视图ZStack中。 

1208
00:54:17,730 --> 00:54:19,199
 ZStack有条件。 

1209
00:54:19,199 --> 00:54:21,759
如果该卡面朝上，它会做一件事。 

1210
00:54:21,760 --> 00:54:24,260
如果是面朝下的，那就做另一件事。 

1211
00:54:24,260 --> 00:54:27,920
 ZStack在这里使用的这个功能，请记住， 

1212
00:54:27,920 --> 00:54:28,789
被称为ViewBiulder。 

1213
00:54:28,789 --> 00:54:33,039
这是我们的GeometryReader所做的事情， 

1214
00:54:33,039 --> 00:54:35,090
 ForEach需要做的同样的事情，HStack， 

1215
00:54:35,090 --> 00:54:38,150
他们都使用ViewBuilder这个功能， 

1216
00:54:38,349 --> 00:54:39,670
但这是一种特殊的功能

1217
00:54:39,670 --> 00:54:40,916
您可以在其中放置这些if-thens 

1218
00:54:40,916 --> 00:54:42,889
您可以只列出视图。 

1219
00:54:42,889 --> 00:54:45,609
一切都变成了某种东西

1220
00:54:45,610 --> 00:54:48,090
那就是“某些视图”。 

1221
00:54:48,090 --> 00:54:51,769
因此，ZStack可以将“某些视图”作为其内容。 

1222
00:54:51,769 --> 00:54:55,389
好吧，我们可以在Grid上做同样的事情， 

1223
00:54:55,389 --> 00:54:57,049
但我们不需要进行任何布局。 

1224
00:54:57,050 --> 00:54:59,690
我们正在使用我们的框架和位置进行布局。 

1225
00:54:59,889 --> 00:55:02,190
所以我们想要一些需要ViewBuilder的东西

1226
00:55:02,190 --> 00:55:03,769
那有点什么都不做。 

1227
00:55:03,969 --> 00:55:05,509
而且有这样的事情。 

1228
00:55:05,510 --> 00:55:07,303
它称为组。 

1229
00:55:08,340 --> 00:55:12,550
因此，Group就像ZStack或其他任何事物

1230
00:55:12,550 --> 00:55:16,690
它的功能参数是一个“视图”构建器。 

1231
00:55:16,690 --> 00:55:20,730
但是，它对这里的内容没有任何作用。 

1232
00:55:20,730 --> 00:55:23,639
它允许您执行if if thens以及所有这些操作， 

1233
00:55:23,639 --> 00:55:26,210
您仍然可以列出这些东西， 

1234
00:55:26,210 --> 00:55:28,539
但这并没有把它们摆出来

1235
00:55:28,539 --> 00:55:30,920
或尝试以任何方式定位它们。 

1236
00:55:30,920 --> 00:55:33,863
因此，我们的定位将继续在这里进行。 

1237
00:55:35,030 --> 00:55:37,271
因此，我们将其转换为两行函数

1238
00:55:37,271 --> 00:55:40,269
而不是一个班轮，所以我们必须在这里放回程

1239
00:55:40,269 --> 00:55:41,780
以确保我们返回小组。 

1240
00:55:41,780 --> 00:55:45,090
但是现在我们要返回Group，这是一些视图。 

1241
00:55:45,289 --> 00:55:48,210
而Group只是使用View builder的东西

1242
00:55:48,210 --> 00:55:49,610
像这样去

1243
00:55:49,610 --> 00:55:53,530
现在，您可能会问：“如果索引为零，Group会做什么？” 

1244
00:55:53,530 --> 00:55:55,360
好吧，那会回来的

1245
00:55:55,360 --> 00:55:57,539
有某种空白的内容。 

1246
00:55:57,739 --> 00:55:59,299
它的身体将是一个空洞的视图。 

1247
00:55:59,300 --> 00:56:01,210
实际上有一个名为EmptyView的视图。 

1248
00:56:01,409 --> 00:56:04,179
可能会返回，但我们真的不在乎。 

1249
00:56:04,179 --> 00:56:06,373
我们只是在这里使用ViewBuilder功能

1250
00:56:06,373 --> 00:56:08,849
当我们知道我们可以做的时候。 

1251
00:56:08,849 --> 00:56:11,440
我们会发现该组很有用

1252
00:56:11,440 --> 00:56:14,170
在许多其他情况下也是如此。 

1253
00:56:14,170 --> 00:56:17,630
顾名思义，它对分组非常有用。 

1254
00:56:17,630 --> 00:56:20,760
这是因为集团，其观点在这里

1255
00:56:20,760 --> 00:56:22,480
是一个ViewBuilder视图。 

1256
00:56:22,480 --> 00:56:24,349
这就是为什么我们能够做到的

1257
00:56:24,349 --> 00:56:28,579
但这也是为什么我们能够列出一些视图的原因， 

1258
00:56:28,579 --> 00:56:30,289
然后将它们分组。 

1259
00:56:30,289 --> 00:56:33,759
因此，这实际上可能是Group存在的主要原因。 

1260
00:56:33,760 --> 00:56:36,010
这就是为什么将其称为“组”。 

1261
00:56:36,010 --> 00:56:39,050
但是说实话，我真的可能没有

1262
00:56:39,050 --> 00:56:41,539
经历了所有麻烦。 

1263
00:56:41,739 --> 00:56:43,709
我认为没有任何原因

1264
00:56:43,710 --> 00:56:45,860
检查该索引是否为零。 

1265
00:56:45,860 --> 00:56:48,393
正如我之前提到的，它永远不应为零。 

1266
00:56:49,260 --> 00:56:54,170
因此，我可能会删除所有这些内容。 

1267
00:56:54,170 --> 00:56:56,590
回到我们以前的地方。 

1268
00:56:56,590 --> 00:56:59,690
并让该索引强制展开。 

1269
00:56:59,889 --> 00:57:02,052
如果它使我的应用程序崩溃，那么它也会使我的应用程序崩溃。 

1270
00:57:02,052 --> 00:57:05,309
它永远都不应该，所以我想在开发中找到， 

1271
00:57:05,309 --> 00:57:07,860
而没有所有这些代码，则代码更干净

1272
00:57:07,860 --> 00:57:10,452
还有ViewBuilder的东西。 

1273
00:57:11,469 --> 00:57:14,579
我可能要做的另一件事是移动此感叹号

1274
00:57:14,579 --> 00:57:17,460
从这里我经过这个变种

1275
00:57:17,460 --> 00:57:22,090
到这里我实际上得到了这个var的价值。 

1276
00:57:22,090 --> 00:57:23,690
因此，获取该firstIndex， 

1277
00:57:23,889 --> 00:57:25,920
并立即强行打开包装。 

1278
00:57:25,920 --> 00:57:28,280
这就是这个索引变量

1279
00:57:28,280 --> 00:57:30,723
转换为Int，我们可以直接将其传递。 

1280
00:57:32,280 --> 00:57:33,840
好吧，那里还有一个地方

1281
00:57:34,039 --> 00:57:35,675
我们使用firstIndex的地方。 

1282
00:57:35,675 --> 00:57:38,050
那是在我们的模型中，所以让我们来看一下

1283
00:57:38,050 --> 00:57:40,860
看看我们造成的损害

1284
00:57:40,860 --> 00:57:43,800
通过在此处切换到firstIndex。 

1285
00:57:43,800 --> 00:57:45,769
在这里，我们将使用一些不同的策略

1286
00:57:45,969 --> 00:57:48,739
避免必须解开Optional的错误

1287
00:57:48,739 --> 00:57:51,929
我要在我的租赁前使用if 

1288
00:57:51,929 --> 00:57:53,699
这是一个非常酷的功能。 

1289
00:57:53,699 --> 00:57:57,089
只需将if放在前面，然后再放大括号

1290
00:57:57,090 --> 00:57:59,150
做任何你想做的事。 

1291
00:57:59,349 --> 00:58:03,230
而您想要的任何事情只会实际发生

1292
00:58:03,230 --> 00:58:06,289
如果这个东西返回非零。 

1293
00:58:06,489 --> 00:58:09,979
如果返回nil，则该代码甚至都不会执行。 

1294
00:58:09,980 --> 00:58:14,769
在这里，请注意，如果让我们继续

1295
00:58:14,769 --> 00:58:17,380
冒号Int作为selectedIndex的类型。 

1296
00:58:17,380 --> 00:58:20,210
顺便说一下，我们并不需要它，因为它可以推断出它， 

1297
00:58:20,409 --> 00:58:22,739
但selectedIndex实际上是一个Int。 

1298
00:58:22,739 --> 00:58:26,729
只有在firstIndex的情况下它才会实际存在

1299
00:58:26,730 --> 00:58:29,300
返回非nil，这是唯一的时间

1300
00:58:29,300 --> 00:58:31,769
该代码也将被执行。 

1301
00:58:31,969 --> 00:58:33,399
但这正是我们想要的。 

1302
00:58:33,400 --> 00:58:34,960
它可以保护我们免受selectedIndex的影响。 

1303
00:58:35,159 --> 00:58:37,529
这意味着选择什么都不做。 

1304
00:58:37,530 --> 00:58:39,539
如果我们在卡中找不到该卡， 

1305
00:58:39,739 --> 00:58:40,599
那么这什么也没做。 

1306
00:58:40,599 --> 00:58:41,432
这正是我们想要的。 

1307
00:58:41,432 --> 00:58:43,039
我们希望它什么也不做。 

1308
00:58:43,039 --> 00:58:46,039
让我们运行并确保此可选业务

1309
00:58:46,039 --> 00:58:47,980
没有破坏任何东西。 

1310
00:58:47,980 --> 00:58:48,813
开始了。 

1311
00:58:48,813 --> 00:58:50,550
是的，我们仍然可以将卡片翻转过来。 

1312
00:58:50,550 --> 00:58:52,150
面朝上，面朝下。 

1313
00:58:52,150 --> 00:58:55,519
但是现在，该尝试玩游戏了。 

1314
00:58:55,519 --> 00:58:57,650
我们还需要Optional。 

1315
00:58:57,650 --> 00:59:00,030
我们将尽力使这些卡

1316
00:59:00,030 --> 00:59:02,000
实际上会匹配，也许匹配的卡

1317
00:59:02,199 --> 00:59:03,032
从游戏中消失。 

1318
00:59:03,032 --> 00:59:04,502
那也很酷。 

1319
00:59:05,769 --> 00:59:06,967
那么我们该怎么做呢？ 

1320
00:59:06,967 --> 00:59:11,619
我们如何玩我们的游戏，让它玩？ 

1321
00:59:11,619 --> 00:59:13,289
好吧，我们需要一些设计。 

1322
00:59:13,289 --> 00:59:15,039
我们是软件设计师。 

1323
00:59:15,039 --> 00:59:16,349
我们必须从概念上思考

1324
00:59:16,349 --> 00:59:18,299
我们将如何实现这一目标。 

1325
00:59:18,300 --> 00:59:21,880
因此，在我看来，我将经历各种情况。 

1326
00:59:22,079 --> 00:59:24,769
首先，我所有的卡都是正面朝下的。 

1327
00:59:24,769 --> 00:59:26,610
然后我点击卡片。 

1328
00:59:26,610 --> 00:59:28,210
然后没有匹配发生。 

1329
00:59:28,210 --> 00:59:30,570
卡只是面朝上翻转，这就是它的作用

1330
00:59:30,570 --> 00:59:32,610
现在就在我们的代码中。 

1331
00:59:32,610 --> 00:59:34,320
所以，好的。 

1332
00:59:34,320 --> 00:59:36,800
第二种状态是我拿到一张卡

1333
00:59:36,800 --> 00:59:38,750
然后我点击第二张卡片

1334
00:59:38,750 --> 00:59:40,880
好吧，那时候我真的很需要比赛。 

1335
00:59:40,880 --> 00:59:42,440
因此，如果有一张卡片正面朝上

1336
00:59:42,639 --> 00:59:44,250
然后点击了卡片

1337
00:59:44,250 --> 00:59:46,079
那就是我要玩游戏的时候。 

1338
00:59:46,079 --> 00:59:49,849
如果现在有两张卡片正面朝上，而我按了第三张卡片， 

1339
00:59:49,849 --> 00:59:51,759
现在我基本上需要转向

1340
00:59:51,760 --> 00:59:53,230
其他两张卡片正面朝下。 

1341
00:59:53,230 --> 00:59:54,250
无论他们是否匹配， 

1342
00:59:54,250 --> 00:59:55,960
他们需要面朝下。 

1343
00:59:55,960 --> 00:59:58,210
我刚刚接触过的卡片

1344
00:59:58,210 --> 01:00:00,309
那将是面朝上的。 

1345
01:00:01,179 --> 01:00:02,419
在这三种情况下。 

1346
01:00:02,420 --> 01:00:04,389
这就是所有场景。 

1347
01:00:04,389 --> 01:00:06,829
在这三种情况下，我唯一一次玩过

1348
01:00:06,829 --> 01:00:11,579
一个匹配的游戏是如果有一张且只有一张卡片面朝上

1349
01:00:11,579 --> 01:00:14,210
当时我碰到一张新卡。 

1350
01:00:14,210 --> 01:00:16,030
所以我需要发现这种情况

1351
01:00:16,030 --> 01:00:17,210
当只有一个。 

1352
01:00:17,210 --> 01:00:19,579
所以我要去一个变种

1353
01:00:19,579 --> 01:00:21,469
跟踪索引

1354
01:00:21,469 --> 01:00:26,252
一张唯一的面朝上的卡片。 

1355
01:00:27,989 --> 01:00:30,379
这是我数组的索引， 

1356
01:00:30,380 --> 01:00:31,619
因此它将成为一个Int。 

1357
01:00:31,619 --> 01:00:34,619
但这可能是我比赛的开始

1358
01:00:34,619 --> 01:00:35,779
而且没有面朝上的卡， 

1359
01:00:35,780 --> 01:00:38,230
也许有两张面朝上的卡。 

1360
01:00:38,230 --> 01:00:41,409
因此，这确实需要是可选的。 

1361
01:00:41,409 --> 01:00:44,319
请注意，我在这里没有得到错误提示

1362
01:00:44,320 --> 01:00:45,630
我还没有初始化这个。 

1363
01:00:45,829 --> 01:00:49,259
没有错误，但是我还没有初始化。 

1364
01:00:49,260 --> 01:00:49,893
没有错误。 

1365
01:00:50,092 --> 01:00:53,009
那是因为所有可选项

1366
01:00:53,010 --> 01:00:56,000
自动初始化为nil。 

1367
01:00:56,199 --> 01:00:57,429
因此等于nil。 

1368
01:00:57,429 --> 01:00:58,960
您可以根据需要输入。 

1369
01:00:58,960 --> 01:01:01,289
但是，如果您不把它放在那儿，它就会在那里。 

1370
01:01:01,489 --> 01:01:02,696
这很有道理，对吗？ 

1371
01:01:02,697 --> 01:01:05,202
可选值等于nil表示未设置。 

1372
01:01:06,248 --> 01:01:10,760
从总体上讲，此var开始时未设置游戏。 

1373
01:01:10,760 --> 01:01:11,690
因此，让我们继续前进。 

1374
01:01:11,690 --> 01:01:14,980
我得到了这个selectedIndex，我真的只想要

1375
01:01:14,980 --> 01:01:19,980
要注意显然在我的阵列中的卡片， 

1376
01:01:20,719 --> 01:01:25,299
而且还没有面朝上。 

1377
01:01:25,300 --> 01:01:28,130
如果某张卡已经面朝上并且我点击了它， 

1378
01:01:28,130 --> 01:01:29,849
我只是忽略它。 

1379
01:01:29,849 --> 01:01:31,889
现在，您会认为这可行，对吗？ 

1380
01:01:31,889 --> 01:01:33,429
在此处获取selectedIndex， 

1381
01:01:33,429 --> 01:01:35,989
并且selectedIndex不是朝上的。 

1382
01:01:35,989 --> 01:01:40,329
但它抱怨selectedIndex尚未解决。 

1383
01:01:40,329 --> 01:01:42,309
因此，如果您想这样做

1384
01:01:42,309 --> 01:01:44,860
你在说如果放手

1385
01:01:44,860 --> 01:01:47,289
然后你想做，在那件事上， 

1386
01:01:47,489 --> 01:01:50,549
而不是在这里，您将使用逗号。 

1387
01:01:50,550 --> 01:01:53,269
所以逗号就像顺序的

1388
01:01:53,269 --> 01:01:55,519
它首先在哪里做。 

1389
01:01:55,519 --> 01:01:59,869
然后，完成了它，可以做到这一点，并设置了selectedIndex。 

1390
01:01:59,869 --> 01:02:01,630
您甚至可以拥有更多这些， 

1391
01:02:01,630 --> 01:02:05,000
就像我可能也想忽略Cards 

1392
01:02:05,000 --> 01:02:09,190
这表明索引不匹配。 

1393
01:02:09,190 --> 01:02:11,309
所以我只会碰卡

1394
01:02:11,309 --> 01:02:12,940
面朝上，无与伦比。 

1395
01:02:12,940 --> 01:02:14,842
否则，我将忽略这些卡。 

1396
01:02:15,940 --> 01:02:19,362
如果让我们使用这些逗号表示，则相当多。 

1397
01:02:20,289 --> 01:02:22,630
在里面，我知道我已经选择了卡片

1398
01:02:22,630 --> 01:02:24,849
那是面朝下且尚未匹配的。 

1399
01:02:24,849 --> 01:02:28,500
所以我只想看看是否只有一个

1400
01:02:28,500 --> 01:02:30,280
卡片正面朝上，所以我要说

1401
01:02:30,280 --> 01:02:32,827
如果我可以让potentialMatchIndex 

1402
01:02:34,269 --> 01:02:38,039
等于indexOfTheOneAndOnlyFaceUpCard， 

1403
01:02:38,039 --> 01:02:40,690
现在我可能有一场比赛

1404
01:02:40,690 --> 01:02:42,380
因为只有一张面朝上的卡。 

1405
01:02:42,380 --> 01:02:44,420
我刚把另一张卡翻了过来。 

1406
01:02:44,420 --> 01:02:45,550
我们需要尝试并匹配它。 

1407
01:02:45,550 --> 01:02:49,400
没问题，如果在selectedIndex的Cards， 

1408
01:02:49,599 --> 01:02:53,099
如果有内容，请记住内容

1409
01:02:53,099 --> 01:02:55,940
在卡上，这就是卡上的内容， 

1410
01:02:55,940 --> 01:03:00,940
等于卡的潜在匹配数内容， 

1411
01:03:01,329 --> 01:03:04,299
然后woohoo，有一场比赛。 

1412
01:03:04,300 --> 01:03:06,510
现在，这使错误发生了。 

1413
01:03:06,510 --> 01:03:08,590
为什么会出错？ 

1414
01:03:08,590 --> 01:03:12,237
它说：“二元运算符等于-不能应用

1415
01:03:12,237 --> 01:03:15,789
 “到两个CardContent操作数。” 

1416
01:03:15,789 --> 01:03:20,789
嗯，实际上这两个都是CardContent类型。 

1417
01:03:21,710 --> 01:03:24,699
那是我们不在乎。 

1418
01:03:24,699 --> 01:03:27,719
为什么我们不能在CardContent上做equals-equals？ 

1419
01:03:27,719 --> 01:03:30,089
这是一个字符串，对，表情符号字符串。 

1420
01:03:30,090 --> 01:03:31,900
等等

1421
01:03:31,900 --> 01:03:35,750
这是一种通用的记忆游戏玩法。 

1422
01:03:35,750 --> 01:03:37,849
这些里面没有表情符号。 

1423
01:03:37,849 --> 01:03:41,949
他们是CardContent，这对我们来说不在乎。 

1424
01:03:41,949 --> 01:03:45,879
可以是任何东西，图像，字符串，整数，等等。 

1425
01:03:45,880 --> 01:03:47,480
我们试图说等于。 

1426
01:03:47,679 --> 01:03:49,699
如果它是字符串，那么就可以了。 

1427
01:03:49,699 --> 01:03:50,909
如果是图片怎么办？ 

1428
01:03:50,909 --> 01:03:53,289
您能说一张图片等于另一张图片吗？ 

1429
01:03:53,289 --> 01:03:55,159
也许不是，我不知道。 

1430
01:03:55,159 --> 01:03:56,639
等于不是什么

1431
01:03:56,639 --> 01:03:58,991
那只适用于一切。 

1432
01:03:58,992 --> 01:04:02,630
实际上，平等在Swift中如何工作？ 

1433
01:04:02,829 --> 01:04:06,480
不管您信不信，Swift中的equals-equals并不是内置的

1434
01:04:06,480 --> 01:04:07,860
语言。 

1435
01:04:07,860 --> 01:04:10,630
它在Swift中使用了一种称为运算符的功能

1436
01:04:10,630 --> 01:04:13,309
这样您就可以关联一个运算符

1437
01:04:13,309 --> 01:04:15,199
具有功能。 

1438
01:04:15,199 --> 01:04:17,319
这正是平等所要做的。 

1439
01:04:17,320 --> 01:04:21,750
它将它与类型函数equals-equals关联。 

1440
01:04:21,750 --> 01:04:24,139
现在，等于等于看起来很有趣

1441
01:04:24,139 --> 01:04:27,299
 Swift中的功能。 

1442
01:04:27,300 --> 01:04:29,400
这有点好笑，但也请记住

1443
01:04:29,400 --> 01:04:32,869
那张笑脸，表情符号笑脸， 

1444
01:04:32,869 --> 01:04:35,210
在Swift中是有效的函数名称。 

1445
01:04:35,210 --> 01:04:39,059
几乎所有Unicode字符都是有效的Swift。 

1446
01:04:39,059 --> 01:04:42,130
因此，等于笑脸和笑脸一样有效。 

1447
01:04:42,130 --> 01:04:44,730
所以这个等值函数是一个类型函数， 

1448
01:04:44,730 --> 01:04:46,460
它只需要两个参数， 

1449
01:04:46,460 --> 01:04:48,567
这是平等两边的两件事， 

1450
01:04:48,567 --> 01:04:52,329
无论是否相同，它都会返回布尔值。 

1451
01:04:52,329 --> 01:04:54,369
就是这样，这正是您所期望的。 

1452
01:04:54,369 --> 01:04:58,089
但是，并非每种类型都具有“等于”。 

1453
01:04:58,090 --> 01:05:00,000
只有某些类型可以实际

1454
01:05:00,000 --> 01:05:02,130
检查是否相等。 

1455
01:05:02,130 --> 01:05:04,550
但幸运的是，等于函数

1456
01:05:04,550 --> 01:05:07,610
在一项名为“平等”的协议中， 

1457
01:05:07,809 --> 01:05:11,029
所以我们可以在这里利用我们的约束和收获

1458
01:05:11,030 --> 01:05:15,789
说我们的CardContent在哪里实现Equatable。 

1459
01:05:15,989 --> 01:05:18,059
换句话说，我们只会工作， 

1460
01:05:18,059 --> 01:05:20,579
我们的MemoryGame仅在CardContent时有效

1461
01:05:21,469 --> 01:05:23,982
可以等于等于，可以等于。 

1462
01:05:25,019 --> 01:05:28,759
让我们在文档中查看该协议。 

1463
01:05:28,760 --> 01:05:31,050
所以我要做选择，单击。 

1464
01:05:31,050 --> 01:05:34,110
这是有关它的顶级文档， 

1465
01:05:34,309 --> 01:05:35,882
但让我们进入文档。 

1466
01:05:37,070 --> 01:05:39,360
平等是一个非常重要的协议。 

1467
01:05:39,360 --> 01:05:41,940
您可以看到很多解释

1468
01:05:41,940 --> 01:05:44,530
说某事物相等意味着什么

1469
01:05:44,530 --> 01:05:48,130
其他的东西，可转让财产，所有这一切。 

1470
01:05:48,130 --> 01:05:50,539
但是当您找到有关它的功能列表时， 

1471
01:05:50,539 --> 01:05:53,469
只有一个是必需的。 

1472
01:05:53,469 --> 01:05:54,599
您看到这个要求了吗？ 

1473
01:05:54,599 --> 01:05:56,949
这意味着它是协议的一部分， 

1474
01:05:56,949 --> 01:05:59,099
而且没有默认实现

1475
01:05:59,099 --> 01:06:03,199
扩展到任何地方，所以您必须实现它。 

1476
01:06:03,199 --> 01:06:06,969
这就是我所说的，静态的，类型函数

1477
01:06:06,969 --> 01:06:09,569
这需要其中两件事， 

1478
01:06:09,570 --> 01:06:12,070
记得在幻灯片中，我们拥有的比

1479
01:06:12,070 --> 01:06:15,400
而且你有自我，所以论点大于

1480
01:06:15,400 --> 01:06:16,980
与一个int或它是总统。 

1481
01:06:17,179 --> 01:06:18,139
这里也是一样。 

1482
01:06:18,139 --> 01:06:20,949
如果您有equals-equals，如果我们使用String， 

1483
01:06:20,949 --> 01:06:23,619
那么Self和Self将是String和String， 

1484
01:06:23,619 --> 01:06:26,579
因此它需要两个String并进行比较。 

1485
01:06:26,579 --> 01:06:29,460
如果是Int，则需要两个Int，无论如何。 

1486
01:06:29,460 --> 01:06:31,179
这是您必须实现的唯一功能。 

1487
01:06:31,179 --> 01:06:34,480
真正简单的功能，简单易懂的功能， 

1488
01:06:34,480 --> 01:06:36,380
尽管您必须阅读所有这些内容以确保

1489
01:06:36,380 --> 01:06:37,710
你真的很明白

1490
01:06:37,710 --> 01:06:40,380
这是我们必须在Equatable中实施的唯一方法。 

1491
01:06:40,380 --> 01:06:42,019
所有其他这些都不是必需的

1492
01:06:42,019 --> 01:06:44,809
因为您可以通过扩展免费获得它们。 

1493
01:06:44,809 --> 01:06:48,320
 Swift Foundation为您提供了这些东西

1494
01:06:48,320 --> 01:06:51,289
元组和其他东西自动在这里。 

1495
01:06:51,289 --> 01:06:53,610
不等于，它免费提供给您。 

1496
01:06:53,610 --> 01:06:55,983
它们全部基于此处的等值。 

1497
01:06:57,630 --> 01:07:00,550
这是一个协议，等于协议。 

1498
01:07:00,550 --> 01:07:03,980
因此，我们只是强迫或约束， 

1499
01:07:04,179 --> 01:07:07,619
我们的CardContent（我们不在乎）要平等。 

1500
01:07:07,619 --> 01:07:08,500
我们有点在意。 

1501
01:07:08,500 --> 01:07:11,539
我们关心它是等值的，因此我们可以对其进行比较。 

1502
01:07:11,539 --> 01:07:13,309
好吧，如果这两件事匹配， 

1503
01:07:13,309 --> 01:07:14,809
那我就说他们相配了

1504
01:07:14,809 --> 01:07:19,809
 selectedIndex，isMatched处的纸牌等于true。 

1505
01:07:20,900 --> 01:07:24,000
当然，在potentialMatchIndex的卡片

1506
01:07:24,000 --> 01:07:25,170
事实证明这是一场比赛， 

1507
01:07:25,170 --> 01:07:28,463
因此它的isMatched也等于true。 

1508
01:07:29,400 --> 01:07:30,400
因此，这些卡是匹配的。 

1509
01:07:30,400 --> 01:07:31,369
棒极了。 

1510
01:07:31,369 --> 01:07:33,909
请注意，无论它们是否匹配， 

1511
01:07:33,909 --> 01:07:36,259
现在有两张卡片正面朝上。 

1512
01:07:36,260 --> 01:07:41,083
因此，一张唯一的朝上卡的索引为nil。 

1513
01:07:41,987 --> 01:07:44,039
没有一张，只有一张面朝上的卡。 

1514
01:07:44,039 --> 01:07:46,090
有两个，所以这意味着零。 

1515
01:07:47,039 --> 01:07:48,900
那其他情况呢？ 

1516
01:07:48,900 --> 01:07:52,019
因此，在这种情况下，没有一张，只有一张面朝上的卡。 

1517
01:07:52,219 --> 01:07:55,250
因此，要么为零，要么不止一个。 

1518
01:07:55,250 --> 01:07:58,219
在这种情况下，我们想将所有卡面朝下

1519
01:07:58,219 --> 01:08:00,469
除了我们当然选择的那个。 

1520
01:08:00,469 --> 01:08:01,909
所以我们要做一些循环

1521
01:08:01,909 --> 01:08:05,072
在我们的cards.indices中索引

1522
01:08:06,112 --> 01:08:08,969
而且我们只需要购买每张卡

1523
01:08:08,969 --> 01:08:12,899
 isFaceUp等于false，我们将确保

1524
01:08:12,900 --> 01:08:17,899
我们将Card设为true，将其面朝上。 

1525
01:08:18,010 --> 01:08:19,329
在这种情况下也请注意

1526
01:08:19,529 --> 01:08:24,529
 indexOfTheOneAndOnlyFaceUpCard是我们的selectedIndex。 

1527
01:08:24,713 --> 01:08:26,961
因为我只是把所有这些面朝下

1528
01:08:26,961 --> 01:08:29,445
我要把这个放回去

1529
01:08:29,445 --> 01:08:33,921
因此它将成为唯一的面朝上的卡片。 

1530
01:08:33,921 --> 01:08:35,090
就是这样了。 

1531
01:08:35,090 --> 01:08:36,010
这是我们的逻辑。 

1532
01:08:36,010 --> 01:08:38,947
我们不需要选择此卡就可以在那里打印。 

1533
01:08:38,947 --> 01:08:41,430
这就是完成这项工作的全部。 

1534
01:08:41,430 --> 01:08:44,802
因此，让我们运行，看看我们的游戏是否按照我们的意愿进行。 

1535
01:08:45,770 --> 01:08:47,920
好吧，这个游戏原来是最简单的游戏之一

1536
01:08:47,920 --> 01:08:51,869
进行记忆游戏，因为所有卡都面朝上。 

1537
01:08:51,869 --> 01:08:52,970
所以，那不好。 

1538
01:08:52,970 --> 01:08:54,489
让我们回到这里的模型

1539
01:08:54,689 --> 01:08:58,039
并进行更改，使所有卡面朝下开始。 

1540
01:08:58,039 --> 01:09:01,533
我认为这将使游戏更具挑战性。 

1541
01:09:02,960 --> 01:09:04,100
好吧，让我们尝试一下。 

1542
01:09:04,100 --> 01:09:05,800
鬼，是的。 

1543
01:09:05,800 --> 01:09:07,949
南瓜，哦，不，没有对手。 

1544
01:09:08,149 --> 01:09:11,639
鬼，是的，蜘蛛，不，不，不再。 

1545
01:09:11,640 --> 01:09:14,109
南瓜啊，我想我知道南瓜在哪里。 

1546
01:09:14,109 --> 01:09:15,210
就在这里

1547
01:09:15,409 --> 01:09:16,269
是。 

1548
01:09:16,270 --> 01:09:18,079
然后蜘蛛呢？ 

1549
01:09:18,279 --> 01:09:23,019
哦，现在请注意，它确实使我匹配的卡片面朝下， 

1550
01:09:23,020 --> 01:09:24,500
如果我尝试触及它们， 

1551
01:09:24,500 --> 01:09:27,279
我目前正在反复点击这些

1552
01:09:27,279 --> 01:09:29,939
他们不回头，因为他们已经匹配。 

1553
01:09:29,939 --> 01:09:32,139
我们将忽略已经匹配的卡片。 

1554
01:09:32,140 --> 01:09:35,510
但是拥有这些正面朝下的卡片并不是一个很好的用户界面

1555
01:09:35,510 --> 01:09:37,922
您无法触摸，它什么也没做。 

1556
01:09:37,922 --> 01:09:40,519
我真的很想把这些拿走。 

1557
01:09:40,520 --> 01:09:43,250
因此，如果它们匹配，我将带走它们。 

1558
01:09:43,250 --> 01:09:46,340
因此，让我们回到我们的UI并执行此操作。 

1559
01:09:46,340 --> 01:09:48,199
这是我们的CardView。 

1560
01:09:48,199 --> 01:09:51,380
这是卡正面朝上的地方，那里没有问题。 

1561
01:09:51,380 --> 01:09:52,949
这是他们面朝下的地方。 

1562
01:09:53,149 --> 01:09:56,529
我要说的是如果卡片不匹配， 

1563
01:09:56,529 --> 01:09:58,719
那我画

1564
01:09:58,720 --> 01:10:00,909
但是如果它匹配并且面朝下， 

1565
01:10:00,909 --> 01:10:02,599
我什么也不会画。 

1566
01:10:02,600 --> 01:10:04,350
同样，这是ViewBuilder。 

1567
01:10:04,350 --> 01:10:05,369
这些简单的ifs。 

1568
01:10:05,569 --> 01:10:08,639
您甚至可以将这些if嵌套在else中

1569
01:10:08,640 --> 01:10:10,460
或其他if的if内。 

1570
01:10:10,659 --> 01:10:12,199
嵌套ifs可以。 

1571
01:10:12,199 --> 01:10:14,349
请注意，我们在这里甚至不需要其他。 

1572
01:10:14,350 --> 01:10:16,523
 ViewBuilder知道如何处理事实

1573
01:10:16,523 --> 01:10:20,590
如果没有发生，那么这里什么也不会发生。 

1574
01:10:20,590 --> 01:10:21,779
本质上是一个空的视图。 

1575
01:10:21,979 --> 01:10:25,569
实际上，在SwiftUI中，有一个名为EmptyView的视图。 

1576
01:10:25,569 --> 01:10:27,929
这就是这个ViewBuilder要做的

1577
01:10:27,930 --> 01:10:30,280
如果卡片朝下，则为ZStack。 

1578
01:10:31,886 --> 01:10:33,182
看看是否可以解决该问题。 

1579
01:10:35,273 --> 01:10:38,757
然后我们得到南瓜，蜘蛛，鬼魂。 

1580
01:10:39,939 --> 01:10:41,689
哦，有比赛了，准备好了吗？ 

1581
01:10:41,689 --> 01:10:43,839
哇，这把他们带走了。 

1582
01:10:43,840 --> 01:10:46,520
另一场比赛，带走了那些。 

1583
01:10:46,520 --> 01:10:47,920
好的，这很好。 

1584
01:10:47,920 --> 01:10:51,197
我们的游戏基本上运行良好。 

1585
01:10:51,197 --> 01:10:54,369
因此，我想对模特做最后一件事。 

1586
01:10:54,369 --> 01:10:57,430
我有点担心我有这种状态， 

1587
01:10:57,430 --> 01:10:59,489
 indexOfTheOneAndOnlyFaceUpCard， 

1588
01:10:59,689 --> 01:11:01,659
我必须保持同步

1589
01:11:01,659 --> 01:11:04,409
我对卡的更改。 

1590
01:11:04,409 --> 01:11:07,720
这是一种容易出错的编程方式

1591
01:11:07,720 --> 01:11:09,960
当您在两个地方拥有州时。 

1592
01:11:09,960 --> 01:11:13,000
 indexOfTheOneAndOnlyFaceUpCard在这里， 

1593
01:11:13,000 --> 01:11:16,819
也可以从这些卡中确定

1594
01:11:16,819 --> 01:11:20,159
因此，让我们在这里使用计算的var 

1595
01:11:20,159 --> 01:11:25,159
并从卡中获取indexOfTheOneAndOnlyFaceUpCard。 

1596
01:11:25,270 --> 01:11:28,289
而且我们还将在这里进行一组

1597
01:11:28,489 --> 01:11:32,069
这样，如果有人设置indexOfTheOneAndOnlyFaceUpCard， 

1598
01:11:32,069 --> 01:11:35,029
我们将所有其他卡片正面朝下。 

1599
01:11:35,029 --> 01:11:37,219
这是您第一次看到计算属性

1600
01:11:37,220 --> 01:11:38,659
我们可以得到的价值， 

1601
01:11:38,859 --> 01:11:41,552
但我们也可以设置

1602
01:11:42,760 --> 01:11:45,029
让我们先设置一个。 

1603
01:11:45,229 --> 01:11:48,169
两者比较简单。 

1604
01:11:48,170 --> 01:11:51,060
当有人时我们将如何反应

1605
01:11:51,060 --> 01:11:56,060
设置indexOfTheOneAndOnlyFaceUpCard的值？ 

1606
01:11:56,159 --> 01:11:58,019
那么在这种情况下，我们需要经历

1607
01:11:58,020 --> 01:11:59,420
我们所有的卡。 

1608
01:11:59,420 --> 01:12:02,350
我将在这里浏览我们的索引。 

1609
01:12:02,350 --> 01:12:07,233
而且我要把所有卡片都朝下放置。 

1610
01:12:09,069 --> 01:12:11,549
除了我不想那样做

1611
01:12:11,550 --> 01:12:13,529
如果这是你说的

1612
01:12:13,529 --> 01:12:16,179
是indexOfTheOneAndOnlyFaceUpCard。 

1613
01:12:16,180 --> 01:12:20,670
在此集合内，有一个名为newValue的特殊变量。 

1614
01:12:20,670 --> 01:12:23,353
所以我可以告诉你索引是否等于newValue， 

1615
01:12:25,869 --> 01:12:28,729
这个人说这等于的价值， 

1616
01:12:28,729 --> 01:12:31,069
然后面朝上。 

1617
01:12:31,069 --> 01:12:33,299
所以newValue是特殊的var， 

1618
01:12:33,300 --> 01:12:37,850
仅在此集合内显示计算属性。 

1619
01:12:37,850 --> 01:12:40,000
这就是人们设定的目标。 

1620
01:12:40,199 --> 01:12:41,550
可能是零。 

1621
01:12:41,550 --> 01:12:44,770
此newValue是可选的，因此可以为nil。 

1622
01:12:44,770 --> 01:12:48,210
索引是一个整数，并且整数从不等于

1623
01:12:48,409 --> 01:12:50,139
未设置的可选

1624
01:12:50,140 --> 01:12:52,420
所以这等于是真的

1625
01:12:52,420 --> 01:12:54,140
如果这是可选的

1626
01:12:54,140 --> 01:12:57,563
及其关联的整数与此整数匹配

1627
01:12:59,039 --> 01:13:01,720
设置就这样，非常简单。 

1628
01:13:01,720 --> 01:13:03,720
怎么样呢？ 

1629
01:13:03,720 --> 01:13:06,520
好吧，要获得它，我真的需要查看所有卡片

1630
01:13:06,520 --> 01:13:07,829
看看哪些面朝上

1631
01:13:08,029 --> 01:13:09,619
看看是否只有一个。 

1632
01:13:09,619 --> 01:13:12,840
因此，让我们从获取所有面朝上的卡开始。 

1633
01:13:12,840 --> 01:13:15,819
所以我要说faceUpCardIndices。 

1634
01:13:15,819 --> 01:13:18,439
这将是一个整数数组。 

1635
01:13:18,439 --> 01:13:21,169
顺便说一句，我要在这里使用这种语法

1636
01:13:21,170 --> 01:13:22,670
表示整数数组。 

1637
01:13:22,670 --> 01:13:26,649
这与Int数组完全相同。 

1638
01:13:26,649 --> 01:13:28,899
我要说的是在现实世界中

1639
01:13:28,899 --> 01:13:33,000
实际上，这是首选语法。 

1640
01:13:33,000 --> 01:13:35,510
并非100％确信，但在我看来确实如此

1641
01:13:35,510 --> 01:13:37,949
人们更喜欢这种方法而不是Int数组。 

1642
01:13:37,949 --> 01:13:39,099
我喜欢整数数组。 

1643
01:13:39,100 --> 01:13:41,180
显然，这是通用的， 

1644
01:13:41,180 --> 01:13:43,880
不管是Int还是所有

1645
01:13:43,880 --> 01:13:47,340
但是使用数组非常普遍， 

1646
01:13:47,340 --> 01:13:49,853
所以我可以理解那里的速记。 

1647
01:13:50,739 --> 01:13:53,489
那么，现在我该如何获得这个faceUpCardIndices？ 

1648
01:13:53,489 --> 01:13:55,059
它从那里开始是空的， 

1649
01:13:55,060 --> 01:13:59,409
所以我要去找卡片索引。 

1650
01:13:59,609 --> 01:14:01,259
遍历我所有的卡。 

1651
01:14:01,260 --> 01:14:05,840
如果某个索引的卡面朝上， 

1652
01:14:05,840 --> 01:14:09,368
然后我将其放入faceUpCardIndices中， 

1653
01:14:09,368 --> 01:14:10,909
追加该索引。 

1654
01:14:11,109 --> 01:14:14,689
好吧，现在我有了所有面朝上的Card索引。 

1655
01:14:14,689 --> 01:14:19,469
我要说的是，如果faceUpCardIndices.count等于1， 

1656
01:14:19,470 --> 01:14:21,313
因此只有一张卡， 

1657
01:14:21,313 --> 01:14:26,313
然后我将那个faceUpCardIndices归零。 

1658
01:14:26,420 --> 01:14:28,550
顺便说一句，还有一个不错的小变种， 

1659
01:14:28,550 --> 01:14:30,340
首先。 

1660
01:14:30,340 --> 01:14:31,930
当我们先输入时

1661
01:14:31,930 --> 01:14:34,960
请注意，此变量的返回类型， 

1662
01:14:34,960 --> 01:14:38,560
或此var的类型是Int，问号， 

1663
01:14:38,560 --> 01:14:39,960
可选Int，为什么？ 

1664
01:14:39,960 --> 01:14:42,409
因为数组可能为空。 

1665
01:14:42,409 --> 01:14:44,739
因此，如果您说Array.first，而Array为空， 

1666
01:14:44,739 --> 01:14:46,840
这将返回nil。 

1667
01:14:46,840 --> 01:14:49,972
 Swift使用Optionals进行交流。 

1668
01:14:51,220 --> 01:14:53,810
否则，我将返回nil。 

1669
01:14:53,810 --> 01:14:57,210
因为如果没有一张卡

1670
01:14:57,210 --> 01:15:00,520
在面朝上的卡片列表中，那么显然， 

1671
01:15:00,520 --> 01:15:03,682
 indexOfTheOneAndOnlyFaceUpCard为零，仅此而已。 

1672
01:15:05,500 --> 01:15:07,289
所以现在计算出来

1673
01:15:07,289 --> 01:15:10,750
我不必太努力地确保它保持同步。 

1674
01:15:10,750 --> 01:15:13,859
例如，在这里，我什至不必说

1675
01:15:13,859 --> 01:15:16,479
 indexOfTheOneAndOnlyFaceUpCard为零。 

1676
01:15:16,479 --> 01:15:18,239
完全删除该代码

1677
01:15:18,239 --> 01:15:20,369
因为它总是会知道

1678
01:15:20,369 --> 01:15:22,039
当有两个面朝上的卡片时。 

1679
01:15:22,039 --> 01:15:23,699
它计算它。 

1680
01:15:23,699 --> 01:15:26,519
有点类似，因为我在这里

1681
01:15:26,520 --> 01:15:29,500
唯一的一张面朝上的卡片就是该索引， 

1682
01:15:29,500 --> 01:15:32,229
我不需要将所有其他部件正面朝下放置。 

1683
01:15:32,229 --> 01:15:35,332
这将由设置者自动完成。 

1684
01:15:36,250 --> 01:15:38,810
而且，将其面朝上的确如此， 

1685
01:15:38,810 --> 01:15:41,710
我们只需要在这里做，因为再次

1686
01:15:41,909 --> 01:15:44,047
设置indexOfTheOneAndOnlyFaceUpCard 

1687
01:15:44,047 --> 01:15:48,630
将确保此selectedIndex朝上。 

1688
01:15:49,469 --> 01:15:52,340
因此，这使得该代码非常少

1689
01:15:52,340 --> 01:15:54,159
玩整个纸牌配对游戏。 

1690
01:15:54,359 --> 01:15:57,567
现在，这里要花很多代码。 

1691
01:15:57,567 --> 01:15:59,250
我们将在一秒钟内解决该问题， 

1692
01:15:59,250 --> 01:16:02,622
但请确保这没有破坏任何内容。 

1693
01:16:03,649 --> 01:16:04,519
开始了。 

1694
01:16:04,520 --> 01:16:08,840
南瓜，蜘蛛，蜘蛛，蜘蛛，南瓜，好吧。 

1695
01:16:08,840 --> 01:16:12,930
鬼，不，南瓜，鬼，鬼，鬼，南瓜。 

1696
01:16:12,930 --> 01:16:14,630
所以这是工作。 

1697
01:16:14,630 --> 01:16:16,779
漂亮的代码就在这里。 

1698
01:16:16,979 --> 01:16:20,500
这里的代码多于我们所需的代码。 

1699
01:16:20,500 --> 01:16:23,693
那么，如何才能减少此代码呢？ 

1700
01:16:24,600 --> 01:16:26,000
在这里，我只能想到一件事

1701
01:16:26,199 --> 01:16:28,699
使它更有效率， 

1702
01:16:28,699 --> 01:16:31,579
这是我在说的是真的

1703
01:16:31,579 --> 01:16:34,710
然后将其设置为true，否则将其设置为false。 

1704
01:16:34,710 --> 01:16:38,273
我可以把它放到这里。 

1705
01:16:39,248 --> 01:16:41,909
然后，我不需要所有这些开销

1706
01:16:41,909 --> 01:16:43,722
这一切的语法如果。 

1707
01:16:44,605 --> 01:16:45,859
所以我要设置每张卡。 

1708
01:16:45,859 --> 01:16:48,219
除非索引，否则我将其设置为false 

1709
01:16:48,220 --> 01:16:50,770
等于那个人所说的等于， 

1710
01:16:50,770 --> 01:16:52,070
就像我在这里做。 

1711
01:16:53,344 --> 01:16:54,176
很好。 

1712
01:16:54,176 --> 01:16:56,059
那是最少的代码。 

1713
01:16:56,060 --> 01:16:57,350
那怎么办

1714
01:16:57,350 --> 01:16:59,060
信不信由你，我要做到

1715
01:16:59,060 --> 01:17:00,489
所以这是一行代码。 

1716
01:17:00,689 --> 01:17:03,169
您知道我们喜欢此类中的一行代码。 

1717
01:17:03,170 --> 01:17:05,859
您的第一次家庭作业证明了这一点。 

1718
01:17:05,859 --> 01:17:08,229
那么我该如何编写这一行代码？ 

1719
01:17:08,229 --> 01:17:12,139
我将从这里拥有所有这些开始

1720
01:17:12,140 --> 01:17:13,930
成为一行，我要做

1721
01:17:13,930 --> 01:17:17,329
具有称为过滤器的范围内的功能。 

1722
01:17:17,529 --> 01:17:20,929
所以我要拿我的卡指数，这是一个范围

1723
01:17:20,930 --> 01:17:24,369
在零，点点之间，小于cards.count。 

1724
01:17:24,369 --> 01:17:26,699
并调用此函数过滤器。 

1725
01:17:26,699 --> 01:17:29,149
您会在此处看到过滤器。 

1726
01:17:29,149 --> 01:17:31,199
它返回一个整数数组。 

1727
01:17:31,199 --> 01:17:33,760
您在这里在左侧看到整数数组。 

1728
01:17:33,760 --> 01:17:37,579
这些整数就是这个范围内的所有整数

1729
01:17:37,579 --> 01:17:40,199
该函数需要一个Int 

1730
01:17:40,199 --> 01:17:42,292
并返回布尔值，则返回true。 

1731
01:17:43,609 --> 01:17:44,442
所以看起来像这样。 

1732
01:17:44,443 --> 01:17:45,909
让我们双击这个。 

1733
01:17:45,909 --> 01:17:46,742
这里是。 

1734
01:17:46,743 --> 01:17:48,630
我什至可以双击它。 

1735
01:17:48,630 --> 01:17:50,199
它为我填补了。 

1736
01:17:50,199 --> 01:17:52,880
这是一个函数，一个内联函数， 

1737
01:17:52,880 --> 01:17:55,880
需要一个Int并返回一个Bool。 

1738
01:17:55,880 --> 01:18:00,210
我们应该返回是否包含此Int， 

1739
01:18:00,210 --> 01:18:01,853
这是指数之一

1740
01:18:02,920 --> 01:18:05,279
在结果faceUpCardIndices中。 

1741
01:18:05,479 --> 01:18:09,079
我们通过过滤掉其他阵列来制作一个新的阵列。 

1742
01:18:09,079 --> 01:18:13,859
这就是索引，因此我们将其称为索引。 

1743
01:18:13,859 --> 01:18:14,859
我们想做什么？ 

1744
01:18:14,859 --> 01:18:19,460
我们想说该索引处的归还卡片， 

1745
01:18:19,460 --> 01:18:20,856
点是isFaceUp。 

1746
01:18:22,360 --> 01:18:24,439
这就是我们想要做的。 

1747
01:18:24,439 --> 01:18:27,819
当然，我们希望在Swift中减少代码量， 

1748
01:18:27,819 --> 01:18:31,052
这样我们就可以收回这个回报。 

1749
01:18:32,340 --> 01:18:35,113
也许我们会像这样把它放在这里。 

1750
01:18:36,989 --> 01:18:39,630
我们可以推断出此返回类型。 

1751
01:18:39,630 --> 01:18:42,913
不需要那个，也不需要这些括号。 

1752
01:18:43,770 --> 01:18:45,170
我上次没有给你看的另一件事

1753
01:18:45,369 --> 01:18:48,399
我们可以做得更小， 

1754
01:18:48,399 --> 01:18:51,129
这是参数在这里指定

1755
01:18:51,130 --> 01:18:51,949
带索引。 

1756
01:18:52,149 --> 01:18:55,629
您可以摆脱它，而只需使用零美元， 

1757
01:18:55,630 --> 01:18:58,329
每个参数分别为1美元和2美元。 

1758
01:18:58,329 --> 01:18:59,670
第一个参数为零美元， 

1759
01:18:59,670 --> 01:19:01,970
第二个论点一美元等等。 

1760
01:19:02,869 --> 01:19:04,119
所以我们快到了。 

1761
01:19:04,119 --> 01:19:07,210
这一切都就在这里。 

1762
01:19:07,210 --> 01:19:11,039
因为我们现在只需一口气计算一下， 

1763
01:19:11,039 --> 01:19:11,872
我们在这里得到这个警告

1764
01:19:11,872 --> 01:19:15,382
现在可以放手了。 

1765
01:19:16,239 --> 01:19:17,639
这个怎么样？ 

1766
01:19:17,640 --> 01:19:19,079
我们如何摆脱这一点？ 

1767
01:19:19,079 --> 01:19:20,029
这里发生了什么？ 

1768
01:19:20,029 --> 01:19:23,409
在这里，我们实际上只是对索引数组说， 

1769
01:19:23,409 --> 01:19:25,460
如果只有你们一个，把它给我。 

1770
01:19:25,460 --> 01:19:27,300
否则，请给我零。 

1771
01:19:27,300 --> 01:19:29,369
好吧，为什么我们不扩展Array， 

1772
01:19:29,569 --> 01:19:34,229
使用扩展数组，有一个这样做的var？ 

1773
01:19:34,229 --> 01:19:36,119
因为这似乎是一个合理的数组问题。 

1774
01:19:36,119 --> 01:19:39,180
嘿Array先生，只给我自己一件事， 

1775
01:19:39,180 --> 01:19:41,170
否则给我零。 

1776
01:19:41,170 --> 01:19:44,563
因此，让我们在这里为Array创建另一个扩展。 

1777
01:19:45,411 --> 01:19:46,750
做一个Swift文件。 

1778
01:19:46,750 --> 01:19:49,810
我们称其为Array + Only 

1779
01:19:49,810 --> 01:19:53,350
因为它返回数组中的唯一内容。 

1780
01:19:53,350 --> 01:19:58,350
而对Array的扩展将扩展所有Array。 

1781
01:19:58,630 --> 01:20:01,119
对Array的这种扩展不是这样的

1782
01:20:01,119 --> 01:20:03,300
元素可识别的位置。 

1783
01:20:03,300 --> 01:20:05,529
这个扩展到所有数组。 

1784
01:20:05,529 --> 01:20:07,889
它将添加此变量，我仅会调用。 

1785
01:20:07,890 --> 01:20:12,289
类型为元素，问号，可选元素。 

1786
01:20:12,289 --> 01:20:15,329
它是经过计算的，它只返回数组的计数

1787
01:20:15,329 --> 01:20:18,132
等于一个，第一个，冒号，零。 

1788
01:20:19,060 --> 01:20:22,680
因此这在Array中，因此count是Array的计数。 

1789
01:20:22,680 --> 01:20:23,619
如果那等于一， 

1790
01:20:23,819 --> 01:20:26,189
我们在这里使用这个三元运算符

1791
01:20:26,189 --> 01:20:28,799
返回数组中的第一项。 

1792
01:20:28,800 --> 01:20:29,823
否则为零。 

1793
01:20:32,140 --> 01:20:34,869
超级简单，那超级简单的代码

1794
01:20:34,869 --> 01:20:37,309
使一切都在这里消失。 

1795
01:20:37,310 --> 01:20:39,250
我们不需要任何这些。 

1796
01:20:39,250 --> 01:20:43,077
相反，我们可以在这里只说点

1797
01:20:43,077 --> 01:20:45,500
并摆脱所有这些。 

1798
01:20:45,500 --> 01:20:47,170
只需退货。 

1799
01:20:47,170 --> 01:20:50,770
但是，由于现在这是单线的，所以我们不需要退货。 

1800
01:20:50,770 --> 01:20:53,970
我们甚至可以在这里将其全部变成一行

1801
01:20:53,970 --> 01:20:55,077
也这样

1802
01:20:55,077 --> 01:20:59,489
这段代码突然变得紧凑了很多。 

1803
01:20:59,689 --> 01:21:02,122
因此，请确保我们没有在此处破坏任何内容。 

1804
01:21:03,859 --> 01:21:08,859
单击，是的，哦，是的，它有效。 

1805
01:21:09,449 --> 01:21:13,039
现在，这已经为您的作业设置了精美的外观。 

1806
01:21:13,039 --> 01:21:16,039
您现在要使用此工作游戏

1807
01:21:16,039 --> 01:21:18,670
并对其进行一些增强。 

1808
01:21:18,670 --> 01:21:20,489
因此，请查看相关内容。 

1809
01:21:20,489 --> 01:21:22,630
我们下次见。 

1810
01:21:22,630 --> 01:21:27,630
 -[旁白]有关更多信息，请访问stanford.edu。 

1
00:00:01,219 --> 00:00:03,802
(gentle music)

2
00:00:04,940 --> 00:00:06,590
- [Narrator] Stanford University.

3
00:00:08,170 --> 00:00:10,580
- [Instructor] We are back, lecture four.

4
00:00:10,580 --> 00:00:15,160
Stanford CS193p, spring of 2020.

5
00:00:15,160 --> 00:00:18,210
Today, I'm going to start
off with a big demo,

6
00:00:18,210 --> 00:00:20,670
and it's going to be to make our card game

7
00:00:20,670 --> 00:00:23,980
be in rows and columns, instead
of all across in one row,

8
00:00:23,980 --> 00:00:27,280
which is gonna make our
game a lot better, no doubt,

9
00:00:27,280 --> 00:00:29,640
but it's also gonna be
a super good example

10
00:00:29,640 --> 00:00:32,430
of doing generics with protocols,

11
00:00:32,430 --> 00:00:34,730
and also functions as types.

12
00:00:34,730 --> 00:00:37,040
And we're gonna learn more
about being a container View

13
00:00:37,040 --> 00:00:38,470
because we're gonna build our own

14
00:00:38,470 --> 00:00:41,970
rows and columns container
View for our cards.

15
00:00:41,970 --> 00:00:44,820
After that demo, we're gonna
hop back into the slides here.

16
00:00:44,820 --> 00:00:47,300
We're gonna talk more about
the Swift type systems,

17
00:00:47,300 --> 00:00:51,050
specifically the type enum.

18
00:00:51,050 --> 00:00:53,780
And then after that, we're
gonna continue in the slides

19
00:00:53,780 --> 00:00:56,590
and talk about one of
the most important types

20
00:00:56,590 --> 00:00:59,583
in all of Swift, Optional,
which happens to be an enum.

21
00:01:01,001 --> 00:01:03,650
And Optional is so
important that I'm gonna go

22
00:01:03,650 --> 00:01:05,440
right back into a demo after that

23
00:01:05,440 --> 00:01:08,390
and show you two really important examples

24
00:01:08,390 --> 00:01:12,393
of using an Optional to
design your code in Swift.

25
00:01:13,380 --> 00:01:15,853
So, let's get started with that demo.

26
00:01:16,920 --> 00:01:20,550
All right, well, it's type
to fix this major deficiency

27
00:01:20,550 --> 00:01:23,020
in our game, which is
that all of the cards

28
00:01:23,020 --> 00:01:24,410
are in one row,

29
00:01:24,410 --> 00:01:26,900
and we know that we could
much more efficiently

30
00:01:26,900 --> 00:01:30,280
use this space if we had rows and columns.

31
00:01:30,280 --> 00:01:33,930
We're gonna do that by
replacing our HStack here

32
00:01:33,930 --> 00:01:35,770
with a Grid.

33
00:01:35,770 --> 00:01:39,770
Now as of the taping of this class,

34
00:01:39,770 --> 00:01:42,580
there was no such thing
as a Grid in SwiftUI,

35
00:01:42,580 --> 00:01:44,017
so we're gonna have to write that.

36
00:01:44,017 --> 00:01:47,160
And it actually provides
us with a great opportunity

37
00:01:47,160 --> 00:01:51,570
to learn a lot about how
things like ZStack work.

38
00:01:51,570 --> 00:01:55,080
So, ZStack we know takes
this argument right here,

39
00:01:55,080 --> 00:01:56,830
which is a function.

40
00:01:56,830 --> 00:01:58,397
This curly brace means it's a function.

41
00:01:58,397 --> 00:02:00,920
It's a function that takes no arguments,

42
00:02:00,920 --> 00:02:05,420
unlike for example, ForEach,
its function to create a View

43
00:02:05,420 --> 00:02:06,960
takes an argument.

44
00:02:06,960 --> 00:02:09,900
But ZStack, the View that gets built here

45
00:02:09,900 --> 00:02:11,200
is quite powerful.

46
00:02:11,200 --> 00:02:13,960
It could be a list of other Views.

47
00:02:13,960 --> 00:02:17,800
It could be a if-then,
a combination thereof.

48
00:02:17,800 --> 00:02:20,990
So this particular function that can build

49
00:02:20,990 --> 00:02:24,783
these complicated View
is called a ViewBuilder.

50
00:02:25,830 --> 00:02:28,300
And we're not gonna use
ViewBuilder quite yet.

51
00:02:28,300 --> 00:02:30,600
We'll eventually learn about ViewBuilder.

52
00:02:30,600 --> 00:02:34,420
So our Grid is just
gonna have a simple View

53
00:02:34,420 --> 00:02:38,020
that it's going to
replicate using a ForEach,

54
00:02:38,020 --> 00:02:39,950
exactly the same way as a ForEach,

55
00:02:39,950 --> 00:02:42,790
to put a certain View at every spot

56
00:02:42,790 --> 00:02:44,530
in the row and column.

57
00:02:44,530 --> 00:02:49,240
So our Grid is really going
to combine HStack like Grid,

58
00:02:49,240 --> 00:02:51,980
except for 2D HStack if
you wanna think of it,

59
00:02:51,980 --> 00:02:54,480
with ForEach like this.

60
00:02:54,480 --> 00:02:59,110
We're gonna take an Array
of Identifiable things,

61
00:02:59,110 --> 00:03:03,620
like these Cards, and then
we're going to pass a function

62
00:03:03,620 --> 00:03:07,260
that takes one of the Identifiable
things as its argument,

63
00:03:07,260 --> 00:03:09,290
and returns the View to use

64
00:03:09,290 --> 00:03:11,820
to draw at that location in the Grid.

65
00:03:11,820 --> 00:03:13,433
Very simple here.

66
00:03:14,460 --> 00:03:15,893
So let's go create that View.

67
00:03:15,893 --> 00:03:17,720
We're gonna go over here to New, File.

68
00:03:17,720 --> 00:03:20,530
We're gonna put it in its own
file because this is really

69
00:03:20,530 --> 00:03:23,380
a very powerful reusable object.

70
00:03:23,380 --> 00:03:26,690
We could use it in all our
apps that needed a Grid.

71
00:03:26,690 --> 00:03:29,500
So it is a SwiftUI View,
so I'm gonna click there.

72
00:03:29,500 --> 00:03:31,070
I'm gonna call it Grid.

73
00:03:31,070 --> 00:03:33,260
Gonna double-check that
it's in one of these

74
00:03:33,260 --> 00:03:36,110
yellow folders here and that this content

75
00:03:36,110 --> 00:03:39,850
kinda matches that, and
it does, so we're good.

76
00:03:39,850 --> 00:03:43,500
And here's our Grid, and of
course, we get "Hello, World!"

77
00:03:43,500 --> 00:03:46,270
This code down here, you'll
remember, at the bottom

78
00:03:46,270 --> 00:03:50,270
is to hook us up to our canvas over here.

79
00:03:50,270 --> 00:03:53,160
But this Grid is completely generic.

80
00:03:53,160 --> 00:03:55,950
And so, if we were gonna
make this preview work,

81
00:03:55,950 --> 00:03:59,390
we would need to come up
with some test data for it.

82
00:03:59,390 --> 00:04:01,700
And we're not gonna do that in this demo,

83
00:04:01,700 --> 00:04:04,270
but someday in the future,
maybe you could do it

84
00:04:04,270 --> 00:04:05,690
as an exercise.

85
00:04:05,690 --> 00:04:08,330
But if you ever delete
this and need it back,

86
00:04:08,330 --> 00:04:11,863
it'll say Create Preview
here in your canvas.

87
00:04:13,000 --> 00:04:16,020
All right, so we gotta
get started on Grid.

88
00:04:16,020 --> 00:04:19,000
First thing we're gonna
do is its two arguments.

89
00:04:19,000 --> 00:04:23,880
The first argument is this
Array of Identifiable,

90
00:04:23,880 --> 00:04:25,860
and the second argument is this function

91
00:04:25,860 --> 00:04:28,480
that takes one of the
Identifiables and provides a View.

92
00:04:28,480 --> 00:04:31,980
So let's get those two
arguments there as vars.

93
00:04:31,980 --> 00:04:36,980
So the first var is I'll call
it items, an Array of Item.

94
00:04:38,310 --> 00:04:41,640
And this Item for us in
Grid is a don't-care.

95
00:04:41,640 --> 00:04:45,750
We really don't-care what that thing is.

96
00:04:45,750 --> 00:04:46,583
It could be anything.

97
00:04:46,583 --> 00:04:50,230
It's gonna be a Card over
here, but there's no reason

98
00:04:50,230 --> 00:04:51,600
for it to be any particular thing,

99
00:04:51,600 --> 00:04:53,430
so it's a don't-care for us.

100
00:04:53,430 --> 00:04:56,379
And similarly, that second argument,

101
00:04:56,379 --> 00:04:59,240
viewForItem I'll call
it, that's a function.

102
00:04:59,240 --> 00:05:02,420
It's a function that takes
an Item as the argument,

103
00:05:02,420 --> 00:05:05,500
and it returns some ItemView,

104
00:05:05,500 --> 00:05:07,460
which is another don't-care for us.

105
00:05:07,460 --> 00:05:10,540
We really don't-care what
kind of View you provide

106
00:05:10,540 --> 00:05:13,957
for each item, so that's
a don't-care, ItemView.

107
00:05:14,980 --> 00:05:19,060
Good start, and we could actually
get this going over here.

108
00:05:19,060 --> 00:05:23,000
Unfortunately, we have to
name this items right there.

109
00:05:23,000 --> 00:05:27,030
This one is really viewForItem,

110
00:05:27,030 --> 00:05:29,170
and put that right there.

111
00:05:29,170 --> 00:05:32,860
But this is the last
argument to this function,

112
00:05:32,860 --> 00:05:35,350
so we know that when the last argument

113
00:05:35,350 --> 00:05:38,320
to a function is another function,

114
00:05:38,320 --> 00:05:41,630
then we can just get rid of
that label, close it off,

115
00:05:41,630 --> 00:05:44,940
and have our function
kinda float on the outside.

116
00:05:44,940 --> 00:05:48,360
So this is the last argument to our Grid.

117
00:05:48,360 --> 00:05:52,000
And that is both of its vars,
this one and the viewForItem.

118
00:05:52,000 --> 00:05:54,320
Just like when we called CardView here,

119
00:05:54,320 --> 00:05:58,380
we had to initialize its
vars as this one Card var,

120
00:05:58,380 --> 00:06:00,000
same thing here with Grid.

121
00:06:00,000 --> 00:06:02,030
We're initializing its two vars.

122
00:06:03,250 --> 00:06:05,850
This might be a good time
to talk about how is it

123
00:06:05,850 --> 00:06:09,050
that ForEach doesn't have
to have this label items?

124
00:06:09,050 --> 00:06:13,510
When we had ForEach, it just
had the iteratable thing

125
00:06:13,510 --> 00:06:15,280
that had Identifiables in it.

126
00:06:15,280 --> 00:06:16,970
How come it didn't have an argument?

127
00:06:16,970 --> 00:06:20,410
Well, it's using technology
that you know well to do that.

128
00:06:20,410 --> 00:06:22,240
So let's do it in Grid as well,

129
00:06:22,240 --> 00:06:24,460
which is it's just an init.

130
00:06:24,460 --> 00:06:27,780
So normally you might
have your init say items

131
00:06:27,780 --> 00:06:32,780
is an Array of Item,
viewForItem is a function

132
00:06:32,910 --> 00:06:36,353
that takes an Item and
returns some ItemView.

133
00:06:37,246 --> 00:06:38,847
That would be a normal kind of init.

134
00:06:38,847 --> 00:06:41,020
And in here, you just want to

135
00:06:41,020 --> 00:06:43,210
initialize your vars, like items.

136
00:06:43,210 --> 00:06:45,790
Well, that's equal to the
Items that are passed in.

137
00:06:45,790 --> 00:06:49,530
And then viewForItem, that's
equal to the viewForItem

138
00:06:49,530 --> 00:06:50,930
that's passed in.

139
00:06:50,930 --> 00:06:53,960
By the way, Swift is gonna
be very confused here

140
00:06:53,960 --> 00:06:58,240
because it doesn't know
which items this is

141
00:06:58,240 --> 00:06:59,680
and which items this is.

142
00:06:59,680 --> 00:07:02,570
We've got a local argument to
this function called items,

143
00:07:02,570 --> 00:07:05,760
and then we have a property called items.

144
00:07:05,760 --> 00:07:08,520
So you can easily fix
Swift's confusion here

145
00:07:08,520 --> 00:07:13,520
by saying self.items,
and self.viewForItem.

146
00:07:13,570 --> 00:07:15,813
This is a different reason
to have to put self here

147
00:07:15,813 --> 00:07:20,700
than we saw with the explicit
self blah-blah-blah hit fix.

148
00:07:20,700 --> 00:07:22,160
But it makes sense here, right?

149
00:07:22,160 --> 00:07:24,970
By doing self.items, now
Swift knows that we're talking

150
00:07:24,970 --> 00:07:26,210
about the green one,

151
00:07:26,210 --> 00:07:28,263
and that this one must be the black one.

152
00:07:29,620 --> 00:07:33,230
Now, this allows us to put this under-bar

153
00:07:33,230 --> 00:07:34,550
as the external name.

154
00:07:34,550 --> 00:07:36,710
Remember under-bar is external name

155
00:07:36,710 --> 00:07:40,260
means do not provide an external name,

156
00:07:40,260 --> 00:07:42,877
and that's exactly what's going on here.

157
00:07:42,877 --> 00:07:45,980
And if I rebuild, you're gonna see

158
00:07:45,980 --> 00:07:48,300
that this code over here, perfectly fine.

159
00:07:49,590 --> 00:07:53,570
However, we still have a
problem back here in our Grid.

160
00:07:53,570 --> 00:07:55,270
This error right here.

161
00:07:55,270 --> 00:07:58,157
It says, "Assigning non-escaping parameter

162
00:07:58,157 --> 00:08:02,500
"'viewForItem' to an @escaping closure."

163
00:08:02,500 --> 00:08:05,450
So I'm gonna try and explain
this escaping closure

164
00:08:05,450 --> 00:08:06,840
in just a few minutes.

165
00:08:06,840 --> 00:08:10,097
Normally, I would actually
probably have slides on it.

166
00:08:10,097 --> 00:08:14,270
I'm gonna skip that this
quarter because in SwiftUI,

167
00:08:14,270 --> 00:08:16,190
since we're doing functional programming,

168
00:08:16,190 --> 00:08:18,270
almost everything is a value type,

169
00:08:18,270 --> 00:08:21,560
and the problem that this
escaping closure thing

170
00:08:21,560 --> 00:08:23,660
is trying to address here

171
00:08:23,660 --> 00:08:26,510
really, really rare in SwiftUI.

172
00:08:26,510 --> 00:08:30,617
Happened a lot more when we
had object-oriented programming

173
00:08:30,617 --> 00:08:31,450
in UIkit.

174
00:08:32,570 --> 00:08:34,920
So, here's what's going on.

175
00:08:34,920 --> 00:08:37,090
This function that's passed in here

176
00:08:37,090 --> 00:08:39,600
that creates a View for a given item

177
00:08:39,600 --> 00:08:42,780
is not actually used in this initializer.

178
00:08:42,780 --> 00:08:46,090
We salt it away into a
var and call it later.

179
00:08:46,090 --> 00:08:47,950
We're gonna call it down here in our body

180
00:08:47,950 --> 00:08:50,050
when we need to actually create the Views

181
00:08:50,050 --> 00:08:52,120
for all of our Items.

182
00:08:52,120 --> 00:08:56,350
So, we have to mark this
kind of function, @escaping.

183
00:08:57,980 --> 00:09:00,140
You can think of it as this function

184
00:09:00,140 --> 00:09:04,190
is going to escape from this initializer

185
00:09:04,190 --> 00:09:05,703
without getting called.

186
00:09:06,550 --> 00:09:08,330
Now, Swift has to be careful,

187
00:09:08,330 --> 00:09:10,230
and it's actually very powerful

188
00:09:10,230 --> 00:09:12,270
and knows how to deal with these functions

189
00:09:12,270 --> 00:09:14,250
that might get called later.

190
00:09:14,250 --> 00:09:15,990
Why can that be an issue?

191
00:09:15,990 --> 00:09:18,420
Well, let's look back
here where we actually

192
00:09:18,420 --> 00:09:20,170
pass this function in.

193
00:09:20,170 --> 00:09:24,980
Whatever code is in here has
to be able to be called later.

194
00:09:24,980 --> 00:09:27,810
So if we use any variables,
especially if we use

195
00:09:27,810 --> 00:09:31,150
a local variable or
something from this function,

196
00:09:31,150 --> 00:09:34,420
that has to be around in the future

197
00:09:34,420 --> 00:09:36,563
when this function gets executed.

198
00:09:37,410 --> 00:09:41,040
Now, how does Swift
accomplish this wonderful feat

199
00:09:41,040 --> 00:09:45,440
of keeping everything in
here around until the future?

200
00:09:45,440 --> 00:09:48,400
Well, it does this by
making function types

201
00:09:48,400 --> 00:09:50,150
be reference types.

202
00:09:50,150 --> 00:09:55,080
Just like classes, our
ViewModel are reference types,

203
00:09:55,080 --> 00:09:56,670
they live in the heap.

204
00:09:56,670 --> 00:09:57,750
They're stored in memory.

205
00:09:57,750 --> 00:09:59,140
People have pointers to them.

206
00:09:59,140 --> 00:10:02,680
Same thing with these functions
that can be called later.

207
00:09:59,140 --> 00:10:02,680
Same thing with these functions
that can be called later.

208
00:10:02,680 --> 00:10:06,160
They live in the heap and
they have pointers to them.

209
00:10:06,160 --> 00:10:11,160
Now, the things inside of here
might also live in the heap.

210
00:10:11,550 --> 00:10:15,290
If any of the things in here
are classes, for example,

211
00:10:15,290 --> 00:10:18,340
then the self in here
is gonna be a pointer

212
00:10:18,340 --> 00:10:19,760
to something in the heap.

213
00:10:19,760 --> 00:10:23,490
And the problem we're trying
to avoid here in Swift

214
00:10:23,490 --> 00:10:27,960
is having self have some var in it

215
00:10:27,960 --> 00:10:30,480
that actually points to this function

216
00:10:30,480 --> 00:10:34,880
because we know this function
points to self inside here.

217
00:10:34,880 --> 00:10:36,430
They're both gonna be in the heap.

218
00:10:36,430 --> 00:10:37,630
The function's kept in the heap

219
00:10:37,630 --> 00:10:39,520
because it's gonna be executed later.

220
00:10:39,520 --> 00:10:42,210
All the things inside the
function have be kept in the heap

221
00:10:42,210 --> 00:10:44,720
so that it will properly execute later.

222
00:10:44,720 --> 00:10:47,440
And so if anything in here points back,

223
00:10:47,440 --> 00:10:49,810
we've got a situation where
two things in the heap

224
00:10:49,810 --> 00:10:51,840
are pointing to each other.

225
00:10:51,840 --> 00:10:54,670
And the way that Swift cleans up memory

226
00:10:54,670 --> 00:10:57,060
is when nobody points
to something anymore,

227
00:10:57,060 --> 00:10:59,010
it cleans up the memory and frees it up

228
00:10:59,010 --> 00:11:00,390
for someone else to use.

229
00:11:00,390 --> 00:11:02,520
Well, if two things are
pointing to each other

230
00:11:02,520 --> 00:11:03,800
and they're both in the heap,

231
00:11:03,800 --> 00:11:05,870
they're never gonna be able to go away

232
00:11:05,870 --> 00:11:07,740
because they're always gonna
have a pointer to each other.

233
00:11:07,740 --> 00:11:10,750
That's called a memory cycle.

234
00:11:10,750 --> 00:11:14,440
So, this whole thing is to try to make it

235
00:11:14,440 --> 00:11:17,210
so that we can detect memory cycles

236
00:11:17,210 --> 00:11:20,590
by seeing these escaping functions.

237
00:11:20,590 --> 00:11:25,590
Amazingly, this is also why you
get this warning about self.

238
00:11:26,190 --> 00:11:28,590
You know when we don't
put a self-dot in here

239
00:11:28,590 --> 00:11:30,560
in our onTapGesture function,

240
00:11:30,560 --> 00:11:32,360
we're gonna get this error that says

241
00:11:32,360 --> 00:11:34,660
this requires explicit self

242
00:11:34,660 --> 00:11:37,400
to make the capture semantics explicit.

243
00:11:37,400 --> 00:11:40,140
Capture semantics means
the fact that it's going

244
00:11:40,140 --> 00:11:42,720
to capture everything in here,

245
00:11:42,720 --> 00:11:46,010
inside this onTapGesture's function,

246
00:11:46,010 --> 00:11:48,510
and keep it in the heap
so that when onTapGesture

247
00:11:48,510 --> 00:11:52,500
executes it in the future when
someone taps on this Card,

248
00:11:52,500 --> 00:11:54,600
that this stuff is still around.

249
00:11:54,600 --> 00:11:55,720
Well if you look at this code,

250
00:11:55,720 --> 00:11:58,420
you're thinking, "Oh well, I
guess it captures ViewModel,"

251
00:11:58,420 --> 00:12:02,120
but it actually would
have to capture self.

252
00:12:02,120 --> 00:12:04,120
So it makes you type the self

253
00:12:04,120 --> 00:12:05,950
so that you realize, oh yes,

254
00:12:05,950 --> 00:12:08,797
this function is going to
make self be in memory.

255
00:12:08,797 --> 00:12:11,160
And then you can verify
that self doesn't actually

256
00:12:11,160 --> 00:12:13,870
somehow directly or
indirectly come back around

257
00:12:13,870 --> 00:12:16,820
and point to this function,

258
00:12:16,820 --> 00:12:19,920
which it doesn't do in
this case because in here,

259
00:12:19,920 --> 00:12:22,270
our ViewModel never points to our Views.

260
00:12:22,270 --> 00:12:24,900
Views point to the ViewModel
but not backwards direction,

261
00:12:24,900 --> 00:12:26,160
so it's no problem.

262
00:12:26,160 --> 00:12:29,580
But even more it's no
problem because this self-dot

263
00:12:29,580 --> 00:12:31,410
does not live in the heap anyway.

264
00:12:31,410 --> 00:12:35,260
This self-dot is this
struct, self is this struct.

265
00:12:35,260 --> 00:12:36,950
Structs are value types.

266
00:12:36,950 --> 00:12:38,300
They don't live in the heap.

267
00:12:38,300 --> 00:12:41,080
So, this is not necessary anyway.

268
00:12:41,080 --> 00:12:45,130
And that is the fix that
has been publicly approved,

269
00:12:45,130 --> 00:12:47,220
that you're probably gonna
see a couple of months

270
00:12:47,220 --> 00:12:49,120
after this video is made.

271
00:12:49,120 --> 00:12:52,310
So this is gonna be out of
date quickly, this video.

272
00:12:52,310 --> 00:12:55,530
But the fix is basically
if self, in this case,

273
00:12:55,530 --> 00:12:57,990
inside of one of these escaping functions

274
00:12:57,990 --> 00:12:59,620
is gonna be held around in the heap,

275
00:12:59,620 --> 00:13:01,680
if self doesn't live in the heap,

276
00:13:01,680 --> 00:13:05,600
in other words, it's a value
type, a struct or an enum,

277
00:13:05,600 --> 00:13:09,010
then you don't need to
have this error come up

278
00:13:09,010 --> 00:13:11,747
and warn you, "Hey, put self-dot there

279
00:13:11,747 --> 00:13:13,807
"so you make sure you
don't have a memory cycle

280
00:13:13,807 --> 00:13:15,187
"where self points to this function,

281
00:13:15,187 --> 00:13:16,620
"this function points to self."

282
00:13:16,620 --> 00:13:19,230
That can't happen because
there aren't two things

283
00:13:19,230 --> 00:13:20,470
in the heap that could point to each other

284
00:13:20,470 --> 00:13:22,280
because self is a struct.

285
00:13:22,280 --> 00:13:24,530
It's a value type, does
not live in the heap.

286
00:13:26,000 --> 00:13:29,600
So, there you got just a
little quick explanation

287
00:13:29,600 --> 00:13:32,550
of all this escaping, and
you even understand now

288
00:13:32,550 --> 00:13:34,060
what this self-dot is.

289
00:13:34,060 --> 00:13:36,480
If you don't understand
all of things I just said

290
00:13:36,480 --> 00:13:40,540
about these escaping
functions and this self-dot,

291
00:13:40,540 --> 00:13:43,280
really, I don't think you have
to worry about it that much

292
00:13:43,280 --> 00:13:44,113
for a couple reasons.

293
00:13:44,113 --> 00:13:46,440
One, this week's reading,
you're gonna read

294
00:13:46,440 --> 00:13:48,550
about these closures, these functions

295
00:13:48,550 --> 00:13:51,870
that are in-line that
capture the stuff they need

296
00:13:51,870 --> 00:13:53,670
to be able to execute later.

297
00:13:53,670 --> 00:13:56,090
So when you read that,
maybe you'll understand it.

298
00:13:56,090 --> 00:13:57,440
Of course, you always have the option,

299
00:13:57,440 --> 00:14:01,090
go on the class forums, ask
more about it to clarify.

300
00:14:01,090 --> 00:14:05,160
And finally, with SwiftUI,
it's just not that important

301
00:14:05,160 --> 00:14:09,110
because so many of the
self-dots are just value types.

302
00:14:09,110 --> 00:14:12,840
Everything in the View, for
example, is all value types.

303
00:14:12,840 --> 00:14:15,170
Our ViewModel, it's a class.

304
00:14:15,170 --> 00:14:17,730
It has possibilities.

305
00:14:17,730 --> 00:14:20,070
But since the ViewModel
never points to anything

306
00:14:20,070 --> 00:14:22,160
in the View, we never really have to worry

307
00:14:22,160 --> 00:14:25,720
about anything in the View
creating these memory cycles.

308
00:14:25,720 --> 00:14:26,553
It'd be very rare.

309
00:14:26,553 --> 00:14:28,840
It's possible to do, but very, very rare.

310
00:14:28,840 --> 00:14:30,800
So the bottom line is I
don't think you have to worry

311
00:14:30,800 --> 00:14:31,890
about it that much.

312
00:14:31,890 --> 00:14:33,240
The only thing that's gonna bother you

313
00:14:33,240 --> 00:14:36,160
is that you're always
gonna have to put self-dot

314
00:14:36,160 --> 00:14:37,500
in front of these things,

315
00:14:37,500 --> 00:14:39,910
or you're gonna have
to deal with this error

316
00:14:39,910 --> 00:14:44,360
and do this, click on
it, and fix all the time.

317
00:14:44,360 --> 00:14:47,290
Again, that's something
you're only gonna have to do

318
00:14:47,290 --> 00:14:49,750
till the beta of this
public thing comes out,

319
00:14:49,750 --> 00:14:51,850
and hopefully, in a couple of months.

320
00:14:51,850 --> 00:14:53,890
But, at worst, a few months.

321
00:14:53,890 --> 00:14:56,380
And after that, then you
won't have to worry about this

322
00:14:56,380 --> 00:14:58,460
at all because not putting self here

323
00:14:58,460 --> 00:15:02,120
when self is a value type will
not generate this warning.

324
00:15:02,120 --> 00:15:04,063
That is the proposed fix.

325
00:15:05,330 --> 00:15:07,600
All right, that's enough of that aside.

326
00:15:07,600 --> 00:15:10,290
This all started because
we had this warning

327
00:15:10,290 --> 00:15:12,180
that told us we had to put escaping here

328
00:15:12,180 --> 00:15:16,288
because indeed, this function
does escape from this init

329
00:15:16,288 --> 00:15:18,530
because we put it in this var.

330
00:15:18,530 --> 00:15:19,853
Let's do our body.

331
00:15:21,500 --> 00:15:24,180
Our body's not "Hello, World!" obviously.

332
00:15:24,180 --> 00:15:25,630
Our body is actually quite simple.

333
00:15:25,630 --> 00:15:28,985
It's just a ForEach of all of our Items.

334
00:15:28,985 --> 00:15:31,993
And for each of our Items,
we are going to return

335
00:15:31,993 --> 00:15:35,070
a viewForItem of that Item.

336
00:15:35,070 --> 00:15:37,345
We're gonna call our function viewForItem.

337
00:15:37,345 --> 00:15:39,927
This is a var, that's a
function we're gonna call it.

338
00:15:39,927 --> 00:15:41,480
And of course, we wanna ForEach.

339
00:15:41,480 --> 00:15:44,520
It also has an escaping
function there for the View,

340
00:15:44,520 --> 00:15:46,663
so we have to say self-dot.

341
00:15:48,250 --> 00:15:52,050
This creates some errors for
us, so let's look at these.

342
00:15:52,050 --> 00:15:54,827
The first one says, "Cannot
convert value of type

343
00:15:54,827 --> 00:15:58,880
"Array of Item to expected
argument type 'Range of Int'."

344
00:15:58,880 --> 00:16:01,880
Oh no, we saw this exact argument problem

345
00:16:01,880 --> 00:16:05,230
when we were over here doing
ForEach the first time.

346
00:16:05,230 --> 00:16:06,770
We were passing this Array of Cards

347
00:16:06,770 --> 00:16:09,080
and we were like, oh, I
thought I could do that.

348
00:16:09,080 --> 00:16:11,670
We used to pass zero dot dot less than for

349
00:16:11,670 --> 00:16:14,350
and we went to Array,
and I had told you that

350
00:16:14,350 --> 00:16:16,310
this ForEach takes an Array.

351
00:16:16,310 --> 00:16:18,060
But we learned that it was an Array

352
00:16:18,060 --> 00:16:21,160
only of Identifiable things.

353
00:16:21,160 --> 00:16:23,580
So we have the same exact problem here.

354
00:16:23,580 --> 00:16:27,060
This ForEach of this
items has to be an Array

355
00:16:27,060 --> 00:16:29,290
of Identifiable things.

356
00:16:29,290 --> 00:16:33,730
Well, that's a problem for us
because Item is a don't-care.

357
00:16:33,730 --> 00:16:36,260
We have no idea what this thing is.

358
00:16:36,260 --> 00:16:39,590
But here is where we get
constrains and gains into the act.

359
00:16:39,590 --> 00:16:44,590
We're gonna say where
Item is Identifiable.

360
00:16:44,640 --> 00:16:47,360
So now we've created
a Grid that only works

361
00:16:47,360 --> 00:16:50,750
with this don't-care when that
don't-care is Identifiable.

362
00:16:50,750 --> 00:16:52,600
So this can still be anything.

363
00:16:52,600 --> 00:16:54,500
But it has to be Identifiable.

364
00:16:54,500 --> 00:16:56,970
This is what I was talking
about in the slides,

365
00:16:56,970 --> 00:16:59,270
a care-a-little-bit kind of thing.

366
00:16:59,270 --> 00:17:00,910
We care a little bit about Item.

367
00:17:00,910 --> 00:17:02,833
We care that it's Identifiable.

368
00:17:03,780 --> 00:17:05,905
So now we have a different error here.

369
00:17:05,905 --> 00:17:07,287
This ForEach error is saying,

370
00:17:07,287 --> 00:17:10,967
"Return type of property
'body'," this is our body,

371
00:17:10,967 --> 00:17:15,680
"requires that 'ItemView'
conform to 'View'."

372
00:17:15,680 --> 00:17:17,230
So what is ItemView?

373
00:17:17,230 --> 00:17:19,847
That's the return type of this function.

374
00:17:19,847 --> 00:17:21,670
And of course, that makes sense

375
00:17:21,670 --> 00:17:26,320
because ForEach can only
use Views to have Views

376
00:17:26,320 --> 00:17:27,153
for these items.

377
00:17:27,153 --> 00:17:29,040
This has to be a View.

378
00:17:29,040 --> 00:17:32,590
So, this viewForItem return
type here of ItemView,

379
00:17:32,590 --> 00:17:33,680
it has to be a View.

380
00:17:33,680 --> 00:17:34,930
And what type is it?

381
00:17:34,930 --> 00:17:37,240
It's a don't-care as well.

382
00:17:37,240 --> 00:17:38,550
We'll do the same thing here.

383
00:17:38,550 --> 00:17:41,523
ItemView has to be a View.

384
00:17:42,550 --> 00:17:45,550
You all seeing how we're
connecting generics,

385
00:17:45,550 --> 00:17:50,550
this is a very generic struct
right here, with protocols.

386
00:17:50,750 --> 00:17:55,420
These are protocols, and
we're using them to constrain

387
00:17:55,420 --> 00:17:57,623
these don't-cares to work.

388
00:18:00,140 --> 00:18:03,600
The next thing we have to do
here is we're a container.

389
00:18:03,600 --> 00:18:05,980
Grid contains all these Views.

390
00:18:05,980 --> 00:18:07,450
It puts them in rows and columns.

391
00:18:07,450 --> 00:18:08,770
It contains them.

392
00:18:08,770 --> 00:18:11,530
And we know the container's
job is to take the space

393
00:18:11,530 --> 00:18:14,260
that's offered to them and divide it up

394
00:18:14,260 --> 00:18:16,270
amongst the things inside.

395
00:18:16,270 --> 00:18:18,660
That means we need to
figure out how much space

396
00:18:18,660 --> 00:18:19,997
has been allocated to us.

397
00:18:19,997 --> 00:18:21,580
And we know how to do that.

398
00:18:21,580 --> 00:18:23,587
That's GeometryReader.

399
00:18:23,587 --> 00:18:24,883
Okay, GeometryReader.

400
00:18:26,050 --> 00:18:28,710
Geometry in is going to allow us

401
00:18:28,710 --> 00:18:31,350
to find out how much space
was given to the Grid,

402
00:18:31,350 --> 00:18:34,643
which we're then going to
hand off to these guys.

403
00:18:36,410 --> 00:18:37,593
So, put this in here.

404
00:18:38,620 --> 00:18:40,730
Now, as soon as put it in here,

405
00:18:40,730 --> 00:18:43,780
of course we're gonna get the
self-dot problem with items.

406
00:18:43,780 --> 00:18:46,830
I'm gonna use the same
solution I used last time,

407
00:18:46,830 --> 00:18:48,420
which is I'm gonna
create a func here called

408
00:18:48,420 --> 00:18:49,570
body(for size: CGSize).

409
00:18:51,330 --> 00:18:54,260
It's gonna return some View of course.

410
00:18:54,260 --> 00:18:58,907
I'm gonna put my code
for my body inside here.

411
00:18:58,907 --> 00:19:01,807
And here I'm just gonna do a
self.body(for: geometry.size).

412
00:19:04,200 --> 00:19:05,820
Again, this is just purely to make it

413
00:19:05,820 --> 00:19:08,950
so I don't have to do
self-dot inside this body.

414
00:19:08,950 --> 00:19:11,610
Just like GeometryReader is escaping

415
00:19:11,610 --> 00:19:13,420
and so we did this self.body,

416
00:19:13,420 --> 00:19:16,610
ForEach is also escaping,

417
00:19:16,610 --> 00:19:18,010
and so I'm gonna do the same thing here.

418
00:19:18,010 --> 00:19:19,560
self.body(for item, in size).

419
00:19:22,374 --> 00:19:23,820
I'm gonna move this to

420
00:19:25,540 --> 00:19:30,350
another little func
body(for item, in size)

421
00:19:30,350 --> 00:19:31,463
turn some View.

422
00:19:33,050 --> 00:19:35,960
And now I don't need the self-dot here.

423
00:19:35,960 --> 00:19:37,003
Just return that.

424
00:19:38,780 --> 00:19:41,660
So, we've arranged our code nicely here.

425
00:19:41,660 --> 00:19:43,760
All we have left to do, believe it or not,

426
00:19:43,760 --> 00:19:48,070
is to actually offer these
Views some of our space,

427
00:19:48,070 --> 00:19:49,440
and then to position them.

428
00:19:49,440 --> 00:19:50,530
That's what containers do.

429
00:19:50,530 --> 00:19:53,178
Offer space, and they position.

430
00:19:53,178 --> 00:19:54,970
To do this, we need to do some math

431
00:19:54,970 --> 00:19:56,550
because we've been offered this space,

432
00:19:56,550 --> 00:20:00,250
and now we need to divide
it up by however many items

433
00:19:56,550 --> 00:20:00,250
and now we need to divide
it up by however many items

434
00:20:00,250 --> 00:20:01,840
we have here.

435
00:20:01,840 --> 00:20:05,150
And to do that math, I
actually wrote some code

436
00:20:05,150 --> 00:20:07,973
that I gave you, and we're gonna use here.

437
00:20:07,973 --> 00:20:09,350
Let's drag it in.

438
00:20:09,350 --> 00:20:11,410
By the way, when you drag code in,

439
00:20:11,410 --> 00:20:13,660
be sure to do this Copy items if needed.

440
00:20:13,660 --> 00:20:15,370
That's almost always what you want.

441
00:20:15,370 --> 00:20:18,520
You want a copy of that
code to put in your project.

442
00:20:18,520 --> 00:20:21,250
Otherwise, it's going to be
referring to your desktop

443
00:20:21,250 --> 00:20:22,850
or wherever you dragged it from.

444
00:20:23,830 --> 00:20:25,430
All right, so we finished that.

445
00:20:25,430 --> 00:20:27,310
So here let's take a look at this little.

446
00:20:27,310 --> 00:20:28,860
This is the math, this GridLayout.

447
00:20:28,860 --> 00:20:30,440
The math, it does this calculation,

448
00:20:30,440 --> 00:20:32,170
so let's take a look.

449
00:20:32,170 --> 00:20:37,170
Now I've collapsed the init
and this two var and func here

450
00:20:38,520 --> 00:20:41,680
'cause we're not gonna look at
the implementation of these.

451
00:20:41,680 --> 00:20:44,530
I do encourage you, after this lecture,

452
00:20:44,530 --> 00:20:47,190
to go and take a look
at the implementation,

453
00:20:47,190 --> 00:20:48,700
and see if you can figure it out.

454
00:20:48,700 --> 00:20:51,550
You'll need the rest of this
lecture to have the knowledge

455
00:20:51,550 --> 00:20:54,010
to be able to really
understand what this is doing,

456
00:20:54,010 --> 00:20:56,380
but it's a good exercise to
try and understand this thing.

457
00:20:56,380 --> 00:20:57,710
It's only about 10 lines of code,

458
00:20:57,710 --> 00:21:00,060
so you shouldn't have
too much trouble with it.

459
00:21:00,910 --> 00:21:02,760
But here's what a GridLayout does.

460
00:21:02,760 --> 00:21:07,760
Its initializer takes a
number of items and a size,

461
00:21:08,090 --> 00:21:10,510
and it divides that
size up by those items.

462
00:21:10,510 --> 00:21:12,650
It does exactly what Grid wants.

463
00:21:12,650 --> 00:21:17,310
Now, it also even lets you
specify a desired aspect ratio.

464
00:21:17,310 --> 00:21:20,200
It can't guarantee that, but
it can try and get close to it.

465
00:21:20,200 --> 00:21:23,350
And that's it, we just create
a GridLayout that does that.

466
00:21:23,350 --> 00:21:25,530
Then we have a var here
that will tell us the size

467
00:21:25,530 --> 00:21:27,180
of the items that are all the same size,

468
00:21:27,180 --> 00:21:28,680
so this would be the size.

469
00:21:28,680 --> 00:21:31,840
And then also the location
of each item as a point.

470
00:21:31,840 --> 00:21:34,030
This is the center of each item,

471
00:21:34,030 --> 00:21:36,120
which again, exactly what Grid wants.

472
00:21:36,120 --> 00:21:38,600
So GridLayout was definitely
made with Grid in mind,

473
00:21:38,600 --> 00:21:43,060
but it's pretty much a
generic divider-up of CGSize

474
00:21:43,910 --> 00:21:46,710
by a certain number of items.

475
00:21:46,710 --> 00:21:48,450
So, let's create this GridLayout

476
00:21:48,450 --> 00:21:50,280
by calling this initializer right here.

477
00:21:50,280 --> 00:21:53,430
I'm gonna do it up in my GeometryReader.

478
00:21:53,430 --> 00:21:56,930
In fact, I'm gonna change
this passing of the size

479
00:21:56,930 --> 00:21:59,890
to instead pass a GridLayout.

480
00:21:59,890 --> 00:22:03,000
And the itemCount is
just the number of Items

481
00:22:03,000 --> 00:22:03,860
that we have.

482
00:22:03,860 --> 00:22:07,180
This is our items Array
right here, its count.

483
00:22:07,180 --> 00:22:10,620
And I'm gonna skip the
desired aspect ratio thing.

484
00:22:10,620 --> 00:22:13,260
We'll just use whatever the default is.

485
00:22:13,260 --> 00:22:15,410
Hopefully in your reading,
you saw that you can have

486
00:22:15,410 --> 00:22:19,040
default arguments for functions
and GridLayout uses that.

487
00:22:19,040 --> 00:22:20,350
But you do have to have the size,

488
00:22:20,350 --> 00:22:24,057
and this is of course going
to be in geometry.size.

489
00:22:24,057 --> 00:22:26,310
And we're still inside
of GeometryReader here

490
00:22:26,310 --> 00:22:29,130
so this items is gonna
have to be self.items.

491
00:22:29,130 --> 00:22:31,103
It's an instance variable there.

492
00:22:32,220 --> 00:22:33,520
So, I've changed this body(for).

493
00:22:33,520 --> 00:22:37,963
Instead of body for size, it's
now our body for the layout.

494
00:22:39,450 --> 00:22:40,773
GridLayout here.

495
00:22:42,080 --> 00:22:44,680
And same thing, I'm gonna
have to pass this on through,

496
00:22:44,680 --> 00:22:46,830
so this is now body(for:
item, in: layout).

497
00:22:49,383 --> 00:22:52,590
So that makes this a layout as well,

498
00:22:52,590 --> 00:22:54,453
passing it on down along the line.

499
00:22:56,140 --> 00:22:58,460
And now we're in here,
we've got this layout,

500
00:22:58,460 --> 00:23:01,970
and we've laid it out with the
number of Items in our size.

501
00:23:01,970 --> 00:23:06,660
So we can easily do things like
offer space to these Views,

502
00:23:06,660 --> 00:23:08,470
which we do with frame.

503
00:23:08,470 --> 00:23:10,270
So we're gonna say frame's width

504
00:23:10,270 --> 00:23:13,600
is the layout's itemSize.width,

505
00:23:13,600 --> 00:23:18,133
and the frame's height is
the layout.itemSize.height.

506
00:23:18,133 --> 00:23:21,490
We're gonna offer the same little subspace

507
00:23:21,490 --> 00:23:25,330
of our space to each of the items.

508
00:23:25,330 --> 00:23:28,680
That's what itemSize in GridLayout does.

509
00:23:28,680 --> 00:23:31,570
Again, GridLayout was
created with this many items

510
00:23:31,570 --> 00:23:33,440
in the size that was offered to us.

511
00:23:33,440 --> 00:23:35,510
That's how we divided it up.

512
00:23:35,510 --> 00:23:37,860
And then we have to position the View,

513
00:23:37,860 --> 00:23:39,410
so we do that with position.

514
00:23:39,410 --> 00:23:41,380
That's the function we do it with.

515
00:23:41,380 --> 00:23:45,570
And we're gonna position
it at the layout's location

516
00:23:45,570 --> 00:23:48,000
ofItemAt index.

517
00:23:48,000 --> 00:23:51,630
So this is indexed, just like
we had with our Cards in fact.

518
00:23:51,630 --> 00:23:55,230
So we have to find the index of this Item

519
00:23:55,230 --> 00:23:57,173
in our Item Array.

520
00:23:58,040 --> 00:23:59,460
No problem, we kinda know how to do that.

521
00:23:59,460 --> 00:24:01,850
We'll say let index equal,

522
00:24:01,850 --> 00:24:03,690
mm, I know how to do this.

523
00:24:03,690 --> 00:24:08,620
I'm gonna create a function
on my self index of this Item.

524
00:24:09,460 --> 00:24:12,777
And I'm gonna go down here
and say func index (of item).

525
00:24:14,541 --> 00:24:18,320
And it's gonna return an
Int, an index into the Array.

526
00:24:18,320 --> 00:24:20,570
We'll return zero here first,

527
00:24:20,570 --> 00:24:23,340
and then we'll fill it out in a second.

528
00:24:23,340 --> 00:24:25,780
Now, this is gonna confuse
Swift again a little bit

529
00:24:25,780 --> 00:24:28,080
'cause you've got index,
this local variable,

530
00:24:28,080 --> 00:24:30,640
and then index, this function.

531
00:24:30,640 --> 00:24:34,260
So, we can fix that
again, same way, self-dot.

532
00:24:34,260 --> 00:24:37,710
Now it knows this index is the function,

533
00:24:37,710 --> 00:24:40,890
and this index is a local
variable we're creating.

534
00:24:40,890 --> 00:24:43,000
So, we do actually use self-dot.

535
00:24:43,000 --> 00:24:46,870
Even once they make that
change with the value type

536
00:24:46,870 --> 00:24:49,350
self-dots not being flagged like that,

537
00:24:49,350 --> 00:24:51,600
we still sometimes wanna use self-dot

538
00:24:51,600 --> 00:24:56,410
to define the difference between
something that's a property

539
00:24:56,410 --> 00:24:58,480
or a function versus a local variable

540
00:24:58,480 --> 00:25:00,173
or a parameter to the function.

541
00:25:01,660 --> 00:25:04,410
All right, in index here, how
are we gonna find this Item

542
00:25:04,410 --> 00:25:05,243
in the Array?

543
00:25:05,243 --> 00:25:06,270
Well, guess what?

544
00:25:06,270 --> 00:25:09,000
These Items are Identifiable.

545
00:25:09,000 --> 00:25:10,387
And probably some of you are like,

546
00:25:10,387 --> 00:25:12,530
"Hmm, this seems awfully familiar."

547
00:25:12,530 --> 00:25:15,160
Well yeah, we're gonna do for index

548
00:25:15,160 --> 00:25:19,470
in zero dot dot less than items.count

549
00:25:19,470 --> 00:25:20,540
that we have.

550
00:25:20,540 --> 00:25:24,590
And if the items at that [index].id

551
00:25:24,590 --> 00:25:27,590
equals this Item's id,

552
00:25:27,590 --> 00:25:30,985
then we're going to return that index.

553
00:25:30,985 --> 00:25:33,120
Otherwise we're gonna return zero,

554
00:25:33,120 --> 00:25:38,120
which is just as bogus as it
was the last time we did this.

555
00:25:38,320 --> 00:25:41,900
Okay now, this function
is kinda double bogus.

556
00:25:41,900 --> 00:25:44,850
It's bogus in that we're
still doing this return zero.

557
00:25:44,850 --> 00:25:47,060
In other words, if we can't find the item

558
00:25:47,060 --> 00:25:50,070
in our items, well, we'll
just return the first item,

559
00:25:50,070 --> 00:25:51,387
index zero right there.

560
00:25:51,387 --> 00:25:52,800
That's bogus.

561
00:25:52,800 --> 00:25:56,220
But what's also bogus is that
this code is exactly the same,

562
00:25:56,220 --> 00:26:01,220
yes, as this code over here in our Model.

563
00:26:01,520 --> 00:26:03,770
So, man, you'd never wanna write

564
00:26:03,770 --> 00:26:06,160
the exact same code like this twice.

565
00:26:06,160 --> 00:26:09,400
That is just terrible programming.

566
00:26:09,400 --> 00:26:11,850
Well, we're gonna fix that in a minute.

567
00:26:11,850 --> 00:26:13,820
But first let's just
see if our Grid works.

568
00:26:13,820 --> 00:26:16,200
Believe it or not, this is
all we need for our Grid.

569
00:26:16,200 --> 00:26:17,033
There's nothing else.

570
00:26:17,033 --> 00:26:19,390
So we get the space that's offered to us.

571
00:26:19,390 --> 00:26:21,640
We use this GridLayout to divide it up,

572
00:26:21,640 --> 00:26:25,800
and then we offer it to our
little sub-Views in there,

573
00:26:25,800 --> 00:26:28,370
and then we position
them at those locations

574
00:26:28,370 --> 00:26:29,871
in the GridLayout.

575
00:26:29,871 --> 00:26:33,000
That's all that's required,
so let's take a run here.

576
00:26:33,000 --> 00:26:34,023
See if it worked.

577
00:26:35,478 --> 00:26:36,450
Ah, and it did.

578
00:26:36,450 --> 00:26:39,410
Look at that, there's our six
cards not in a row anymore.

579
00:26:39,410 --> 00:26:43,190
Let's go landscape, and
look, it resized the cards

580
00:26:43,190 --> 00:26:44,600
to fit the space better.

581
00:26:44,600 --> 00:26:46,700
Now, I would like a little bit of padding

582
00:26:46,700 --> 00:26:50,000
between the cards, but
that's a matter back here

583
00:26:50,000 --> 00:26:52,040
of when we create our CardViews,

584
00:26:52,040 --> 00:26:55,460
we can just put a little padding on there.

585
00:26:55,460 --> 00:26:57,990
If we put some padding
around these CardViews

586
00:26:57,990 --> 00:27:00,790
inside of our Grid,
huh, we get the padding.

587
00:27:00,790 --> 00:27:01,900
Huh, works great.

588
00:27:01,900 --> 00:27:03,670
Maybe we don't want quite so much padding.

589
00:27:03,670 --> 00:27:06,840
Maybe we just want padding of five.

590
00:27:06,840 --> 00:27:07,743
Run that.

591
00:27:10,179 --> 00:27:11,829
Huh, that looks pretty darn good.

592
00:27:12,970 --> 00:27:15,820
Okay well, now that our Grid is working,

593
00:27:15,820 --> 00:27:19,110
let's go and fix the bogus
code that we have right here,

594
00:27:19,110 --> 00:27:21,510
which is this index of item.

595
00:27:21,510 --> 00:27:23,460
And it's bogus 'cause
this totally replicates

596
00:27:23,460 --> 00:27:24,810
this other thing.

597
00:27:24,810 --> 00:27:26,933
Let's think a little bit
about what's going on here.

598
00:27:26,933 --> 00:27:30,810
What're we actually asking,
in both cases, to happen?

599
00:27:30,810 --> 00:27:34,660
We have an Array of things
that are Identifiable,

600
00:27:34,660 --> 00:27:38,010
and we have one of
those things, hopefully.

601
00:27:38,010 --> 00:27:40,500
We know it's Identifiable as well.

602
00:27:40,500 --> 00:27:42,870
And we want to look and
see if we can find it.

603
00:27:42,870 --> 00:27:46,823
So, that sounds to be
more like an Array thing.

604
00:27:48,630 --> 00:27:51,460
Let's add a function to
Array that does this.

605
00:27:51,460 --> 00:27:53,123
Extension Array.

606
00:27:54,190 --> 00:27:59,190
But only to Arrays where
the elements in the Array

607
00:27:59,730 --> 00:28:01,390
are Identifiable.

608
00:28:01,390 --> 00:28:03,873
So there it is again,
constrains and gains.

609
00:28:04,890 --> 00:28:07,930
This extension only is
going to add this function

610
00:28:07,930 --> 00:28:10,483
that we wanna add to those kind of Arrays.

611
00:28:11,380 --> 00:28:12,700
And so, it's the same function.

612
00:28:12,700 --> 00:28:14,250
In fact, I'm just gonna copy and paste

613
00:28:14,250 --> 00:28:16,820
and we'll modify this,
or even cut and paste.

614
00:28:16,820 --> 00:28:18,073
Cut that outta there.

615
00:28:19,180 --> 00:28:20,370
Paste this in here.

616
00:28:20,370 --> 00:28:21,740
It's not quite the same in here

617
00:28:21,740 --> 00:28:23,883
because here we were looking at items.

618
00:28:24,780 --> 00:28:27,420
Obviously this is an Array function,

619
00:28:27,420 --> 00:28:29,790
so now items is self.

620
00:28:29,790 --> 00:28:30,910
And same thing here.

621
00:28:30,910 --> 00:28:32,320
It's not the items' count.

622
00:28:32,320 --> 00:28:34,163
It's self's count.

623
00:28:35,312 --> 00:28:39,470
And the type of this item,
index of item, it's not Item.

624
00:28:39,470 --> 00:28:42,540
It's Element 'cause
that's what we're looking

625
00:28:42,540 --> 00:28:43,373
at an Array of.

626
00:28:43,373 --> 00:28:46,170
We have an Array whose
elements are all Identifiable

627
00:28:46,170 --> 00:28:48,630
and what we're saying
here is get the index

628
00:28:48,630 --> 00:28:52,010
of one of the elements of
this Array that's Identifiable

629
00:28:52,010 --> 00:28:52,973
by looking it up.

630
00:28:54,270 --> 00:28:57,410
Now, this is correct and
this does the right thing,

631
00:28:57,410 --> 00:29:01,330
but I actually don't like the
naming that I've chosen here.

632
00:29:01,330 --> 00:29:03,980
One thing about this is
it doesn't actually return

633
00:29:03,980 --> 00:29:06,310
the index of this item.

634
00:29:06,310 --> 00:29:10,120
It returns the first one that it finds.

635
00:29:10,120 --> 00:29:12,870
Going through the Array from zero on up,

636
00:29:12,870 --> 00:29:15,280
and when it finds one, it returns it.

637
00:29:15,280 --> 00:29:19,743
So this is really the
first index of this item.

638
00:29:20,780 --> 00:29:22,860
I also don't like the word item.

639
00:29:22,860 --> 00:29:25,230
Item makes sense up here in Grid

640
00:29:25,230 --> 00:29:26,260
because we have Item.

641
00:29:26,260 --> 00:29:28,140
The word "item" is all over the place.

642
00:29:28,140 --> 00:29:31,690
But really in Array, Item is not a thing.

643
00:29:31,690 --> 00:29:34,270
There's Element, but there's no Item.

644
00:29:34,270 --> 00:29:37,470
And really what this is is the first index

645
00:29:37,470 --> 00:29:40,220
matching that Element.

646
00:29:40,220 --> 00:29:44,370
So I'm gonna use firstIndex
matching as my name.

647
00:29:44,370 --> 00:29:47,100
This feels more like an Array function,

648
00:29:47,100 --> 00:29:49,103
firstIndex matching this Element.

649
00:29:50,100 --> 00:29:52,080
So, how do we use that up here?

650
00:29:52,080 --> 00:29:53,730
Instead of self.index of,

651
00:29:53,730 --> 00:29:57,290
we're just gonna say items, the Array,

652
00:29:57,290 --> 00:30:02,290
dot firstIndex matching the Item.

653
00:29:57,290 --> 00:30:02,290
dot firstIndex matching the Item.

654
00:30:03,720 --> 00:30:06,150
So we're asking the Array to do this now,

655
00:30:06,150 --> 00:30:09,290
to go find the first
index matching this item.

656
00:30:09,290 --> 00:30:11,610
And we can do exactly
the same thing over here.

657
00:30:11,610 --> 00:30:14,260
We no longer even need this function.

658
00:30:14,260 --> 00:30:17,740
We get it outta here because
we know that our Cards Array

659
00:30:17,740 --> 00:30:22,740
right here can do firstIndex
matching the Card.

660
00:30:26,000 --> 00:30:27,700
So we are reusing this code.

661
00:30:27,700 --> 00:30:31,030
And look how small our Model has become.

662
00:30:31,030 --> 00:30:33,307
It's tiny, it's hardly any code in here.

663
00:30:33,307 --> 00:30:35,670
And some of that is because
we've just made Array

664
00:30:35,670 --> 00:30:38,140
more powerful to look this thing up.

665
00:30:38,140 --> 00:30:39,380
Same thing with Grid.

666
00:30:39,380 --> 00:30:42,180
Grid's very small amount of code

667
00:30:42,180 --> 00:30:44,580
because we're leveraging this Array.

668
00:30:44,580 --> 00:30:47,320
Now, this Array thing has
nothing to do with Grid,

669
00:30:47,320 --> 00:30:50,040
so it does not belong here in Grid.swift.

670
00:30:50,040 --> 00:30:53,410
So I'm going to cut it out Grid.swift.

671
00:30:53,410 --> 00:30:56,803
And I'm gonna put it in its own file.

672
00:30:58,150 --> 00:30:59,550
It's not a SwiftUI View.

673
00:30:59,550 --> 00:31:01,360
It's just a regular Swift file.

674
00:31:01,360 --> 00:31:04,140
Now when we do extensions like this,

675
00:31:04,140 --> 00:31:08,010
we usually call the file Array,
the thing we're extending,

676
00:31:08,010 --> 00:31:10,500
plus some sort of descriptor

677
00:31:10,500 --> 00:31:12,210
of what kind of thing this is.

678
00:31:12,210 --> 00:31:16,080
And so, this is kind of Identifiable,

679
00:31:16,080 --> 00:31:17,963
Array+Identifiable.

680
00:31:19,220 --> 00:31:20,540
So let's go in here.

681
00:31:20,540 --> 00:31:21,610
There it is.

682
00:31:21,610 --> 00:31:22,730
Paste it in.

683
00:31:22,730 --> 00:31:26,720
Notice that this is import Foundation,

684
00:31:26,720 --> 00:31:28,200
which is perfectly fine.

685
00:31:28,200 --> 00:31:29,033
This is not a UI thing.

686
00:31:29,033 --> 00:31:32,510
This is purely Arrays and Identifiables.

687
00:31:32,510 --> 00:31:34,193
None of those are UI things.

688
00:31:35,500 --> 00:31:37,360
So we go back to Grid.

689
00:31:37,360 --> 00:31:40,437
Do build here so it notices
this all this stuff.

690
00:31:40,437 --> 00:31:44,830
And make sure that our Model
also is working, and it is.

691
00:31:44,830 --> 00:31:47,480
No errors, in fact, no
errors in our whole program.

692
00:31:47,480 --> 00:31:50,863
Let's run, make sure that our
Array is doing it, and it is.

693
00:31:53,770 --> 00:31:58,020
All right, so once again, we
are using this whole concept

694
00:31:58,020 --> 00:31:59,280
of constrains and gains.

695
00:31:59,280 --> 00:32:04,060
Here we are constraining the
don't-care type of the Array

696
00:32:04,060 --> 00:32:05,500
so that they're Identifiable,

697
00:32:05,500 --> 00:32:07,970
and that allows us to gain this function.

698
00:32:07,970 --> 00:32:11,640
For all Arrays where elements
are identified they get this.

699
00:32:11,640 --> 00:32:15,060
No Arrays that don't have
Identifiable elements,

700
00:32:15,060 --> 00:32:17,223
they don't even see this function.

701
00:32:17,223 --> 00:32:19,310
Wouldn't even escape complete in Xcode.

702
00:32:19,310 --> 00:32:20,313
It's not even there.

703
00:32:21,740 --> 00:32:22,650
And we're doing the same thing

704
00:32:22,650 --> 00:32:24,280
with constrains and gains here

705
00:32:24,280 --> 00:32:27,100
to make it so that our
Grid is always a Grid

706
00:32:27,100 --> 00:32:31,670
of Identifiable things, matching
two things that are Views.

707
00:32:31,670 --> 00:32:33,100
That is it for this demo.

708
00:32:33,100 --> 00:32:35,860
So I'm gonna go back to the slides,

709
00:32:35,860 --> 00:32:37,930
and we're gonna fix this.

710
00:32:37,930 --> 00:32:40,700
And we need the type in Swift
called Optional to do this,

711
00:32:40,700 --> 00:32:43,540
a very, very important
type, which is an enum.

712
00:32:43,540 --> 00:32:46,060
So let's do a quick
review of what enums are,

713
00:32:46,060 --> 00:32:47,360
and then we'll talk about

714
00:32:47,360 --> 00:32:49,785
this very important type, Optional.

715
00:32:49,785 --> 00:32:53,250
Enums are just another
type like struct or class,

716
00:32:53,250 --> 00:32:57,320
but in the case of an enum,
the value is discrete.

717
00:32:57,320 --> 00:33:01,120
Good example here, FastFoodMenuItem
is either a hamburger

718
00:33:01,120 --> 00:33:03,350
or it's fries or it's a
drink or it's a cookie.

719
00:33:03,350 --> 00:33:04,260
It can't be anything else.

720
00:33:04,260 --> 00:33:05,900
Gotta be one of those four things.

721
00:33:05,900 --> 00:33:07,480
That's the only things on the menu,

722
00:33:07,480 --> 00:33:10,683
and it has to be one and
only one of those things.

723
00:33:11,900 --> 00:33:15,350
Enum, like a struct, is a value type.

724
00:33:15,350 --> 00:33:17,290
Gets copied as you pass it around.

725
00:33:17,290 --> 00:33:18,400
It does not live in the heap.

726
00:33:18,400 --> 00:33:19,970
There's no pointers to it.

727
00:33:19,970 --> 00:33:21,253
It's a value type.

728
00:33:22,410 --> 00:33:25,690
Now what's cool about enums in Swift,

729
00:33:25,690 --> 00:33:27,840
unlike most other languages,

730
00:33:27,840 --> 00:33:30,240
is that each of the discrete values

731
00:33:30,240 --> 00:33:32,267
can have some associated data with it

732
00:33:32,267 --> 00:33:35,840
that's very specific to that
particular discrete value.

733
00:33:35,840 --> 00:33:39,570
For example, we have hamburger here.

734
00:33:39,570 --> 00:33:41,670
And if the FastFoodMenuItem's a hamburger,

735
00:33:41,670 --> 00:33:43,380
we're gonna say how many patties?

736
00:33:43,380 --> 00:33:46,360
Is this a double or a triple or single?

737
00:33:46,360 --> 00:33:49,910
If it's fries, is this a
large fry, small fries?

738
00:33:49,910 --> 00:33:54,110
If it's a drink, you'll see
there, you have this drink,

739
00:33:54,110 --> 00:33:57,080
which is Coke or Dr. Pepper or whatever.

740
00:33:57,080 --> 00:33:59,100
Notice that that String
is unnamed right there,

741
00:33:59,100 --> 00:34:01,680
so these things don't have to have names.

742
00:34:01,680 --> 00:34:04,980
This yellow syntax that you're seeing here

743
00:34:04,980 --> 00:34:07,990
probably, hopefully, looks
familiar from your reading.

744
00:34:07,990 --> 00:34:09,703
This is just a tuple.

745
00:34:11,060 --> 00:34:15,190
So all the rules of tuples
which allow you to have labels

746
00:34:15,190 --> 00:34:18,600
or not labels, and have as
many items as you want here,

747
00:34:18,600 --> 00:34:20,440
all perfectly valid

748
00:34:20,440 --> 00:34:23,023
as the associated data values right here.

749
00:34:25,170 --> 00:34:28,040
So how do you set the value of an enum?

750
00:34:28,040 --> 00:34:29,550
It's very simple.

751
00:34:29,550 --> 00:34:31,970
You just say the name of the enum,

752
00:34:31,970 --> 00:34:35,750
like FastFoodMenuItem,
dot, the discrete value,

753
00:34:35,750 --> 00:34:38,830
hamburger or cookie, like here.

754
00:34:38,830 --> 00:34:41,890
Now of course, in the case
where there's associated data,

755
00:34:41,890 --> 00:34:44,630
you have to provide that associated data.

756
00:34:44,630 --> 00:34:47,566
Hamburger(patties: 2) in this case.

757
00:34:47,566 --> 00:34:51,233
There's no way for it
to create a hamburger

758
00:34:51,233 --> 00:34:53,220
if it doesn't know how
many patties there are.

759
00:34:54,160 --> 00:34:56,230
Now Swift can do type inference here

760
00:34:56,230 --> 00:34:58,750
so that you don't have
to type FastFoodMenuItem

761
00:34:58,750 --> 00:35:01,130
on both sides of this equals.

762
00:35:01,130 --> 00:35:02,670
But you have to be a little bit careful.

763
00:35:02,670 --> 00:35:04,770
You have to put it on
one side of the equals

764
00:35:04,770 --> 00:35:06,560
because in the case if you just say

765
00:35:06,560 --> 00:35:09,030
var yetAnotherItem equals cookie,

766
00:35:09,030 --> 00:35:10,950
Swift does not have enough information

767
00:35:10,950 --> 00:35:14,030
to infer that we're talking
about fast food menu items here.

768
00:35:14,030 --> 00:35:16,355
It could be anything that has a cookie.

769
00:35:16,355 --> 00:35:20,210
So you have to, somewhere,
FastFoodMenuItem has to appear

770
00:35:20,210 --> 00:35:22,123
so that Swift can infer.

771
00:35:23,660 --> 00:35:25,760
How do we check the value?

772
00:35:25,760 --> 00:35:27,830
You might think it would be like an if.

773
00:35:27,830 --> 00:35:30,943
You know, if this menu
item equals a hamburger,

774
00:35:30,943 --> 00:35:32,250
then do something.

775
00:35:32,250 --> 00:35:33,710
But we don't use if with enum.

776
00:35:33,710 --> 00:35:36,510
We use this expression switch.

777
00:35:36,510 --> 00:35:38,600
Now switch exists in other languages.

778
00:35:38,600 --> 00:35:40,230
It's very powerful in Swift,

779
00:35:40,230 --> 00:35:43,410
not only for checking enums
as you're going to see,

780
00:35:43,410 --> 00:35:45,170
but it has regular expression matching

781
00:35:45,170 --> 00:35:46,003
and all kinds of stuff.

782
00:35:46,003 --> 00:35:48,310
Again, you read about that hopefully

783
00:35:48,310 --> 00:35:49,683
in your reading assignment.

784
00:35:50,960 --> 00:35:53,670
So if I wanna check
what value menuItem has,

785
00:35:53,670 --> 00:35:55,100
I'm gonna switch on menuItem,

786
00:35:55,100 --> 00:35:57,340
and then have a case statement

787
00:35:57,340 --> 00:35:59,547
for every single possible menuItem.

788
00:35:59,547 --> 00:36:02,860
And it has to be every single one.

789
00:36:02,860 --> 00:36:05,350
Now, I'm not paying any attention here

790
00:36:05,350 --> 00:36:08,850
to the associated data, and I'm
allowed to ignore that here.

791
00:36:08,850 --> 00:36:12,320
I can still have case
FastFoodMenuItem.hamburger

792
00:36:12,320 --> 00:36:13,950
print the word burger.

793
00:36:13,950 --> 00:36:15,650
I can't say how many patties it is

794
00:36:15,650 --> 00:36:17,720
'cause I haven't looked
at the associated data.

795
00:36:17,720 --> 00:36:19,080
I'm gonna show you that in a second.

796
00:36:19,080 --> 00:36:21,773
But I can still print
burger if I want here.

797
00:36:23,350 --> 00:36:25,430
Swift can infer, of course,

798
00:36:25,430 --> 00:36:27,090
that these are all fast food menu items,

799
00:36:27,090 --> 00:36:28,050
so you don't have to say

800
00:36:28,050 --> 00:36:31,390
case FastFoodMenuItem.hamburger
every time.

801
00:36:31,390 --> 00:36:32,970
You can just switch on the menuItem.

802
00:36:32,970 --> 00:36:35,190
Use .hamburger, .fries, .drink.

803
00:36:35,190 --> 00:36:38,473
It knows menuItem is a
FastFoodMenuItem in this case.

804
00:36:40,260 --> 00:36:42,430
By the way, switch requires you to cover

805
00:36:42,430 --> 00:36:44,110
every single possible case.

806
00:36:44,110 --> 00:36:46,310
So you might have a case, like hamburger,

807
00:36:46,310 --> 00:36:47,180
that you don't care about.

808
00:36:47,180 --> 00:36:49,450
You don't wanna print out hamburger.

809
00:36:49,450 --> 00:36:51,380
In that case, you can just say break.

810
00:36:51,380 --> 00:36:53,980
So, break breaks out of the switch,

811
00:36:53,980 --> 00:36:57,120
and saying case .hamburger
break means it will do nothing

812
00:36:57,120 --> 00:37:00,000
if the menu item is a hamburger.

813
00:37:00,000 --> 00:37:03,310
Similarly, if you really only
care about a couple of cases

814
00:37:03,310 --> 00:37:06,120
and all the rest, you could
just do some default behavior,

815
00:37:06,120 --> 00:37:08,790
you can use the special keyword default.

816
00:37:08,790 --> 00:37:12,010
So a default will happen
if you didn't list

817
00:37:12,010 --> 00:37:13,890
a specific case for something.

818
00:37:13,890 --> 00:37:15,050
But you have to do one or the other.

819
00:37:15,050 --> 00:37:17,210
Either you have to have all the cases

820
00:37:17,210 --> 00:37:19,470
and the ones you don't care
about you break out of,

821
00:37:19,470 --> 00:37:21,090
or you can only have some of the cases,

822
00:37:21,090 --> 00:37:22,863
but then you have to
provide this default case.

823
00:37:22,863 --> 00:37:24,870
It's required in switch in general.

824
00:37:24,870 --> 00:37:27,070
Not just for enums, but always in Swift,

825
00:37:27,070 --> 00:37:29,850
switches require complete
and utter coverage

826
00:37:29,850 --> 00:37:31,273
of all possibilities.

827
00:37:33,350 --> 00:37:35,150
What about that associated data?

828
00:37:35,150 --> 00:37:37,280
Well we can do that in switch as well.

829
00:37:37,280 --> 00:37:40,100
We just add the stuff
you're seeing in yellow here

830
00:37:40,100 --> 00:37:41,820
where when we say case .hamburger,

831
00:37:41,820 --> 00:37:44,570
we say parentheses, let pattyCount.

832
00:37:44,570 --> 00:37:47,380
And that is going to grab the
associated data with hamburger

833
00:37:47,380 --> 00:37:51,490
and assign it to this little
very local variable pattyCount

834
00:37:51,490 --> 00:37:54,070
that's only going to be valid
for this print statement

835
00:37:54,070 --> 00:37:57,130
or whatever that's happening
after this hamburger.

836
00:37:57,130 --> 00:37:59,060
Same thing with the fries.

837
00:37:59,060 --> 00:38:01,350
And for example, the drink is interesting.

838
00:38:01,350 --> 00:38:04,640
So the drink is going to grab
the brand and the ounces.

839
00:38:04,640 --> 00:38:08,320
Notice that ounces used to have
a label when I declared it,

840
00:38:08,320 --> 00:38:11,016
but I didn't do that here and that's okay

841
00:38:11,016 --> 00:38:11,849
because this is tuples.

842
00:38:11,849 --> 00:38:15,560
Tuples you can use the labels
if you want on both sides,

843
00:38:15,560 --> 00:38:16,880
declaring and using it.

844
00:38:16,880 --> 00:38:20,060
And so, this is the exact same
thing that's going on here

845
00:38:20,060 --> 00:38:22,850
where the associated
value, you can grab it

846
00:38:22,850 --> 00:38:24,583
however you want to grab it.

847
00:38:26,500 --> 00:38:28,600
All right, let's see.

848
00:38:28,600 --> 00:38:32,730
Methods, yes, you can
have methods on enums.

849
00:38:32,730 --> 00:38:36,000
It's pretty much unlimited,
whatever you wanna do.

850
00:38:36,000 --> 00:38:39,350
And properties, you can
have computed properties,

851
00:38:39,350 --> 00:38:41,910
but you can't have any stored properties.

852
00:38:41,910 --> 00:38:44,720
All the storage that goes with an enum

853
00:38:44,720 --> 00:38:47,260
is only in these associated values,

854
00:38:47,260 --> 00:38:50,200
which kinda makes sense 'cause
an enum is a discrete thing.

855
00:38:50,200 --> 00:38:52,900
It really wouldn't make
sense to have other data

856
00:38:52,900 --> 00:38:54,110
that applies to all of them.

857
00:38:54,110 --> 00:38:55,410
That wouldn't be discrete.

858
00:38:56,402 --> 00:38:58,993
So, this is why you have to do this.

859
00:39:02,250 --> 00:39:03,170
Switching on self.

860
00:39:03,170 --> 00:39:07,190
All right so, if you have
a function in your enum,

861
00:39:07,190 --> 00:39:09,870
and it's supposed to
essentially tell you something

862
00:39:09,870 --> 00:39:12,210
about the enum, which is really common

863
00:39:12,210 --> 00:39:13,520
to have these kind of functions.

864
00:39:13,520 --> 00:39:17,340
Here I have this function
isIncludedInSpecialOrder number,

865
00:39:17,340 --> 00:39:20,610
which is gonna say whether
this FastFoodMenuItem

866
00:39:20,610 --> 00:39:22,910
is included in a certain special order.

867
00:39:22,910 --> 00:39:25,830
And to do that, I'm gonna
have to switch on myself

868
00:39:25,830 --> 00:39:28,470
and see what I am, to see if I am included

869
00:39:28,470 --> 00:39:29,790
in that special order.

870
00:39:29,790 --> 00:39:32,400
So you can see I have a
bunch of examples here.

871
00:39:32,400 --> 00:39:35,620
One of these examples I wanna
look at a little bit closer,

872
00:39:35,620 --> 00:39:37,610
which is this drink example.

873
00:39:37,610 --> 00:39:41,480
Notice that it's getting the
associated value in the switch

874
00:39:41,480 --> 00:39:43,910
for the ounces, but it's ignoring

875
00:39:43,910 --> 00:39:45,280
whether it's a Coke or Dr. Pepper.

876
00:39:45,280 --> 00:39:46,490
We don't care.

877
00:39:46,490 --> 00:39:48,570
It doesn't matter in terms
of whether it's included

878
00:39:48,570 --> 00:39:49,890
in a special order.

879
00:39:49,890 --> 00:39:54,290
So, this under-bar is the don't
pay any attention to this,

880
00:39:54,290 --> 00:39:56,330
I'm not interested, essentially.

881
00:39:56,330 --> 00:39:58,140
Just like when we have a function,

882
00:39:58,140 --> 00:40:00,770
it has parameters that have external names

883
00:39:58,140 --> 00:40:00,770
it has parameters that have external names

884
00:40:00,770 --> 00:40:03,160
and internal names, we
use that under-bar to say

885
00:40:03,160 --> 00:40:05,610
we're not interested in the
external name, don't use it.

886
00:40:05,610 --> 00:40:07,290
That's what this means here as well.

887
00:40:07,290 --> 00:40:10,740
So this is how if you
had some associated value

888
00:40:10,740 --> 00:40:12,260
as a tuple that had multiple things,

889
00:40:12,260 --> 00:40:14,020
you can just ignore some of them

890
00:40:14,020 --> 00:40:15,570
when you're getting the values.

891
00:40:19,890 --> 00:40:22,140
Enums can do constrains
and gains with protocols

892
00:40:22,140 --> 00:40:24,320
just like structs and classes can.

893
00:40:24,320 --> 00:40:27,120
There's a very interesting
protocol called CaseIterable.

894
00:40:28,180 --> 00:40:32,046
CaseIterable, you gain
a var called allCases.

895
00:40:32,046 --> 00:40:34,570
It's static var, so you
send it to the type,

896
00:40:34,570 --> 00:40:37,850
like here, a TeslaModel.allCases
you see there.

897
00:40:37,850 --> 00:40:42,490
And it's just going to return
to you an iterable thing,

898
00:40:42,490 --> 00:40:46,207
something you can do for-in
over of all the cases.

899
00:40:46,207 --> 00:40:47,730
And that can be super valuable.

900
00:40:47,730 --> 00:40:50,090
In your assignment three,
it's likely that you're going

901
00:40:50,090 --> 00:40:51,980
to need to use this.

902
00:40:51,980 --> 00:40:53,920
Now that we know what an enum is,

903
00:40:53,920 --> 00:40:57,550
we can talk about, probably,
the most important enum

904
00:40:57,550 --> 00:41:02,333
in all of Swift, which is called Optional.

905
00:41:03,870 --> 00:41:07,000
So, an Optional looks
essentially like this.

906
00:41:07,000 --> 00:41:09,870
It's got two discrete values.

907
00:41:09,870 --> 00:41:14,760
One is the case none,
and one is the case some.

908
00:41:14,760 --> 00:41:17,900
And in the some case,
it has associated value,

909
00:41:17,900 --> 00:41:19,077
which is a don't-care.

910
00:41:19,077 --> 00:41:21,590
So, Optional, Optional
just works with any type.

911
00:41:21,590 --> 00:41:24,570
It doesn't care what type it is.

912
00:41:24,570 --> 00:41:26,620
So essentially, Optional is either

913
00:41:26,620 --> 00:41:29,560
is an is set case, that's some,

914
00:41:29,560 --> 00:41:33,100
or the not set case, that's the none.

915
00:41:33,100 --> 00:41:34,890
And that's what an Optional is.

916
00:41:34,890 --> 00:41:36,350
Essentially a type.

917
00:41:36,350 --> 00:41:38,370
You're gonna have
variables of type Optional.

918
00:41:38,370 --> 00:41:40,450
They're either gonna be set or not set.

919
00:41:40,450 --> 00:41:43,370
And if they're set, they're
gonna have associated value

920
00:41:43,370 --> 00:41:48,370
of some type, which Optional
doesn't care what type that is.

921
00:41:48,940 --> 00:41:50,070
So where do we use Optional?

922
00:41:50,070 --> 00:41:53,090
Well, you can imagine we use it any time

923
00:41:53,090 --> 00:41:55,460
we have a variable whose value

924
00:41:55,460 --> 00:42:00,020
could either be not set or
unspecified or undetermined,

925
00:42:00,020 --> 00:42:01,403
anything like that.

926
00:42:02,450 --> 00:42:03,320
What're some examples?

927
00:42:03,320 --> 00:42:08,080
Well, that bogus return
type of firstIndex matching.

928
00:42:08,080 --> 00:42:10,270
If the matching thing is not in the Array,

929
00:42:10,270 --> 00:42:12,280
we're currently returning zero.

930
00:42:12,280 --> 00:42:13,840
And that's the first element in the Array.

931
00:42:13,840 --> 00:42:15,040
That's totally wrong.

932
00:42:15,040 --> 00:42:17,450
So instead, we're gonna
have firstIndex matching's

933
00:42:17,450 --> 00:42:19,460
return type be Optional.

934
00:42:19,460 --> 00:42:24,040
It'll be an Optional with the
associated value being an Int.

935
00:42:24,040 --> 00:42:26,190
And so it's either gonna
return set or not set.

936
00:42:26,190 --> 00:42:29,190
It's gonna return set if it was able

937
00:42:30,420 --> 00:42:32,430
and the associated
value will be the index.

938
00:42:32,430 --> 00:42:36,180
Or it's gonna return not set,
the none case right there,

939
00:42:36,180 --> 00:42:40,270
if it couldn't find that
matching thing in there.

940
00:42:40,270 --> 00:42:43,770
Another good example
just of a normal variable

941
00:42:43,770 --> 00:42:47,250
would be, let's say in my
matching game in the Model,

942
00:42:47,250 --> 00:42:49,340
what if I had a variable which is like

943
00:42:49,340 --> 00:42:52,440
the index of the currently face-up Card?

944
00:42:52,440 --> 00:42:55,530
Okay well, when the game starts,
there is no face-up Card.

945
00:42:55,530 --> 00:42:56,750
So what would that index be?

946
00:42:56,750 --> 00:42:58,360
It's like, it's not set.

947
00:42:58,360 --> 00:43:01,660
So we're gonna use an
Optional to store that.

948
00:43:01,660 --> 00:43:04,865
That var is not gonna be
of type Int for the index.

949
00:43:04,865 --> 00:43:06,570
It's gonna be of type Optional.

950
00:43:06,570 --> 00:43:08,160
Now the associated value will be an Int

951
00:43:08,160 --> 00:43:10,020
because of course, if it is set,

952
00:43:10,020 --> 00:43:12,070
we wanna know what that Int is.

953
00:43:12,070 --> 00:43:14,070
There's a couple good
examples which I'm gonna show

954
00:43:14,070 --> 00:43:15,653
in the demo right after this.

955
00:43:17,020 --> 00:43:18,620
So this happens surprisingly often

956
00:43:18,620 --> 00:43:22,990
that you need some variable
that sometimes is not set,

957
00:43:22,990 --> 00:43:24,350
it's unspecified.

958
00:43:24,350 --> 00:43:27,173
You wanna return a value
that says I couldn't do this,

959
00:43:27,173 --> 00:43:28,850
that kinda stuff.

960
00:43:28,850 --> 00:43:33,220
So, Swift introduces a
lot of syntactic sugar,

961
00:43:33,220 --> 00:43:37,280
basically special syntax, to
be able to make it really easy

962
00:43:37,280 --> 00:43:39,430
to use Optional, so much
so that you're gonna think

963
00:43:39,430 --> 00:43:42,990
that Optionals are just some
kind of magic type in Swift.

964
00:43:42,990 --> 00:43:45,150
But underlying it all,
it's just this enum.

965
00:43:45,150 --> 00:43:48,230
There's really nothing
more to it than that.

966
00:43:48,230 --> 00:43:51,500
So let's take a look at
all this syntactic sugar.

967
00:43:51,500 --> 00:43:55,660
First one is how do we declare or to say

968
00:43:55,660 --> 00:43:57,220
that we want this type?

969
00:43:57,220 --> 00:44:00,590
So right here in yellow,
you see that String?.

970
00:44:00,590 --> 00:44:04,140
That is declaring that
hello, this var hello,

971
00:44:04,140 --> 00:44:06,550
is of type Optional,

972
00:44:06,550 --> 00:44:09,770
an Optional whose associated
value is a String.

973
00:44:09,770 --> 00:44:12,360
We would call this an Optional String.

974
00:44:12,360 --> 00:44:14,580
When students are first exposed to this,

975
00:44:14,580 --> 00:44:18,220
they think that the type
of hello is a String

976
00:44:18,220 --> 00:44:21,410
that somehow is modified to be Optional.

977
00:44:21,410 --> 00:44:24,730
No, the type of hello here is an Optional.

978
00:44:24,730 --> 00:44:27,560
Its associated value is a
String, but it's an Optional.

979
00:44:27,560 --> 00:44:29,120
So that's how we declare it.

980
00:44:29,120 --> 00:44:32,010
That is how we type the type,

981
00:44:32,010 --> 00:44:36,083
how we type in with our fingers
the type Optional String.

982
00:44:37,200 --> 00:44:38,880
Now how about setting the value?

983
00:44:38,880 --> 00:44:41,480
Well remember, an Optional
String, it's an Optional.

984
00:44:41,480 --> 00:44:43,760
It only has two cases, none and some.

985
00:44:43,760 --> 00:44:47,490
So we set the none case
by just saying equals nil.

986
00:44:47,490 --> 00:44:52,240
So the keyword nil in
Swift means Optional.none.

987
00:44:52,240 --> 00:44:55,983
That means the not set
case of an Optional is nil.

988
00:44:57,340 --> 00:45:00,320
And similarly, we can say, hello,

989
00:45:00,320 --> 00:45:02,620
this Optional String
equals the String hello.

990
00:45:02,620 --> 00:45:04,860
And Swift is smart enough
to know that that means

991
00:45:04,860 --> 00:45:07,130
set this Optional to the some case

992
00:45:07,130 --> 00:45:10,023
and use hello as the associated value.

993
00:45:11,330 --> 00:45:14,500
So that String, hello
in this case, is set,

994
00:45:14,500 --> 00:45:17,923
and its associated value is hello.

995
00:45:19,690 --> 00:45:23,150
Note that Optionals always start

996
00:45:23,150 --> 00:45:25,920
with an implicit equals nil.

997
00:45:25,920 --> 00:45:28,940
This is nice because remember
that in structs and classes,

998
00:45:28,940 --> 00:45:31,110
all vars have to have an initial value.

999
00:45:31,110 --> 00:45:32,390
We've jumped through a lot of hoops

1000
00:45:32,390 --> 00:45:33,800
to try and get all of our vars

1001
00:45:33,800 --> 00:45:36,000
to have initial values so far.

1002
00:45:36,000 --> 00:45:38,220
Well, Optional, no hoops to jump through

1003
00:45:38,220 --> 00:45:40,470
because it gets an implicit equals nil,

1004
00:45:40,470 --> 00:45:45,350
or in the enum world,
dot-none, for all vars.

1005
00:45:45,350 --> 00:45:47,720
It makes sense, right, because
you've got an Optional here.

1006
00:45:47,720 --> 00:45:48,870
It's either set or not set.

1007
00:45:48,870 --> 00:45:50,890
Well, it's gonna start out not set.

1008
00:45:50,890 --> 00:45:54,390
You could initialize it to
equals hello if you wanted to,

1009
00:45:54,390 --> 00:45:56,550
but you can just leave it uninitialized,

1010
00:45:56,550 --> 00:45:58,070
but it's not really uninitialized.

1011
00:45:58,070 --> 00:46:00,593
It does get initialized to the none case.

1012
00:46:01,510 --> 00:46:03,270
So how about accessing the values?

1013
00:46:03,270 --> 00:46:06,070
So let's say I have a var like hello,

1014
00:46:06,070 --> 00:46:08,890
and it's an Optional,
Optional String let's say,

1015
00:46:08,890 --> 00:46:10,680
and I want the String.

1016
00:46:10,680 --> 00:46:12,690
How do I get the String?

1017
00:46:12,690 --> 00:46:14,010
How do I get that associated value?

1018
00:46:14,010 --> 00:46:16,390
Am I gonna have to do, like
you see down here in the right,

1019
00:46:16,390 --> 00:46:18,530
switch on it and then do case this?

1020
00:46:18,530 --> 00:46:19,670
Of course not.

1021
00:46:19,670 --> 00:46:22,350
There's a simple way to
do that switch on it.

1022
00:46:22,350 --> 00:46:23,300
Two ways, actually.

1023
00:46:23,300 --> 00:46:25,070
One is exclamation point.

1024
00:46:25,070 --> 00:46:27,910
If you put an exclamation
point after a var

1025
00:46:27,910 --> 00:46:31,000
that is an Optional, it will assume

1026
00:46:31,000 --> 00:46:33,500
that it's in the some case, the set case,

1027
00:46:33,500 --> 00:46:35,650
and get to you the associated value.

1028
00:46:35,650 --> 00:46:38,630
But if you're not, it
crashes your program.

1029
00:46:38,630 --> 00:46:40,820
Exclamation point is
truly, well we call it

1030
00:46:40,820 --> 00:46:44,130
force unwrapping, because
you're forcing that thing

1031
00:46:44,130 --> 00:46:45,950
to be unwrapped and give me that String.

1032
00:46:45,950 --> 00:46:47,100
But if that String's not there

1033
00:46:47,100 --> 00:46:49,010
because the Optional's
in the not set case,

1034
00:46:49,010 --> 00:46:50,437
then it crashes your program.

1035
00:46:50,437 --> 00:46:51,980
And we're gonna see in the demo,

1036
00:46:51,980 --> 00:46:54,249
this sounds like, ah,
I would never use this.

1037
00:46:54,249 --> 00:46:55,820
I would never want my program to crash.

1038
00:46:55,820 --> 00:46:57,210
But it can actually be quite useful

1039
00:46:57,210 --> 00:46:59,040
in cases where you know
this is never supposed

1040
00:46:59,040 --> 00:47:00,180
to be the case.

1041
00:47:00,180 --> 00:47:03,550
You can easily find bugs
in development and all that

1042
00:47:03,550 --> 00:47:05,040
by making the thing crash and say,

1043
00:47:05,040 --> 00:47:07,350
"Wah, that should never have crashed."

1044
00:47:07,350 --> 00:47:09,930
But there is a safe way to do it,

1045
00:47:09,930 --> 00:47:12,980
and that's by assigning
it to another variable,

1046
00:47:12,980 --> 00:47:14,090
a safe variable.

1047
00:47:14,090 --> 00:47:16,040
And you do that with if let.

1048
00:47:16,040 --> 00:47:18,320
So you see in the lower left corner here,

1049
00:47:18,320 --> 00:47:21,140
all the yellow is surrounding
how you do the if let.

1050
00:47:21,140 --> 00:47:23,970
You say, if let, some safe version,

1051
00:47:23,970 --> 00:47:27,170
equals the Optional, hello is an Optional,

1052
00:47:27,170 --> 00:47:31,160
then that safehello is
going to be of type String.

1053
00:47:31,160 --> 00:47:34,020
It's going to get the
value if the Optional

1054
00:47:34,020 --> 00:47:35,260
is in the some case.

1055
00:47:35,260 --> 00:47:37,610
And then inside the
curly braces after there,

1056
00:47:37,610 --> 00:47:39,870
if let safehello equals open curly brace,

1057
00:47:39,870 --> 00:47:43,090
in that curly brace,
safehello will exist in there,

1058
00:47:43,090 --> 00:47:44,580
and it will be a String.

1059
00:47:44,580 --> 00:47:45,667
Not an Optional.

1060
00:47:45,667 --> 00:47:50,250
It's grabbed the associated
value out of the Optional safely

1061
00:47:50,250 --> 00:47:51,320
and is executing.

1062
00:47:51,320 --> 00:47:54,430
Now, if that hello were
in the not set case,

1063
00:47:54,430 --> 00:47:56,890
then it just wouldn't
even execute that code

1064
00:47:56,890 --> 00:47:58,466
that says print(safehello).

1065
00:47:58,466 --> 00:47:59,600
Wouldn't even be executed.

1066
00:47:59,600 --> 00:48:02,690
It would do the do
something else down there.

1067
00:48:02,690 --> 00:48:05,370
That's like, on the right
there, the lower right,

1068
00:48:05,370 --> 00:48:06,600
switching on hello.

1069
00:48:06,600 --> 00:48:08,870
And in the case that
it's in the not set case,

1070
00:48:08,870 --> 00:48:11,520
you're gonna do that
something else that's an else.

1071
00:48:11,520 --> 00:48:13,000
Otherwise, if it's in the some case,

1072
00:48:13,000 --> 00:48:15,360
then you're just going to
get the String outta there

1073
00:48:15,360 --> 00:48:17,963
and do the print(safehello) in there.

1074
00:48:18,920 --> 00:48:22,260
So that's how we get the
value, the syntactic sugar

1075
00:48:22,260 --> 00:48:23,790
for getting the value of an Optional.

1076
00:48:23,790 --> 00:48:25,510
Either forcibly grabbing it out of there

1077
00:48:25,510 --> 00:48:27,180
and crashing if we can't find it,

1078
00:48:27,180 --> 00:48:30,170
or doing if let to a safe variable,

1079
00:48:30,170 --> 00:48:31,683
a safe landing spot for it.

1080
00:48:32,610 --> 00:48:34,670
Another cool little syntactic sugar

1081
00:48:34,670 --> 00:48:36,780
is the Optional defaulting.

1082
00:48:36,780 --> 00:48:40,900
So, this allows you to really
simply provide a default

1083
00:48:40,900 --> 00:48:43,300
when you're accessing an Optional

1084
00:48:43,300 --> 00:48:45,677
in case that Optional
is in the not set case,

1085
00:48:45,677 --> 00:48:47,630
and so it's equal to nil.

1086
00:48:47,630 --> 00:48:50,610
Here I have a little constant called x

1087
00:48:50,610 --> 00:48:54,570
which is of type Optional
String, Optional String.

1088
00:48:54,570 --> 00:48:56,040
And I may have set it to something.

1089
00:48:56,040 --> 00:48:58,780
Maybe I set it to nil, maybe
I set it to have something.

1090
00:48:58,780 --> 00:49:02,830
But now I'm saying let y equal x.

1091
00:49:02,830 --> 00:49:05,720
But if x is nil, use foo.

1092
00:49:05,720 --> 00:49:07,340
That's what that question
mark-question mark

1093
00:49:07,340 --> 00:49:08,410
means right there.

1094
00:49:08,410 --> 00:49:12,030
So, y is always going to be,
in this case, of type String.

1095
00:49:12,030 --> 00:49:15,667
Because if x, which is an
Optional, is in the set case

1096
00:49:15,667 --> 00:49:18,850
and it has an associated
value, y is gonna get it.

1097
00:49:18,850 --> 00:49:21,990
But if x is in the not set case,

1098
00:49:21,990 --> 00:49:24,530
then this question mark-question
mark's gonna make y

1099
00:49:24,530 --> 00:49:25,743
get the value of foo.

1100
00:49:26,680 --> 00:49:27,970
All right, so that's shown on the right

1101
00:49:27,970 --> 00:49:30,363
what it would look like
in enum form there.

1102
00:49:31,780 --> 00:49:35,660
All right, so Optionals are
best learned about in action,

1103
00:49:35,660 --> 00:49:38,010
so we're going to do two major things

1104
00:49:38,010 --> 00:49:39,183
with Optionals in this demo.

1105
00:49:39,183 --> 00:49:41,570
One, we're gonna fix that
firstIndex of matching

1106
00:49:41,570 --> 00:49:42,580
as I mentioned.

1107
00:49:42,580 --> 00:49:44,740
And number two, we're gonna make our game,

1108
00:49:44,740 --> 00:49:48,570
actually play the Memorize
game, start matching cards.

1109
00:49:48,570 --> 00:49:51,470
And to do that, a central piece of that,

1110
00:49:51,470 --> 00:49:53,720
is to have a variable that keeps track

1111
00:49:53,720 --> 00:49:55,950
of this card that's face-up.

1112
00:49:55,950 --> 00:49:57,120
'Cause when there's a card face-up,

1113
00:49:57,120 --> 00:49:59,690
I have to match it when
someone picks another card.

1114
00:49:59,690 --> 00:50:02,253
So, let's dive right into that demo.

1115
00:49:59,690 --> 00:50:02,253
So, let's dive right into that demo.

1116
00:50:03,930 --> 00:50:06,740
All righty, now that we
know what Optionals are,

1117
00:50:06,740 --> 00:50:09,600
we can use it to fix this bogus thing

1118
00:50:09,600 --> 00:50:11,110
that we had right here.

1119
00:50:11,110 --> 00:50:12,940
What was bogus about this?

1120
00:50:12,940 --> 00:50:16,350
Well, we have this function
that found the first index

1121
00:50:16,350 --> 00:50:19,570
matching some element in
an Array of Identifiables.

1122
00:50:19,570 --> 00:50:20,403
Which it did.

1123
00:50:20,403 --> 00:50:22,400
It went through and found the first one.

1124
00:50:22,400 --> 00:50:26,320
But if it couldn't find
it, it returned zero.

1125
00:50:26,320 --> 00:50:29,830
And zero means the index of
the first thing in the Array,

1126
00:50:29,830 --> 00:50:32,840
which is especially bogus
if this Array is empty,

1127
00:50:32,840 --> 00:50:34,290
which it could be.

1128
00:50:34,290 --> 00:50:35,770
So how're we going to fix this?

1129
00:50:35,770 --> 00:50:37,740
We're gonna fix it by
having our return type,

1130
00:50:37,740 --> 00:50:41,550
instead of being an Int,
it's going to be an Optional.

1131
00:50:41,550 --> 00:50:45,243
Notice I said that this
expression is an Optional.

1132
00:50:45,243 --> 00:50:48,160
It's an Optional whose
associated value is an Int,

1133
00:50:48,160 --> 00:50:50,330
but it's an Optional.

1134
00:50:50,330 --> 00:50:52,390
People sometimes get a little
confused in the beginning

1135
00:50:52,390 --> 00:50:54,490
thinking that this is somehow an Int

1136
00:50:54,490 --> 00:50:56,100
with some modifier on it.

1137
00:50:56,100 --> 00:50:57,973
No, this is a different type from Int.

1138
00:50:57,973 --> 00:51:00,550
It's a type called Optional.

1139
00:51:00,550 --> 00:51:03,540
This Optional Int, we might call it,

1140
00:51:03,540 --> 00:51:06,700
allows us to return nil right here,

1141
00:51:06,700 --> 00:51:11,380
or not set value of the Optional,
when we couldn't find it.

1142
00:51:11,380 --> 00:51:13,590
And it's really good at
communicating to anyone

1143
00:51:13,590 --> 00:51:16,610
who calls this, "I couldn't find this."

1144
00:51:16,610 --> 00:51:19,680
Our normal return is returning an Int,

1145
00:51:19,680 --> 00:51:21,810
and Swift is smart enough, of course,

1146
00:51:21,810 --> 00:51:25,240
that if you have an Optional
Int and you return an Int,

1147
00:51:25,240 --> 00:51:27,860
it will return the
Optional in the set state

1148
00:51:27,860 --> 00:51:29,980
with the associated value being that Int,

1149
00:51:29,980 --> 00:51:31,363
exactly what you want.

1150
00:51:32,220 --> 00:51:33,053
So this is it.

1151
00:51:33,053 --> 00:51:36,340
Now, this is no longer, in
any way, a bogus function,

1152
00:51:36,340 --> 00:51:38,770
it's a completely good function.

1153
00:51:38,770 --> 00:51:42,600
And we can use it in the two
places where we call this.

1154
00:51:42,600 --> 00:51:43,660
Let's go over here to Grid.

1155
00:51:43,660 --> 00:51:45,080
Let's start with this one.

1156
00:51:45,080 --> 00:51:47,270
So here is Grid using firstIndex.

1157
00:51:47,270 --> 00:51:48,680
It's getting the index.

1158
00:51:48,680 --> 00:51:50,740
This local variable right here,

1159
00:51:50,740 --> 00:51:52,700
if we option click on it now,

1160
00:51:52,700 --> 00:51:55,450
is now of type Optional Int.

1161
00:51:55,450 --> 00:51:58,040
Well, that's gonna be a problem down here,

1162
00:51:58,040 --> 00:51:59,810
and we'll see an error appear here,

1163
00:51:59,810 --> 00:52:03,357
which is "Value of Optional
type Int must be unwrapped

1164
00:52:03,357 --> 00:52:04,960
"to a value of Int."

1165
00:52:04,960 --> 00:52:08,370
And indeed, layout.location ofItemAt

1166
00:52:08,370 --> 00:52:11,060
does not take an Optional as its argument.

1167
00:52:11,060 --> 00:52:12,690
It takes an Int.

1168
00:52:12,690 --> 00:52:15,350
Now we could take this thing's advice

1169
00:52:15,350 --> 00:52:17,680
and say all right, let's unwrap it.

1170
00:52:17,680 --> 00:52:20,490
This is how we unwrap an Optional.

1171
00:52:20,490 --> 00:52:23,690
This takes an Optional
that's in the set state,

1172
00:52:23,690 --> 00:52:25,663
and gets its associated value.

1173
00:52:26,610 --> 00:52:30,540
However, when the Optional
is in the not set state,

1174
00:52:30,540 --> 00:52:32,820
this crashes your program.

1175
00:52:32,820 --> 00:52:33,957
Now some of you might say,

1176
00:52:33,957 --> 00:52:37,487
"Whoa, why are we ever
gonna use exclamation point?

1177
00:52:37,487 --> 00:52:40,990
"It's terrible, it crashes
my program sometimes."

1178
00:52:40,990 --> 00:52:44,050
Well yes, but in this case,
might actually be good

1179
00:52:44,050 --> 00:52:46,230
to leave this exclamation point in here.

1180
00:52:46,230 --> 00:52:48,370
Because it should never be the case

1181
00:52:48,370 --> 00:52:51,360
that we look up the first
index of one of our items,

1182
00:52:51,360 --> 00:52:55,070
which we only got by ForEach-ing
through our Item Array.

1183
00:52:55,070 --> 00:52:56,660
This should never be nil.

1184
00:52:56,660 --> 00:52:59,810
And if it ever were nil,
something is going terribly wrong

1185
00:52:59,810 --> 00:53:03,200
somewhere in my code, and
I'd kinda like it to crash

1186
00:53:03,200 --> 00:53:04,783
so I find that problem.

1187
00:53:05,800 --> 00:53:07,600
But maybe I'm really conservative,

1188
00:53:07,600 --> 00:53:09,870
and when I ship my code to my customers,

1189
00:53:09,870 --> 00:53:12,080
I really wanna make sure, no matter what,

1190
00:53:12,080 --> 00:53:15,670
it doesn't crash with one
of these exclamation points.

1191
00:53:15,670 --> 00:53:18,590
So, I could kind of protect my customers

1192
00:53:18,590 --> 00:53:21,680
by protecting this code, and say if index

1193
00:53:21,680 --> 00:53:25,410
does not equal nil, then do this.

1194
00:53:25,410 --> 00:53:27,750
And that will protect this code

1195
00:53:27,750 --> 00:53:29,203
so that it can't crash.

1196
00:53:29,203 --> 00:53:33,880
Because if index is not nil,
then unwrapping it right here

1197
00:53:33,880 --> 00:53:36,000
is always going to work.

1198
00:53:36,000 --> 00:53:38,053
But this doesn't build.

1199
00:53:39,160 --> 00:53:41,900
And why does this code not build?

1200
00:53:41,900 --> 00:53:44,077
It says here "Missing return in a function

1201
00:53:44,077 --> 00:53:47,210
"expected to return 'some View'."

1202
00:53:47,210 --> 00:53:50,890
Indeed, this function is
supposed to return "some View."

1203
00:53:50,890 --> 00:53:54,320
And it does return "some
View" in the case the index

1204
00:53:54,320 --> 00:53:56,960
is not nil, but if index is nil,

1205
00:53:56,960 --> 00:53:58,853
currently, it returns nothing.

1206
00:53:59,800 --> 00:54:01,320
That's a problem.

1207
00:54:01,320 --> 00:54:03,343
I'm not even sure what
we would wanna return

1208
00:54:03,343 --> 00:54:05,610
in that case here.

1209
00:54:05,610 --> 00:54:07,980
So, we're gonna have to take
a little different strategy

1210
00:54:07,980 --> 00:54:11,240
to return "some View" here
that has a conditional.

1211
00:54:11,240 --> 00:54:13,080
And we've seen it before.

1212
00:54:13,080 --> 00:54:17,730
It's over here in our View, ZStack.

1213
00:54:17,730 --> 00:54:19,200
ZStack had a conditional.

1214
00:54:19,200 --> 00:54:21,760
If the card was face-up, it did one thing.

1215
00:54:21,760 --> 00:54:24,260
If it was face-down, it did another thing.

1216
00:54:24,260 --> 00:54:27,920
This function right here
that ZStack takes, remember,

1217
00:54:27,920 --> 00:54:28,790
is called the ViewBiulder.

1218
00:54:28,790 --> 00:54:33,040
It's the same thing that
our GeometryReader takes,

1219
00:54:33,040 --> 00:54:35,090
same thing ForEach takes, HStack,

1220
00:54:35,090 --> 00:54:38,350
they all take this thing,
ViewBuilder, which is a function,

1221
00:54:38,350 --> 00:54:39,670
but it's a special kind of function

1222
00:54:39,670 --> 00:54:40,917
where you can put these if-thens in there,

1223
00:54:40,917 --> 00:54:42,890
and you can just list Views.

1224
00:54:42,890 --> 00:54:45,610
And it turns that all into something

1225
00:54:45,610 --> 00:54:48,090
that is "some View."

1226
00:54:48,090 --> 00:54:51,770
So the ZStack can have
"some View" as its content.

1227
00:54:51,770 --> 00:54:55,390
Well, we can do this same
thing over here in our Grid,

1228
00:54:55,390 --> 00:54:57,050
but we don't need to do any layout.

1229
00:54:57,050 --> 00:54:59,890
We're doing the layout with
our frame and position.

1230
00:54:59,890 --> 00:55:02,190
So we want something
that takes a ViewBuilder

1231
00:55:02,190 --> 00:55:03,970
that kinda does nothing.

1232
00:55:03,970 --> 00:55:05,510
And there is such a thing.

1233
00:55:05,510 --> 00:55:07,303
It's called Group.

1234
00:55:08,340 --> 00:55:12,550
So, Group is like a ZStack
or any of these other things

1235
00:55:12,550 --> 00:55:16,690
in that its function argument
here is a View builder.

1236
00:55:16,690 --> 00:55:20,730
However, it doesn't do anything
to what's inside of here.

1237
00:55:20,730 --> 00:55:23,640
It allows you to do the
if and thens and all that,

1238
00:55:23,640 --> 00:55:26,210
and you can still list the things,

1239
00:55:26,210 --> 00:55:28,540
but it does not lay them out

1240
00:55:28,540 --> 00:55:30,920
or try to position them in any way.

1241
00:55:30,920 --> 00:55:33,863
And so, our positioning will
continue to work in here.

1242
00:55:35,030 --> 00:55:37,271
So, we turn this to a two-line function

1243
00:55:37,271 --> 00:55:40,270
instead of a one liner, so
we have to put return in here

1244
00:55:40,270 --> 00:55:41,780
to make sure we're returning the Group.

1245
00:55:41,780 --> 00:55:45,290
But now we are returning
Group, which is some View.

1246
00:55:45,290 --> 00:55:48,210
And Group is just using
the View builder stuff

1247
00:55:48,210 --> 00:55:49,610
to go like this.

1248
00:55:49,610 --> 00:55:53,530
Now, you might ask, "What does
Group do if index is nil?"

1249
00:55:53,530 --> 00:55:55,360
Well, it's gonna return a group

1250
00:55:55,360 --> 00:55:57,740
that has some sort of empty content.

1251
00:55:57,740 --> 00:55:59,300
Its body is gonna be an empty View.

1252
00:55:59,300 --> 00:56:01,410
There's actually a View called EmptyView.

1253
00:56:01,410 --> 00:56:04,180
Probably returns that,
but we really don't care.

1254
00:56:04,180 --> 00:56:06,374
We're just using the
ViewBuilder functionality here

1255
00:56:06,374 --> 00:56:08,850
when we know we can do ifs.

1256
00:56:08,850 --> 00:56:11,440
And we're gonna find that Group is useful

1257
00:56:11,440 --> 00:56:14,170
in a lot of other situations as well.

1258
00:56:14,170 --> 00:56:17,630
As its name implies, it's
good for grouping things.

1259
00:56:17,630 --> 00:56:20,760
That's because Group, its View here

1260
00:56:20,760 --> 00:56:22,480
is a ViewBuilder View.

1261
00:56:22,480 --> 00:56:24,350
That's why we're able to do the if,

1262
00:56:24,350 --> 00:56:28,580
but it's also why we would
be able to list some Views,

1263
00:56:28,580 --> 00:56:30,290
and thus group them.

1264
00:56:30,290 --> 00:56:33,760
So that's really probably the
primary reason Group exists.

1265
00:56:33,760 --> 00:56:36,010
That's why it's called Group.

1266
00:56:36,010 --> 00:56:39,050
But to be honest, I really
probably wouldn't have

1267
00:56:39,050 --> 00:56:41,740
gone through all the
trouble of doing this.

1268
00:56:41,740 --> 00:56:43,710
I don't think there's really any reason

1269
00:56:43,710 --> 00:56:45,860
to check if this index is nil.

1270
00:56:45,860 --> 00:56:48,393
It should never be nil,
as I mentioned before.

1271
00:56:49,260 --> 00:56:54,170
So I likely would have
just removed all this.

1272
00:56:54,170 --> 00:56:56,590
Gone back to where we were before.

1273
00:56:56,590 --> 00:56:59,890
And let this index force unwrap happen.

1274
00:56:59,890 --> 00:57:02,053
And if it crashed my
app, it crashed my app.

1275
00:57:02,053 --> 00:57:05,310
It never should, and so I
wanna find in development,

1276
00:57:05,310 --> 00:57:07,860
and this code is a lot
cleaner without all that

1277
00:57:07,860 --> 00:57:10,453
ViewBuilder stuff in there as well.

1278
00:57:11,470 --> 00:57:14,580
The other thing I might do is
move this exclamation point

1279
00:57:14,580 --> 00:57:17,460
from down here where I'm passing this var

1280
00:57:17,460 --> 00:57:22,090
to up here where I'm actually
getting the value of this var.

1281
00:57:22,090 --> 00:57:23,890
So, get that firstIndex,

1282
00:57:23,890 --> 00:57:25,920
and immediately force unwrap it.

1283
00:57:25,920 --> 00:57:28,280
That turns this index variable right here

1284
00:57:28,280 --> 00:57:30,723
into an Int, and we can pass it directly.

1285
00:57:32,280 --> 00:57:34,040
All right, so there was one other place

1286
00:57:34,040 --> 00:57:35,675
where we used firstIndex.

1287
00:57:35,675 --> 00:57:38,050
That's in our Model, so let's go over here

1288
00:57:38,050 --> 00:57:40,860
and take a look at the damage we wrought

1289
00:57:40,860 --> 00:57:43,800
by switching over to firstIndex here.

1290
00:57:43,800 --> 00:57:45,970
Here we're gonna use a
little different strategy

1291
00:57:45,970 --> 00:57:48,740
to get around the error that
the Optional must be unwrapped

1292
00:57:48,740 --> 00:57:51,930
is I'm gonna use the
if in front of my let,

1293
00:57:51,930 --> 00:57:53,700
which is a really cool feature.

1294
00:57:53,700 --> 00:57:57,090
Just put the if in front,
and then you put curly braces

1295
00:57:57,090 --> 00:57:59,350
and do anything you want.

1296
00:57:59,350 --> 00:58:03,230
And this anything you want
will only actually happen

1297
00:58:03,230 --> 00:58:06,490
if this thing returns non nil.

1298
00:58:06,490 --> 00:58:09,980
If it returns nil, this code
just doesn't even get executed.

1299
00:58:09,980 --> 00:58:14,770
In here, notice that this
if let allowed us to keep

1300
00:58:14,770 --> 00:58:17,380
colon Int as the type of chosenIndex.

1301
00:58:17,380 --> 00:58:20,410
We don't need that, by the way,
'cause it's gonna infer it,

1302
00:58:20,410 --> 00:58:22,740
but chosenIndex is in fact an Int.

1303
00:58:22,740 --> 00:58:26,730
It's only going to actually
exist if this firstIndex

1304
00:58:26,730 --> 00:58:29,300
returns a non nil, and
that's the only time

1305
00:58:29,300 --> 00:58:31,970
this code's gonna be executed either.

1306
00:58:31,970 --> 00:58:33,400
But this does exactly what we want.

1307
00:58:33,400 --> 00:58:35,160
It protects us against chosenIndex.

1308
00:58:35,160 --> 00:58:37,530
It means choose does nothing.

1309
00:58:37,530 --> 00:58:39,740
If we can't find this Card in our cards,

1310
00:58:39,740 --> 00:58:40,600
then this does nothing.

1311
00:58:40,600 --> 00:58:41,433
That's exactly what we want.

1312
00:58:41,433 --> 00:58:43,040
We want it to do nothing.

1313
00:58:43,040 --> 00:58:46,040
Let's run and make sure
this Optional business

1314
00:58:46,040 --> 00:58:47,980
didn't break anything.

1315
00:58:47,980 --> 00:58:48,813
Here we go.

1316
00:58:48,813 --> 00:58:50,550
Yup, we can still flip our cards over.

1317
00:58:50,550 --> 00:58:52,150
face-up, face-down.

1318
00:58:52,150 --> 00:58:55,520
But now, it's time to
try and play the game.

1319
00:58:55,520 --> 00:58:57,650
We'll need Optional for that as well.

1320
00:58:57,650 --> 00:59:00,030
We're gonna try and make
it so that these cards

1321
00:59:00,030 --> 00:59:02,200
will actually match,
and maybe matched cards

1322
00:59:02,200 --> 00:59:03,033
will disappear from the game.

1323
00:59:03,033 --> 00:59:04,503
That would be cool too.

1324
00:59:05,770 --> 00:59:06,967
So how do we do that?

1325
00:59:06,967 --> 00:59:11,620
How're we going to play
our game, make it play?

1326
00:59:11,620 --> 00:59:13,290
Well, we need a little bit of design.

1327
00:59:13,290 --> 00:59:15,040
We are software designers.

1328
00:59:15,040 --> 00:59:16,350
We have to think conceptually

1329
00:59:16,350 --> 00:59:18,300
how are we gonna make this happen.

1330
00:59:18,300 --> 00:59:22,080
So I'm gonna run through,
in my mind, the scenarios.

1331
00:59:22,080 --> 00:59:24,770
First, all of my Cards are face-down.

1332
00:59:24,770 --> 00:59:26,610
And I click on a Card.

1333
00:59:26,610 --> 00:59:28,210
And no matching happens then.

1334
00:59:28,210 --> 00:59:30,570
The Card just flips face-up,
which is what it's doing

1335
00:59:30,570 --> 00:59:32,610
in our code right there now.

1336
00:59:32,610 --> 00:59:34,320
So, okay that's fine.

1337
00:59:34,320 --> 00:59:36,800
Second state is I got that one Card up

1338
00:59:36,800 --> 00:59:38,750
and I click on a second Card.

1339
00:59:38,750 --> 00:59:40,880
Well, that's when I really need to match.

1340
00:59:40,880 --> 00:59:42,640
So if there's one Card face-up

1341
00:59:42,640 --> 00:59:44,250
and there's a Card clicked on,

1342
00:59:44,250 --> 00:59:46,080
that's when I'm gonna play my game.

1343
00:59:46,080 --> 00:59:49,850
If there's two Cards face-up
now and I press a third Card,

1344
00:59:49,850 --> 00:59:51,760
now I need to essentially turn

1345
00:59:51,760 --> 00:59:53,230
those other two Cards face-down.

1346
00:59:53,230 --> 00:59:54,250
Whether they're matched or not,

1347
00:59:54,250 --> 00:59:55,960
they need to be turned face-down.

1348
00:59:55,960 --> 00:59:58,210
And the Card I just touched on,

1349
00:59:58,210 --> 01:00:00,310
that's going to be the one that's face-up.

1350
00:59:58,210 --> 01:00:00,310
that's going to be the one that's face-up.

1351
01:00:01,180 --> 01:00:02,420
In those three scenarios.

1352
01:00:02,420 --> 01:00:04,390
That's all the scenarios there are.

1353
01:00:04,390 --> 01:00:06,830
In those three scenarios, the
only time I actually played

1354
01:00:06,830 --> 01:00:11,580
a matching game is if there's
one and only one Card face-up

1355
01:00:11,580 --> 01:00:14,210
at the time I touch on a new Card.

1356
01:00:14,210 --> 01:00:16,030
So I need to detect that case

1357
01:00:16,030 --> 01:00:17,210
when there's one and only one.

1358
01:00:17,210 --> 01:00:19,580
So I'm gonna have a var

1359
01:00:19,580 --> 01:00:21,470
which keeps track of the index

1360
01:00:21,470 --> 01:00:26,253
of the one and only face-up Card.

1361
01:00:27,990 --> 01:00:30,380
And this is an index into my Array,

1362
01:00:30,380 --> 01:00:31,620
so it's gonna be an Int.

1363
01:00:31,620 --> 01:00:34,620
But it might be the start of my game

1364
01:00:34,620 --> 01:00:35,780
and there's no face-up Card,

1365
01:00:35,780 --> 01:00:38,230
or maybe there's two face-up Cards.

1366
01:00:38,230 --> 01:00:41,410
So this really needs to be an Optional.

1367
01:00:41,410 --> 01:00:44,320
Notice that I didn't
get the error down here

1368
01:00:44,320 --> 01:00:45,830
that I haven't initialized this.

1369
01:00:45,830 --> 01:00:49,260
There's no errors, but I
haven't initialized this yet.

1370
01:00:49,260 --> 01:00:50,093
No errors.

1371
01:00:50,093 --> 01:00:53,010
And that's because all Optionals

1372
01:00:53,010 --> 01:00:56,200
get initialized to nil automatically.

1373
01:00:56,200 --> 01:00:57,430
So there's an equals nil.

1374
01:00:57,430 --> 01:00:58,960
You could type it if you want.

1375
01:00:58,960 --> 01:01:01,490
But if you don't put it in
there, it's gonna be there.

1376
01:01:01,490 --> 01:01:02,697
And that makes sense, right?

1377
01:01:02,697 --> 01:01:05,203
Optionals equals nil means it's not set.

1378
01:01:06,248 --> 01:01:10,760
Makes total sense that this var
starts out the game not set.

1379
01:01:10,760 --> 01:01:11,690
So let's keep going here.

1380
01:01:11,690 --> 01:01:14,980
I got this chosenIndex,
and I really only want

1381
01:01:14,980 --> 01:01:19,980
to pay attention to Cards that
are obviously in my Array,

1382
01:01:20,720 --> 01:01:25,300
but also that are not already face-up.

1383
01:01:25,300 --> 01:01:28,130
If a Card is already
face-up and I tap on it,

1384
01:01:28,130 --> 01:01:29,850
I'm just gonna ignore it.

1385
01:01:29,850 --> 01:01:31,890
Now, you'd think this would work, right?

1386
01:01:31,890 --> 01:01:33,430
Get the chosenIndex here,

1387
01:01:33,430 --> 01:01:35,990
and the chosenIndex is not face-up.

1388
01:01:35,990 --> 01:01:40,330
But it's complaining that
chosenIndex is unresolved.

1389
01:01:40,330 --> 01:01:42,310
So if you wanna do an and like this

1390
01:01:42,310 --> 01:01:44,860
where you're saying if let of something

1391
01:01:44,860 --> 01:01:47,490
and then you wanna do
and on that something,

1392
01:01:47,490 --> 01:01:50,550
instead of and here,
you're gonna use comma.

1393
01:01:50,550 --> 01:01:53,270
So comma is like a sequential and,

1394
01:01:53,270 --> 01:01:55,520
where it does this first.

1395
01:01:55,520 --> 01:01:59,870
Then, that's done, it can do
this, and chosenIndex is set.

1396
01:01:59,870 --> 01:02:01,630
And you can even have more of these,

1397
01:02:01,630 --> 01:02:05,000
like I might also want to ignore Cards

1398
01:02:05,000 --> 01:02:09,190
where this shows an
index is not not matched.

1399
01:02:09,190 --> 01:02:11,310
So I'm only gonna touch on Cards

1400
01:02:11,310 --> 01:02:12,940
that are face-up and unmatched.

1401
01:02:12,940 --> 01:02:14,843
Otherwise I just ignore those Cards.

1402
01:02:15,940 --> 01:02:19,363
We use that comma notation
quite a bit with these if lets.

1403
01:02:20,290 --> 01:02:22,630
Inside here, I know
that I've chosen a Card

1404
01:02:22,630 --> 01:02:24,850
that was face-down and not yet matched.

1405
01:02:24,850 --> 01:02:28,500
So I just wanna see if
there's one and only one

1406
01:02:28,500 --> 01:02:30,280
face-up Card right now, so I'm gonna say

1407
01:02:30,280 --> 01:02:32,827
if I can let potentialMatchIndex

1408
01:02:34,270 --> 01:02:38,040
equal the indexOfTheOneAndOnlyFaceUpCard,

1409
01:02:38,040 --> 01:02:40,690
now I might have a match

1410
01:02:40,690 --> 01:02:42,380
because there's one and
only one face-up Card.

1411
01:02:42,380 --> 01:02:44,420
I just turned another Card over.

1412
01:02:44,420 --> 01:02:45,550
We need to try and match it.

1413
01:02:45,550 --> 01:02:49,600
No problem, if the Cards
at the chosenIndex,

1414
01:02:49,600 --> 01:02:53,100
if its contents, remember the content

1415
01:02:53,100 --> 01:02:55,940
on the Card right here,
that's what's on the Card,

1416
01:02:55,940 --> 01:03:00,940
equals the Cards at the
potentialMatchIndex content,

1417
01:03:01,330 --> 01:03:04,300
then woohoo, got a match.

1418
01:03:04,300 --> 01:03:06,510
Now this is making an error happen.

1419
01:03:06,510 --> 01:03:08,590
Why is this making an error?

1420
01:03:08,590 --> 01:03:12,237
It says "Binary operator
equals-equals cannot be applied

1421
01:03:12,237 --> 01:03:15,790
"to two CardContent operands."

1422
01:03:15,790 --> 01:03:20,790
Hmm, indeed both of these
things are type CardContent.

1423
01:03:21,710 --> 01:03:24,700
That's our don't-care down here.

1424
01:03:24,700 --> 01:03:27,720
Why can't we do
equals-equals on CardContent?

1425
01:03:27,720 --> 01:03:30,090
It's a String, right, emoji String.

1426
01:03:30,090 --> 01:03:31,900
Op, wait a second.

1427
01:03:31,900 --> 01:03:35,750
This is a generic memory
game playing thing.

1428
01:03:35,750 --> 01:03:37,850
These are no emoji in there.

1429
01:03:37,850 --> 01:03:41,950
They're CardContent, which
is a don't-care for us.

1430
01:03:41,950 --> 01:03:45,880
This could be anything, Images,
Strings, Ints, whatever.

1431
01:03:45,880 --> 01:03:47,680
We're trying to say equals-equals.

1432
01:03:47,680 --> 01:03:49,700
If it's a String, okay, it works fine.

1433
01:03:49,700 --> 01:03:50,910
What if it's an Image?

1434
01:03:50,910 --> 01:03:53,290
Can you say one Image
equals-equals another?

1435
01:03:53,290 --> 01:03:55,160
Maybe not, I don't know.

1436
01:03:55,160 --> 01:03:56,640
Equals-equals is not something

1437
01:03:56,640 --> 01:03:58,992
that just applies to everything.

1438
01:03:58,992 --> 01:04:02,830
And in fact, how does
equals-equals work in Swift?

1439
01:04:02,830 --> 01:04:06,480
Equals-equals in Swift, believe
it or not, is not built in

1440
01:04:06,480 --> 01:04:07,860
to the language.

1441
01:04:07,860 --> 01:04:10,630
It uses a feature in
Swift called operators

1442
01:04:10,630 --> 01:04:13,310
that lets you associate
an operator like this

1443
01:04:13,310 --> 01:04:15,200
with a function.

1444
01:04:15,200 --> 01:04:17,320
And that's exactly what equal-equals does.

1445
01:04:17,320 --> 01:04:21,750
It associates it with the
type function equals-equals.

1446
01:04:21,750 --> 01:04:24,140
Now, equals-equals might
seem like a funny name

1447
01:04:24,140 --> 01:04:27,300
for a function in Swift.

1448
01:04:27,300 --> 01:04:29,400
And it is kinda funny, but also remember

1449
01:04:29,400 --> 01:04:32,870
that smiley face, the emoji smiley face,

1450
01:04:32,870 --> 01:04:35,210
is a valid function name in Swift.

1451
01:04:35,210 --> 01:04:39,060
Any Unicode characters,
pretty much, is valid Swift.

1452
01:04:39,060 --> 01:04:42,130
So, equals-equals is just
as valid as smiley face.

1453
01:04:42,130 --> 01:04:44,730
So this equal-equals
function is a type function,

1454
01:04:44,730 --> 01:04:46,460
and it just takes two arguments,

1455
01:04:46,460 --> 01:04:48,567
which is the two things on
either side of the equals,

1456
01:04:48,567 --> 01:04:52,330
and it returns a bool, whether
they're the same or not.

1457
01:04:52,330 --> 01:04:54,370
That's it, that's exactly
what you'd expect.

1458
01:04:54,370 --> 01:04:58,090
But not every type has
this equals-equals in it.

1459
01:04:58,090 --> 01:05:00,000
Only some types that can actually

1460
01:05:00,000 --> 01:05:02,130
check for equality have that.

1461
01:05:02,130 --> 01:05:04,550
But luckily, that equals-equals function

1462
01:05:04,550 --> 01:05:07,810
is in a protocol called Equatable,

1463
01:05:07,810 --> 01:05:11,030
so we can use our
constrains and gains here

1464
01:05:11,030 --> 01:05:15,990
to say where our CardContent
implements Equatable.

1465
01:05:15,990 --> 01:05:18,060
In other words, we're only gonna work,

1466
01:05:18,060 --> 01:05:20,580
our MemoryGame only works
when our CardContent

1467
01:05:21,470 --> 01:05:23,983
can be equaled-equaled,
could be Equatable.

1468
01:05:25,020 --> 01:05:28,760
Let's go look at this
protocol in the documentation.

1469
01:05:28,760 --> 01:05:31,050
So I'm gonna do Option, click.

1470
01:05:31,050 --> 01:05:34,310
This is a kind of top-level
documentation about it,

1471
01:05:34,310 --> 01:05:35,883
but let's go into the doc.

1472
01:05:37,070 --> 01:05:39,360
Equal-equal's a very important protocol.

1473
01:05:39,360 --> 01:05:41,940
You can see it's got a lot of explanation

1474
01:05:41,940 --> 01:05:44,530
of what it means to say
something is equal-equal

1475
01:05:44,530 --> 01:05:48,130
to something else, transitive
property, all this business.

1476
01:05:48,130 --> 01:05:50,540
But when you get down to the
list of functions about it,

1477
01:05:50,540 --> 01:05:53,470
there's only one that is required.

1478
01:05:53,470 --> 01:05:54,600
You see this required?

1479
01:05:54,600 --> 01:05:56,950
That means it is part of the protocol,

1480
01:05:56,950 --> 01:05:59,100
and there's no default implementation

1481
01:05:59,100 --> 01:06:03,200
by an extension anywhere,
so you must implement this.

1482
01:06:03,200 --> 01:06:06,970
And it's exactly what I said,
a static, a type function

1483
01:06:06,970 --> 01:06:09,570
that takes two of those things,

1484
01:06:09,570 --> 01:06:12,070
remember in the slides,
we had is greater than

1485
01:06:12,070 --> 01:06:15,400
and you had self, so the
argument is greater than

1486
01:06:15,400 --> 01:06:17,180
with an Int or it was a President.

1487
01:06:17,180 --> 01:06:18,140
Same thing here.

1488
01:06:18,140 --> 01:06:20,950
If you have equals-equals
and if let's a String,

1489
01:06:20,950 --> 01:06:23,620
then Self and Self would
be String and String,

1490
01:06:23,620 --> 01:06:26,580
so it takes two Strings and compares them.

1491
01:06:26,580 --> 01:06:29,460
If it's Int, it takes two Ints, whatever.

1492
01:06:29,460 --> 01:06:31,180
This is the only function
you have to implement.

1493
01:06:31,180 --> 01:06:34,480
Really easy function, simple
function to understand,

1494
01:06:34,480 --> 01:06:36,380
although you have to read
all this to make sure

1495
01:06:36,380 --> 01:06:37,710
you really understand it.

1496
01:06:37,710 --> 01:06:40,380
And the only one we have
to implement in Equatable.

1497
01:06:40,380 --> 01:06:42,020
All these other ones are not required

1498
01:06:42,020 --> 01:06:44,810
because you get them
for free by extension.

1499
01:06:44,810 --> 01:06:48,320
Swift Foundation gives you these things

1500
01:06:48,320 --> 01:06:51,290
for tuples and other
things here automatically.

1501
01:06:51,290 --> 01:06:53,610
And does not equals, it
gives you that one for free.

1502
01:06:53,610 --> 01:06:55,983
They're all based on
the equals-equals here.

1503
01:06:57,630 --> 01:07:00,550
This is a protocol, protocol Equatable.

1504
01:07:00,550 --> 01:07:04,180
So we are just forcing, or constraining,

1505
01:07:04,180 --> 01:07:07,620
our CardContent, our
don't-care, to be Equatable.

1506
01:07:07,620 --> 01:07:08,500
We care a little bit.

1507
01:07:08,500 --> 01:07:11,540
We care that it's Equatable
so we can compare it.

1508
01:07:11,540 --> 01:07:13,310
All right, so if these two things match,

1509
01:07:13,310 --> 01:07:14,810
then I'm just gonna say they're matched.

1510
01:07:14,810 --> 01:07:19,810
cards at the chosenIndex,
isMatched equals true.

1511
01:07:20,900 --> 01:07:24,000
And of course the cards at
the potentialMatchIndex,

1512
01:07:24,000 --> 01:07:25,170
it did turn out to be a match,

1513
01:07:25,170 --> 01:07:28,463
so its isMatched also equals true.

1514
01:07:29,400 --> 01:07:30,400
So these Cards are matched.

1515
01:07:30,400 --> 01:07:31,370
That's awesome.

1516
01:07:31,370 --> 01:07:33,910
Notice that no matter what,
whether they match or not,

1517
01:07:33,910 --> 01:07:36,260
there are two Cards face-up now.

1518
01:07:36,260 --> 01:07:41,083
So the index of the one and
only face-up Card is nil.

1519
01:07:41,988 --> 01:07:44,040
There's not one and only one face-up Card.

1520
01:07:44,040 --> 01:07:46,090
There are two, so that means this is nil.

1521
01:07:47,040 --> 01:07:48,900
What about the else case here?

1522
01:07:48,900 --> 01:07:52,220
So in this case, there is not
one and only one face-up Card.

1523
01:07:52,220 --> 01:07:55,250
So there's either zero
or there's more than one.

1524
01:07:55,250 --> 01:07:58,220
In this case, we wanna turn
all the Cards face-down

1525
01:07:58,220 --> 01:08:00,470
except for the one we
just chose of course.

1526
01:08:00,470 --> 01:08:01,910
So we're gonna do a little for loop,

1527
01:08:01,910 --> 01:08:05,073
index in our cards.indices

1528
01:08:06,113 --> 01:08:08,970
And we're just gonna go
for every single Card

1529
01:08:08,970 --> 01:08:12,900
isFaceUp equals false, and we'll make sure

1530
01:08:12,900 --> 01:08:17,900
that we turn our Card to
true, turn it face-up.

1531
01:08:18,010 --> 01:08:19,530
Also notice in this case

1532
01:08:19,530 --> 01:08:24,530
that the indexOfTheOneAndOnlyFaceUpCard
is our chosenIndex.

1533
01:08:24,714 --> 01:08:26,961
'Cause I just turned
all of these face-down

1534
01:08:26,961 --> 01:08:29,446
and I'm gonna turn this one back up,

1535
01:08:29,446 --> 01:08:33,921
and so it's going to be
the only face-up Card.

1536
01:08:33,921 --> 01:08:35,090
So that's it.

1537
01:08:35,090 --> 01:08:36,010
This is our logic.

1538
01:08:36,010 --> 01:08:38,947
We don't need this Card chosen
to print anymore right there.

1539
01:08:38,947 --> 01:08:41,430
And that's the entirety
of making this work.

1540
01:08:41,430 --> 01:08:44,803
So let's run, see if our
game plays like we want.

1541
01:08:45,770 --> 01:08:47,920
Well, this game turns out
to be one of the easiest

1542
01:08:47,920 --> 01:08:51,870
memory games out there because
all the Cards start face-up.

1543
01:08:51,870 --> 01:08:52,970
So, that's no good.

1544
01:08:52,970 --> 01:08:54,690
Let's go back to our Model here

1545
01:08:54,690 --> 01:08:58,040
and change it so that all
the Cards start face-down.

1546
01:08:58,040 --> 01:09:01,533
I think that's gonna make for
a much more challenging game.

1547
01:09:02,960 --> 01:09:04,100
All right, let's try it.

1548
01:09:04,100 --> 01:09:05,800
Ghost, yeah.

1549
01:09:05,800 --> 01:09:08,150
Pumpkin, oh no, no match.

1550
01:09:08,150 --> 01:09:11,640
Ghost, yeah, spider, no, no, not again.

1551
01:09:11,640 --> 01:09:14,109
Pumpkin, ah, I think I
know where the pumpkin is.

1552
01:09:14,109 --> 01:09:15,410
It's right here.

1553
01:09:15,410 --> 01:09:16,270
Yes.

1554
01:09:16,270 --> 01:09:18,280
And then how about spider?

1555
01:09:18,280 --> 01:09:23,020
Oh, now notice that it did turn
my matched cards face-down,

1556
01:09:23,020 --> 01:09:24,500
and if I try to touch on them,

1557
01:09:24,500 --> 01:09:27,280
I'm currently clicking
on these repeatedly,

1558
01:09:27,280 --> 01:09:29,940
they don't turn back up because
they're already matched.

1559
01:09:29,940 --> 01:09:32,140
And we ignore cards that
are already matched.

1560
01:09:32,140 --> 01:09:35,510
But this is not very good UI
to have these face-down cards

1561
01:09:35,510 --> 01:09:37,923
that you can't touch on, it does nothing.

1562
01:09:37,923 --> 01:09:40,520
I really wanna take these away.

1563
01:09:40,520 --> 01:09:43,250
So if they're matched,
I'm gonna take them away.

1564
01:09:43,250 --> 01:09:46,340
So let's go back to our UI and do that.

1565
01:09:46,340 --> 01:09:48,200
Here's our CardView.

1566
01:09:48,200 --> 01:09:51,380
And here's where the cards
are face-up, no problem there.

1567
01:09:51,380 --> 01:09:53,150
Here's where they're face-down.

1568
01:09:53,150 --> 01:09:56,530
I'm gonna say if the Card is not matched,

1569
01:09:56,530 --> 01:09:58,720
then I'll draw it.

1570
01:09:58,720 --> 01:10:00,910
But if it is matched and it's face-down,

1571
01:09:58,720 --> 01:10:00,910
But if it is matched and it's face-down,

1572
01:10:00,910 --> 01:10:02,600
I'm gonna draw nothing.

1573
01:10:02,600 --> 01:10:04,350
Again, this is ViewBuilder.

1574
01:10:04,350 --> 01:10:05,570
It's got these simple ifs.

1575
01:10:05,570 --> 01:10:08,640
You can even nest these
ifs inside the elses

1576
01:10:08,640 --> 01:10:10,660
or inside the ifs of other ifs.

1577
01:10:10,660 --> 01:10:12,200
Nested ifs are okay.

1578
01:10:12,200 --> 01:10:14,350
And notice we don't
even need an else here.

1579
01:10:14,350 --> 01:10:16,523
ViewBuilder knows how
to deal with the fact

1580
01:10:16,523 --> 01:10:20,590
that the if didn't happen, and
so nothing is gonna be here.

1581
01:10:20,590 --> 01:10:21,980
Essentially there's an empty View.

1582
01:10:21,980 --> 01:10:25,570
And in fact in SwiftUI, there
is a View called EmptyView.

1583
01:10:25,570 --> 01:10:27,930
So that's what this
ViewBuilder is going to make

1584
01:10:27,930 --> 01:10:30,280
for ZStack in the case
the Cards are face-down.

1585
01:10:31,886 --> 01:10:33,183
See if that fixes that.

1586
01:10:35,273 --> 01:10:38,757
And we get pumpkin, spider, ghost.

1587
01:10:39,940 --> 01:10:41,690
Oh, got a match, ready?

1588
01:10:41,690 --> 01:10:43,840
Woo, it took them away.

1589
01:10:43,840 --> 01:10:46,520
Another match, takes those away.

1590
01:10:46,520 --> 01:10:47,920
Okay, this is excellent.

1591
01:10:47,920 --> 01:10:51,197
Our game is basically
functioning beautifully.

1592
01:10:51,197 --> 01:10:54,370
So one last thing I wanna
do, though, to my Model.

1593
01:10:54,370 --> 01:10:57,430
I'm a little concerned
that I have this state,

1594
01:10:57,430 --> 01:10:59,690
the indexOfTheOneAndOnlyFaceUpCard,

1595
01:10:59,690 --> 01:11:01,660
that I'm having to keep in sync

1596
01:11:01,660 --> 01:11:04,410
with my changes to the Cards.

1597
01:11:04,410 --> 01:11:07,720
And this is kind of an
error-prone way to program

1598
01:11:07,720 --> 01:11:09,960
when you have state in two places.

1599
01:11:09,960 --> 01:11:13,000
The indexOfTheOneAndOnlyFaceUpCard
is here,

1600
01:11:13,000 --> 01:11:16,820
and it's also determinable
from these Cards.

1601
01:11:16,820 --> 01:11:20,160
So, let's use a computed var here instead

1602
01:11:20,160 --> 01:11:25,160
and get from the Cards the
indexOfTheOneAndOnlyFaceUpCard.

1603
01:11:25,270 --> 01:11:28,490
And we're also going to do here a set

1604
01:11:28,490 --> 01:11:32,070
so that if someone sets the
indexOfTheOneAndOnlyFaceUpCard,

1605
01:11:32,070 --> 01:11:35,030
we turn all the other Cards face-down.

1606
01:11:35,030 --> 01:11:37,220
This is the first time you've
seen a computed property

1607
01:11:37,220 --> 01:11:38,860
that we can get the value of,

1608
01:11:38,860 --> 01:11:41,553
but we can also set the value of.

1609
01:11:42,760 --> 01:11:45,230
Let's do the set one first.

1610
01:11:45,230 --> 01:11:48,170
It's kind of the simpler of the two.

1611
01:11:48,170 --> 01:11:51,060
How are we going to react when someone

1612
01:11:51,060 --> 01:11:56,060
sets the value of the
indexOfTheOneAndOnlyFaceUpCard?

1613
01:11:56,160 --> 01:11:58,020
Well in that case, we need to go through

1614
01:11:58,020 --> 01:11:59,420
all of our Cards.

1615
01:11:59,420 --> 01:12:02,350
I'm just gonna go
through our indices here.

1616
01:12:02,350 --> 01:12:07,233
And I'm gonna pretty much set
all the Cards to be face-down.

1617
01:12:09,070 --> 01:12:11,550
Except I don't wanna do that

1618
01:12:11,550 --> 01:12:13,530
if this is the one that you said

1619
01:12:13,530 --> 01:12:16,180
was the indexOfTheOneAndOnlyFaceUpCard.

1620
01:12:16,180 --> 01:12:20,670
Inside this set, there's a
special variable called newValue.

1621
01:12:20,670 --> 01:12:23,353
So I can tell you if
index equals newValue,

1622
01:12:25,870 --> 01:12:28,730
the value that the person
said this was equal to,

1623
01:12:28,730 --> 01:12:31,070
then it's face-up.

1624
01:12:31,070 --> 01:12:33,300
So newValue is the special var,

1625
01:12:33,300 --> 01:12:37,850
only appears inside this
set for a computed property.

1626
01:12:37,850 --> 01:12:40,200
And it's whatever the people set this to.

1627
01:12:40,200 --> 01:12:41,550
Could be nil, by the way.

1628
01:12:41,550 --> 01:12:44,770
This newValue, it's an
Optional, so it could be nil.

1629
01:12:44,770 --> 01:12:48,410
Index is an Int, and Int is never equal to

1630
01:12:48,410 --> 01:12:50,140
an Optional that's not set,

1631
01:12:50,140 --> 01:12:52,420
so this equals would only be true

1632
01:12:52,420 --> 01:12:54,140
if this is an Optional that's set

1633
01:12:54,140 --> 01:12:57,563
and its associated integer
matches this integer

1634
01:12:59,040 --> 01:13:01,720
So that's it for set, pretty simple.

1635
01:13:01,720 --> 01:13:03,720
What about getting?

1636
01:13:03,720 --> 01:13:06,520
Well, to get it, I really
need to look at all the Cards

1637
01:13:06,520 --> 01:13:08,030
and see which ones are face-up

1638
01:13:08,030 --> 01:13:09,620
and see if there's only one.

1639
01:13:09,620 --> 01:13:12,840
So let's start by getting
all the face-up Cards.

1640
01:13:12,840 --> 01:13:15,820
So I'm gonna say faceUpCardIndices.

1641
01:13:15,820 --> 01:13:18,440
It's gonna be an Array of Int.

1642
01:13:18,440 --> 01:13:21,170
By the way, I'm gonna use
this syntax right here

1643
01:13:21,170 --> 01:13:22,670
to mean Array of Int.

1644
01:13:22,670 --> 01:13:26,650
This is exactly the same as Array of Int.

1645
01:13:26,650 --> 01:13:28,900
I'm gonna say that out in the real world,

1646
01:13:28,900 --> 01:13:33,000
this is actually slightly
preferred as the syntax.

1647
01:13:33,000 --> 01:13:35,510
Not 100% sure of that,
but it sure seems to me

1648
01:13:35,510 --> 01:13:37,950
people prefer this over Array of Int.

1649
01:13:37,950 --> 01:13:39,100
I like Array of Int.

1650
01:13:39,100 --> 01:13:41,180
It's clearer that that's a generic,

1651
01:13:41,180 --> 01:13:43,880
and the don't-care is Int and all that,

1652
01:13:43,880 --> 01:13:47,340
but Arrays are extremely common to use,

1653
01:13:47,340 --> 01:13:49,853
so I can understand the shorthand there.

1654
01:13:50,740 --> 01:13:53,490
So now, how am I gonna get
this faceUpCardIndices?

1655
01:13:53,490 --> 01:13:55,060
It's starting empty right there,

1656
01:13:55,060 --> 01:13:59,610
so I'm gonna go for
index in cards.indices,

1657
01:13:59,610 --> 01:14:01,260
go through all my Cards.

1658
01:14:01,260 --> 01:14:05,840
If a Card at a certain index is face-up,

1659
01:14:05,840 --> 01:14:09,368
then I'm gonna put it in
the faceUpCardIndices,

1660
01:14:09,368 --> 01:14:11,110
append that index.

1661
01:14:11,110 --> 01:14:14,690
All right, now I have all
the face-up Card indices.

1662
01:14:14,690 --> 01:14:19,470
I'm gonna say if the
faceUpCardIndices.count equals one,

1663
01:14:19,470 --> 01:14:21,313
so one and only one Card,

1664
01:14:21,313 --> 01:14:26,313
then I'm gonna return that
faceUpCardIndices sub zero.

1665
01:14:26,420 --> 01:14:28,550
By the way, there's another
nice little var for that,

1666
01:14:28,550 --> 01:14:30,340
which is .first.

1667
01:14:30,340 --> 01:14:31,930
And when we're typing first,

1668
01:14:31,930 --> 01:14:34,960
notice that its return type of this var,

1669
01:14:34,960 --> 01:14:38,560
or the type of this var,
is Int, question mark,

1670
01:14:38,560 --> 01:14:39,960
Optional Int, why?

1671
01:14:39,960 --> 01:14:42,410
Because the Array might be empty.

1672
01:14:42,410 --> 01:14:44,740
So if you say your Array.first,
and the Array is empty,

1673
01:14:44,740 --> 01:14:46,840
this will return nil.

1674
01:14:46,840 --> 01:14:49,973
There's Swift using Optionals
to communicate something.

1675
01:14:51,220 --> 01:14:53,810
Otherwise, I'm gonna return nil.

1676
01:14:53,810 --> 01:14:57,210
Because if there's not exactly one Card

1677
01:14:57,210 --> 01:15:00,520
in the face-up Card list, then obviously,

1678
01:15:00,520 --> 01:15:03,683
the indexOfTheOneAndOnlyFaceUpCard
is nil, and that's it.

1679
01:15:05,500 --> 01:15:07,290
So now that this is calculated,

1680
01:15:07,290 --> 01:15:10,750
I don't have to work so hard
to make sure it's kept in sync.

1681
01:15:10,750 --> 01:15:13,860
For example, in here, I
don't even need to say

1682
01:15:13,860 --> 01:15:16,480
that the
indexOfTheOneAndOnlyFaceUpCard is nil.

1683
01:15:16,480 --> 01:15:18,240
Just get rid of that code altogether

1684
01:15:18,240 --> 01:15:20,370
because it's always going to know

1685
01:15:20,370 --> 01:15:22,040
when there's two face-up Cards.

1686
01:15:22,040 --> 01:15:23,700
It calculates it.

1687
01:15:23,700 --> 01:15:26,520
Kinda similarly down here, because I set

1688
01:15:26,520 --> 01:15:29,500
the one and only face-up
Card to be this index,

1689
01:15:29,500 --> 01:15:32,230
I don't need to set all
the rest of them face-down.

1690
01:15:32,230 --> 01:15:35,333
That's gonna be automatically
done by the setter of this.

1691
01:15:36,250 --> 01:15:38,810
And also, this true of turning it face-up,

1692
01:15:38,810 --> 01:15:41,910
we only need to do in here because again,

1693
01:15:41,910 --> 01:15:44,048
setting the indexOfTheOneAndOnlyFaceUpCard

1694
01:15:44,048 --> 01:15:48,631
is going to make sure that
this chosenIndex is face-up.

1695
01:15:49,469 --> 01:15:52,340
So that makes this code
really pretty minimal

1696
01:15:52,340 --> 01:15:54,360
to play an entire card-matching game.

1697
01:15:54,360 --> 01:15:57,567
Now that's at the expense
of a lot of code up here.

1698
01:15:57,567 --> 01:15:59,250
And we're gonna fix that in a second,

1699
01:15:59,250 --> 01:16:02,623
but let's make sure that
this has not broken anything.

1700
01:16:03,650 --> 01:16:04,520
Here we go.

1701
01:16:04,520 --> 01:16:08,840
Pumpkin, spider, spider,
spider, pumpkin, all right.

1702
01:16:08,840 --> 01:16:12,930
Ghost, no, pumpkin, ghost,
ghost, ghost, pumpkin.

1703
01:16:12,930 --> 01:16:14,630
So this is working.

1704
01:16:14,630 --> 01:16:16,980
Beautiful looking code right here.

1705
01:16:16,980 --> 01:16:20,500
Little bit more code here than we need.

1706
01:16:20,500 --> 01:16:23,693
So how can we reduce this code a bit?

1707
01:16:24,600 --> 01:16:26,200
Down here, I can only think of one thing

1708
01:16:26,200 --> 01:16:28,700
to make this a little more efficient,

1709
01:16:28,700 --> 01:16:31,580
which is that here I'm
saying if something is true,

1710
01:16:31,580 --> 01:16:34,710
then set this to true, else set it false.

1711
01:16:34,710 --> 01:16:38,273
I could just take this and put it here.

1712
01:16:39,249 --> 01:16:41,910
Then I don't need all
the rest of this overhead

1713
01:16:41,910 --> 01:16:43,723
of the syntax of all this if.

1714
01:16:44,606 --> 01:16:45,860
So I'm just gonna set every Card.

1715
01:16:45,860 --> 01:16:48,220
I'm gonna set it to false unless the index

1716
01:16:48,220 --> 01:16:50,770
is equal to what the person
said this was equal to,

1717
01:16:50,770 --> 01:16:52,070
like I'm doing right here.

1718
01:16:53,344 --> 01:16:54,177
So that's nice.

1719
01:16:54,177 --> 01:16:56,060
That's pretty minimal code.

1720
01:16:56,060 --> 01:16:57,350
What about all this?

1721
01:16:57,350 --> 01:16:59,060
Believe it or not, I'm gonna make it

1722
01:16:59,060 --> 01:17:00,690
so this is one line of code.

1723
01:17:00,690 --> 01:17:03,170
You know we love one line
of code in this class.

1724
01:17:03,170 --> 01:17:05,860
Your first homework
assignment proved that.

1725
01:17:05,860 --> 01:17:08,230
So how am I gonna make
this one line of code?

1726
01:17:08,230 --> 01:17:12,140
I'm gonna start by having
all of this right here

1727
01:17:12,140 --> 01:17:13,930
be one line, and I'm gonna do that

1728
01:17:13,930 --> 01:17:17,530
with a function in a range called filter.

1729
01:17:17,530 --> 01:17:20,930
So I'm gonna take my cards
indices, that's a range

1730
01:17:20,930 --> 01:17:24,370
between zero, dot dot,
less than cards.count.

1731
01:17:24,370 --> 01:17:26,700
And call this function filter.

1732
01:17:26,700 --> 01:17:29,150
You see filter here in range.

1733
01:17:29,150 --> 01:17:31,200
It returns an Array of Int.

1734
01:17:31,200 --> 01:17:33,760
You see on the left here, Array of Int.

1735
01:17:33,760 --> 01:17:37,580
And those Ints are all
the Ints in this range

1736
01:17:37,580 --> 01:17:40,200
where this function that takes an Int

1737
01:17:40,200 --> 01:17:42,293
and returns a bool returns true.

1738
01:17:43,610 --> 01:17:44,443
So it looks like this.

1739
01:17:44,443 --> 01:17:45,910
Let's double-click on this.

1740
01:17:45,910 --> 01:17:46,743
Here it is.

1741
01:17:46,743 --> 01:17:48,630
I can double-click on this even.

1742
01:17:48,630 --> 01:17:50,200
It fills it in for me.

1743
01:17:50,200 --> 01:17:52,880
This is a function, an in-line function,

1744
01:17:52,880 --> 01:17:55,880
that takes an Int and returns a Bool.

1745
01:17:55,880 --> 01:18:00,210
And we're supposed to return
whether to include this Int,

1746
01:18:00,210 --> 01:18:01,853
which is one of the indices,

1747
01:18:02,920 --> 01:18:05,480
in the resulting faceUpCardIndices.

1748
01:18:05,480 --> 01:18:09,080
We're making a new Array by
filtering out these other ones.

1749
01:18:09,080 --> 01:18:13,860
This is what the index is,
so we'll call this index.

1750
01:18:13,860 --> 01:18:14,860
And what do we wanna do?

1751
01:18:14,860 --> 01:18:19,460
We wanna say return Cards at that index,

1752
01:18:19,460 --> 01:18:20,857
dot, isFaceUp.

1753
01:18:22,361 --> 01:18:24,440
So this is all we wanna do.

1754
01:18:24,440 --> 01:18:27,820
Of course, we like to make
things less code in Swift,

1755
01:18:27,820 --> 01:18:31,053
so we can take away this return.

1756
01:18:32,340 --> 01:18:35,113
Maybe we'll put this up here, like this.

1757
01:18:36,990 --> 01:18:39,630
We can infer this return type.

1758
01:18:39,630 --> 01:18:42,913
Don't need that, don't need
these parentheses in there.

1759
01:18:43,770 --> 01:18:45,370
There's another thing I
didn't show you last time

1760
01:18:45,370 --> 01:18:48,400
that we can do to make these even smaller,

1761
01:18:48,400 --> 01:18:51,130
which is that the arguments
are specified here

1762
01:18:51,130 --> 01:18:52,150
with index in.

1763
01:18:52,150 --> 01:18:55,630
You can get rid of that
and just use dollar-zero,

1764
01:18:55,630 --> 01:18:58,330
and dollar-one, and dollar-two
for each of the arguments.

1765
01:18:58,330 --> 01:18:59,670
Dollar-zero for the first argument,

1766
01:18:59,670 --> 01:19:01,970
dollar-one for the second
argument, et cetera.

1767
01:19:02,870 --> 01:19:04,120
So we're almost there.

1768
01:19:04,120 --> 01:19:07,210
This is all gone right here.

1769
01:19:07,210 --> 01:19:11,040
And because we now just
calculate this in one fell swoop,

1770
01:19:11,040 --> 01:19:11,873
we're getting this warning here

1771
01:19:11,873 --> 01:19:15,383
that this can now be a let, which it can.

1772
01:19:16,240 --> 01:19:17,640
How about this?

1773
01:19:17,640 --> 01:19:19,080
How do we get rid of this?

1774
01:19:19,080 --> 01:19:20,030
What's going on here?

1775
01:19:20,030 --> 01:19:23,410
Here we're actually just
saying to the Array of indices,

1776
01:19:23,410 --> 01:19:25,460
if there's only one of you, give it to me.

1777
01:19:25,460 --> 01:19:27,300
Otherwise, give me nil.

1778
01:19:27,300 --> 01:19:29,570
Well, why don't we extend Array,

1779
01:19:29,570 --> 01:19:34,230
using extension to Array, to
have a var that does this?

1780
01:19:34,230 --> 01:19:36,120
'Cause that seems like a
reasonable Array thing.

1781
01:19:36,120 --> 01:19:39,180
Hey Mr. Array, give me the
only thing in yourself,

1782
01:19:39,180 --> 01:19:41,170
otherwise give me nil.

1783
01:19:41,170 --> 01:19:44,563
So let's create another little
extension for Array here.

1784
01:19:45,411 --> 01:19:46,750
Do a Swift file.

1785
01:19:46,750 --> 01:19:49,810
We'll call this one Array+Only

1786
01:19:49,810 --> 01:19:53,350
since it returns the
only thing in an Array.

1787
01:19:53,350 --> 01:19:58,350
And this extension to Array
is gonna extend all Arrays.

1788
01:19:58,630 --> 01:20:01,120
This extension to Array
is not like this one

1789
01:19:58,630 --> 01:20:01,120
This extension to Array
is not like this one

1790
01:20:01,120 --> 01:20:03,300
where it's where Element's Identifiable.

1791
01:20:03,300 --> 01:20:05,530
This one extends to all Arrays.

1792
01:20:05,530 --> 01:20:07,890
It's gonna add this var
I'm gonna call only.

1793
01:20:07,890 --> 01:20:12,290
It's of type Element, question
mark, Optional Element.

1794
01:20:12,290 --> 01:20:15,330
And it's computed, and it
just returns the Array's count

1795
01:20:15,330 --> 01:20:18,133
equals one, first, colon, nil.

1796
01:20:19,060 --> 01:20:22,680
So this is in Array, so count
is the count of the Array.

1797
01:20:22,680 --> 01:20:23,820
And if that equals one,

1798
01:20:23,820 --> 01:20:26,190
we're using this ternary operator here

1799
01:20:26,190 --> 01:20:28,800
to return the first item in the Array.

1800
01:20:28,800 --> 01:20:29,823
Otherwise nil.

1801
01:20:32,140 --> 01:20:34,870
Super simple, and that super simple code

1802
01:20:34,870 --> 01:20:37,310
makes this all go away right here.

1803
01:20:37,310 --> 01:20:39,250
We don't need any of this.

1804
01:20:39,250 --> 01:20:43,077
Instead, we can just
say dot-only over here,

1805
01:20:43,077 --> 01:20:45,500
and get rid of all of this.

1806
01:20:45,500 --> 01:20:47,170
Just return this.

1807
01:20:47,170 --> 01:20:50,770
But since this is now a
one-liner, we don't need return.

1808
01:20:50,770 --> 01:20:53,970
And we can even make
it all be one line here

1809
01:20:53,970 --> 01:20:55,077
like this as well.

1810
01:20:55,077 --> 01:20:59,690
And this code has all of a
sudden gotten a lot more compact.

1811
01:20:59,690 --> 01:21:02,123
So let's make sure we
didn't break anything there.

1812
01:21:03,860 --> 01:21:08,860
Click, yeah, ooh, what, yay, it works.

1813
01:21:09,450 --> 01:21:13,040
Now this has set up this
beautifully for your homework.

1814
01:21:13,040 --> 01:21:16,040
You're going to now take this working game

1815
01:21:16,040 --> 01:21:18,670
and do some enhancements to it.

1816
01:21:18,670 --> 01:21:20,490
So check out the writeup for that.

1817
01:21:20,490 --> 01:21:22,630
And we'll see you next lecture.

1818
01:21:22,630 --> 01:21:25,883
- [Narrator] For more, please
visit us at stanford.edu.

