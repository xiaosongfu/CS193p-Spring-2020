1
00:00:02,330 --> 00:00:04,919
 （音乐照亮） 

2
00:00:04,919 --> 00:00:06,570
 -[旁白]斯坦福大学。 

3
00:00:08,119 --> 00:00:09,799
 -[老师]大家好，欢迎光临， 

4
00:00:09,800 --> 00:00:13,313
斯坦福CS193p 2020年春季。 

5
00:00:13,313 --> 00:00:15,320
这是第三讲。 

6
00:00:15,320 --> 00:00:18,315
我今天将从演示开始， 

7
00:00:18,315 --> 00:00:22,620
我们正在讨论的反应式SwiftUI内容的演示。 

8
00:00:22,620 --> 00:00:24,769
然后我要跳一些幻灯片， 

9
00:00:24,969 --> 00:00:28,269
多说一些Swift类型的系统， 

10
00:00:28,269 --> 00:00:31,769
具体来说就是协议，然后

11
00:00:31,769 --> 00:00:33,619
之后一个完全不同的话题， 

12
00:00:33,619 --> 00:00:36,479
这是视图的布局系统， 

13
00:00:36,479 --> 00:00:39,839
它们如何在屏幕上布置。 

14
00:00:39,840 --> 00:00:42,099
如果时间允许，我实际上会做一些演示

15
00:00:42,299 --> 00:00:44,689
到今天结束时， 

16
00:00:44,689 --> 00:00:47,119
如果没有，它将被推迟到下一次。 

17
00:00:47,119 --> 00:00:50,890
下次我们一定要布置卡片

18
00:00:50,890 --> 00:00:53,320
行和列而不是全部

19
00:00:53,320 --> 00:00:55,890
像现在这样水平排列

20
00:00:55,890 --> 00:00:59,090
我们还将开始实际拥有

21
00:00:59,090 --> 00:01:03,670
我们的模型玩游戏并实现我们的一些逻辑。 

22
00:01:03,670 --> 00:01:06,373
但是现在，让我们来做这个反应式Swift演示。 

23
00:01:07,290 --> 00:01:11,969
希望您现在对MVVM非常熟悉， 

24
00:01:11,969 --> 00:01:13,409
但是在我开始这个演示之前， 

25
00:01:13,409 --> 00:01:15,340
我要花一秒钟

26
00:01:15,340 --> 00:01:18,280
复习一下，以防万一已经几天了

27
00:01:18,280 --> 00:01:19,890
因为你做了功课。 

28
00:01:19,890 --> 00:01:23,359
这是我们的模型，称为MemoryGame。 

29
00:01:23,359 --> 00:01:25,429
它有这个不在乎CardContent 

30
00:01:25,430 --> 00:01:26,759
卡上有什么

31
00:01:26,959 --> 00:01:29,119
作为模型，我们不在乎。 

32
00:01:29,120 --> 00:01:31,079
这取决于用户界面来决定它想要什么

33
00:01:31,079 --> 00:01:34,179
在卡片上显示。 

34
00:01:34,180 --> 00:01:35,400
这是我们的卡。 

35
00:01:35,400 --> 00:01:39,149
这是此Card结构的数组。 

36
00:01:39,349 --> 00:01:43,449
这个选择让我们从本质上玩游戏。 

37
00:01:43,450 --> 00:01:45,310
我们还没有实现

38
00:01:45,310 --> 00:01:46,519
但是当您选择一张卡时， 

39
00:01:46,519 --> 00:01:50,119
那就是匹配发生的时间，诸如此类。 

40
00:01:50,120 --> 00:01:54,369
这是我们初始化或创建MemoryGame的方法。 

41
00:01:54,569 --> 00:01:56,109
我们显然想指定

42
00:01:56,109 --> 00:01:58,359
我们的游戏中有几副牌， 

43
00:01:58,359 --> 00:02:01,370
我们需要一个cardContentFactory函数

44
00:02:01,370 --> 00:02:03,500
制作卡片上的内容

45
00:02:03,500 --> 00:02:05,569
因为对我们来说，这不在乎。 

46
00:02:05,569 --> 00:02:08,852
因此，需要照顾的人必须为我们做到这一点。 

47
00:02:09,830 --> 00:02:11,930
这是我们的ViewModel。 

48
00:02:12,129 --> 00:02:15,669
我们的ViewModel有一个var，即Model。 

49
00:02:15,669 --> 00:02:18,829
我们的ViewModel可以一次与模型对话。 

50
00:02:18,830 --> 00:02:22,469
它是视图模型的门户或门口

51
00:02:22,669 --> 00:02:25,019
因此它必须能够做到这一点。 

52
00:02:25,020 --> 00:02:29,370
请注意，这里没有指向视图的变量。 

53
00:02:29,370 --> 00:02:32,689
 ViewModel从不与其视图对话。 

54
00:02:32,689 --> 00:02:35,599
与ViewModel对话的是View。 

55
00:02:35,599 --> 00:02:37,826
我们将看看

56
00:02:37,826 --> 00:02:41,819
和ViewModel互动，只需片刻

57
00:02:41,819 --> 00:02:44,269
但永远不会有任何连接

58
00:02:44,270 --> 00:02:45,969
从ViewModel到Views 

59
00:02:45,969 --> 00:02:47,889
因为很多很多不同的观点

60
00:02:47,889 --> 00:02:50,179
将使用此ViewModel，此门户， 

61
00:02:50,180 --> 00:02:52,280
这个门口，进入模型。 

62
00:02:52,280 --> 00:02:54,240
他们将使用它，共享它。 

63
00:02:54,240 --> 00:02:56,710
同样，这就是为什么我们的ViewModel是一个类。 

64
00:02:56,710 --> 00:02:58,710
它是指向堆中某物的指针。 

65
00:02:58,710 --> 00:03:01,689
分享指向的内容很容易。 

66
00:03:01,889 --> 00:03:06,399
因此，我们的ViewModel还提供了对模型的公共访问

67
00:03:06,400 --> 00:03:08,710
否则是私有的。 

68
00:03:08,710 --> 00:03:11,250
而且访问都在获取信息， 

69
00:03:11,250 --> 00:03:12,449
喜欢拿卡

70
00:03:12,449 --> 00:03:16,409
并让视图表达其意图，在这种情况下， 

71
00:03:16,409 --> 00:03:18,479
选择一张卡。 

72
00:03:18,479 --> 00:03:21,659
两者都非常容易通过我们的模型实施

73
00:03:21,659 --> 00:03:24,629
但这就是我们的ViewModels工作。 

74
00:03:24,629 --> 00:03:26,689
最后，我们有自己的观点。 

75
00:03:26,689 --> 00:03:31,689
在MVVM视图意义上，我们的视图中有两个视图。 

76
00:03:32,349 --> 00:03:35,079
一个是代表一张卡片的视图

77
00:03:35,080 --> 00:03:39,210
然后是此视图，这是我们在此处组合的所有卡。 

78
00:03:39,210 --> 00:03:42,379
根据我得到的反馈

79
00:03:42,379 --> 00:03:43,430
你们中的一些人

80
00:03:43,430 --> 00:03:44,689
在本周的家庭作业中， 

81
00:03:44,889 --> 00:03:48,879
我想澄清一点，我们的想法

82
00:03:48,879 --> 00:03:53,019
通过澄清我们用来描述事物的词语。 

83
00:03:53,020 --> 00:03:56,157
你们当中有些人在说

84
00:03:56,157 --> 00:03:57,826
 “哦，我正在使用此功能

85
00:03:58,026 --> 00:04:03,026
 “设置卡的字体。” 

86
00:04:03,069 --> 00:04:07,616
虽然我认为这是不正确的， 

87
00:04:09,479 --> 00:04:11,829
真的更好的说法是

88
00:04:11,830 --> 00:04:16,830
这个功能在这里修改了我们发送给它的视图

89
00:04:17,149 --> 00:04:21,229
以便使用此字体进行绘制。 

90
00:04:21,230 --> 00:04:22,699
那有什么区别？ 

91
00:04:22,899 --> 00:04:26,099
嗯，这是声明式编程之间的区别

92
00:04:26,100 --> 00:04:28,129
和命令式编程。 

93
00:04:28,129 --> 00:04:31,980
在声明中，我们只是声明这是字体

94
00:04:31,980 --> 00:04:34,910
用于绘制此视图， 

95
00:04:34,910 --> 00:04:38,069
而当务之急是，您在想诸如此类的事情， 

96
00:04:38,269 --> 00:04:41,740
我正在调用此函数来设置字体

97
00:04:41,740 --> 00:04:44,387
在某个时刻，我正在设置它。 

98
00:04:44,387 --> 00:04:47,769
并且没有及时使用此声明。 

99
00:04:47,769 --> 00:04:51,659
在任何时候，这应该绘制视图

100
00:04:51,660 --> 00:04:53,980
反映模型，它应该能够

101
00:04:53,980 --> 00:04:58,189
随时要求该机构这样做。 

102
00:04:58,189 --> 00:05:00,719
景气，应该是一个视图

103
00:05:00,720 --> 00:05:03,000
反映了模型的状态， 

104
00:05:03,000 --> 00:05:04,603
本质上对时间不敏感。 

105
00:05:05,579 --> 00:05:08,719
关于这个身体的另一件事是这个变种， 

106
00:05:08,720 --> 00:05:11,850
您永远不会访问此变量。 

107
00:05:11,850 --> 00:05:15,480
下半身永远不会出现在您的代码中。 

108
00:05:15,480 --> 00:05:18,629
该主体由系统调用。 

109
00:05:18,829 --> 00:05:20,639
每当系统想要

110
00:05:20,639 --> 00:05:24,639
绘制一个表示该模型的视图， 

111
00:05:24,639 --> 00:05:28,129
它将调用此变量以获取该视图。 

112
00:05:28,129 --> 00:05:29,659
因此，这由系统调用。 

113
00:05:29,660 --> 00:05:33,449
您的工作是通过声明实现它

114
00:05:33,649 --> 00:05:36,702
为视图提供了模型的当前状态

115
00:05:36,702 --> 00:05:40,529
通过该门户ViewModel看到的

116
00:05:40,529 --> 00:05:42,799
我想说的最后一件事是

117
00:05:42,800 --> 00:05:46,920
有些人在这些ViewBuilder中

118
00:05:46,920 --> 00:05:51,560
例如在ForEach中，甚至在ZStack或HStack中。 

119
00:05:51,560 --> 00:05:54,860
记住这些是ViewBuilders，而ViewBuilders很酷

120
00:05:54,860 --> 00:05:57,810
因为它们是返回View的函数

121
00:05:57,810 --> 00:06:00,339
而且他们确实允许这种限制

122
00:06:00,339 --> 00:06:03,409
并且它们允许您仅列出视图而不是

123
00:06:03,410 --> 00:06:06,177
将它们放入数组或其他内容中，您可以列出它们。 

124
00:06:06,177 --> 00:06:08,800
人们想在这里放一个变种， 

125
00:06:08,800 --> 00:06:11,319
 var x在这里等于某物。 

126
00:06:11,319 --> 00:06:13,209
当然，您不能创建var 

127
00:06:13,209 --> 00:06:14,592
在ViewBuilder中。 

128
00:06:15,439 --> 00:06:19,269
无法在这些ViewBuilder中创建变量， 

129
00:06:19,269 --> 00:06:21,569
只是不允许创建var。 

130
00:06:21,569 --> 00:06:22,740
你是怎么做到的？ 

131
00:06:22,740 --> 00:06:23,970
有两种方法可以做到这一点。 

132
00:06:23,970 --> 00:06:27,060
第一，您可以将vars放在ViewBuilders之外， 

133
00:06:27,060 --> 00:06:29,329
只是在正常的功能上

134
00:06:29,329 --> 00:06:33,000
然后我可以在这里使用x 

135
00:06:33,000 --> 00:06:34,269
但是如果我现在就这样做， 

136
00:06:34,269 --> 00:06:35,519
我已经创建了这两行， 

137
00:06:35,519 --> 00:06:38,339
我不得不说返回ZStack， 

138
00:06:38,339 --> 00:06:40,659
没关系，我可以做到。 

139
00:06:40,660 --> 00:06:42,930
另一种方法，也许是更常见的方法

140
00:06:42,930 --> 00:06:46,980
是创建另一个，假设这是一个Int， 

141
00:06:46,980 --> 00:06:49,579
计算属性，然后返回任何内容

142
00:06:49,779 --> 00:06:51,219
您希望x为的值

143
00:06:51,220 --> 00:06:52,740
现在您可以在这里使用x 

144
00:06:52,740 --> 00:06:55,519
它将仅使用此计算属性

145
00:06:55,519 --> 00:06:58,289
计算它想要的x的值。 

146
00:06:58,290 --> 00:07:00,160
这就是我们处理的方式

147
00:07:00,160 --> 00:07:03,509
基本创建局部变量

148
00:07:03,709 --> 00:07:08,709
或我们在此处绘制所需的变量。 

149
00:07:09,029 --> 00:07:12,449
顺便说一下，这目前称为ContentView 

150
00:07:12,449 --> 00:07:15,110
因为那是我们开始的地方

151
00:07:15,110 --> 00:07:17,286
使用Xcode中的模板。 

152
00:07:17,286 --> 00:07:20,610
 Xcode当时不知道我们在做一个记忆游戏

153
00:07:20,610 --> 00:07:22,509
因此将其称为ContentView。 

154
00:07:22,509 --> 00:07:23,779
在我们开始之前就想过

155
00:07:23,779 --> 00:07:25,939
我会告诉你如何重命名

156
00:07:25,939 --> 00:07:29,110
成为一个更好的名字。 

157
00:07:29,110 --> 00:07:31,790
现在您可能会想在导航器中执行此操作

158
00:07:31,790 --> 00:07:35,629
使用此处的搜索和替换功能。 

159
00:07:35,829 --> 00:07:38,199
您可以通过替换此处来做到这一点， 

160
00:07:38,199 --> 00:07:40,979
然后您可以搜索例如ContentView 

161
00:07:42,757 --> 00:07:44,969
它会找到它所引用的所有地方， 

162
00:07:44,970 --> 00:07:46,000
那么你可以更换它

163
00:07:46,000 --> 00:07:48,927
带有EmojiMemoryGameView之类的东西

164
00:07:49,829 --> 00:07:51,339
或类似的东西。 

165
00:07:51,339 --> 00:07:54,669
但是实际上，这不是我们要做的。 

166
00:07:54,670 --> 00:07:58,500
如果我们要更改var或类型的名称， 

167
00:07:58,500 --> 00:08:01,029
我们将使用重构。 

168
00:08:01,029 --> 00:08:03,329
所以我们要做的就是压低

169
00:08:03,329 --> 00:08:07,091
 Command键，Command +单击。 

170
00:08:07,091 --> 00:08:09,329
当我们按Command +单击时，我们会在这里得到这个漂亮的菜单

171
00:08:09,329 --> 00:08:11,199
我们可以跳到定义

172
00:08:11,199 --> 00:08:14,339
类型或var之类的东西。 

173
00:08:14,339 --> 00:08:15,612
我们也可以重命名。 

174
00:08:16,454 --> 00:08:19,930
所以我们执行Command +单击，然后我们将重命名。 

175
00:08:19,930 --> 00:08:22,290
它向我们展示了所有地方

176
00:08:22,290 --> 00:08:24,000
它发现了ContentView， 

177
00:08:24,199 --> 00:08:27,009
本质上与我们在此处进行搜索相同。 

178
00:08:27,009 --> 00:08:28,550
其中一些会改变， 

179
00:08:28,550 --> 00:08:31,319
你可以用这个小勾号告诉

180
00:08:31,319 --> 00:08:32,779
事情只会改变。 

181
00:08:32,779 --> 00:08:35,850
因此，它将更改此文件名， 

182
00:08:35,850 --> 00:08:38,009
因此，它将要更改其名称，这很好。 

183
00:08:38,009 --> 00:08:41,539
这里显示了评论ContentView 

184
00:08:41,539 --> 00:08:42,860
但这不会改变。 

185
00:08:42,860 --> 00:08:44,730
您会看到它不是蓝色，而是灰色。 

186
00:08:44,730 --> 00:08:46,019
只是说，我发现了这个， 

187
00:08:46,019 --> 00:08:48,529
但我不会改变，因为我不确定

188
00:08:48,529 --> 00:08:50,709
那真的是指这种类型

189
00:08:50,710 --> 00:08:51,750
因为它在评论中

190
00:08:51,750 --> 00:08:54,220
所以我们必须自己改变它。 

191
00:08:54,220 --> 00:08:57,100
这个var preViews将会在这里改变。 

192
00:08:57,100 --> 00:08:59,889
那实际上是我们滚开的代码

193
00:08:59,889 --> 00:09:03,259
一开始显示我们的ContentView 

194
00:09:03,259 --> 00:09:05,590
在此处的灰色preView窗口中， 

195
00:09:05,590 --> 00:09:07,570
因此显然需要进行更改。 

196
00:09:07,570 --> 00:09:09,939
这是场景委托中的代码

197
00:09:10,139 --> 00:09:12,730
我们实际上在创建记忆游戏的地方

198
00:09:12,730 --> 00:09:16,850
然后将其传递到此顶级ContentView中。 

199
00:09:16,850 --> 00:09:20,120
因此，当您执行此Command +单击并重命名时， 

200
00:09:20,120 --> 00:09:23,220
它实际上选择了Command +单击的内容

201
00:09:23,220 --> 00:09:24,740
您可以输入新内容。 

202
00:09:24,740 --> 00:09:29,740
所以EmojiMemoryGameView，看看，它正在改变它

203
00:09:30,340 --> 00:09:32,840
在所有其他地方，虽然不在这里。 

204
00:09:32,840 --> 00:09:33,673
就是这样。 

205
00:09:33,673 --> 00:09:35,799
所以你就在这里点击这个重命名

206
00:09:35,799 --> 00:09:37,399
它已重命名，甚至是名称

207
00:09:37,399 --> 00:09:40,399
此处文件的名称已重命名。 

208
00:09:40,399 --> 00:09:43,069
我们可以回去修复这些东西

209
00:09:43,070 --> 00:09:46,210
不确定，例如此处的评论， 

210
00:09:46,210 --> 00:09:50,980
说，这是我们的EmojiMemoryGameView.swift 

211
00:09:50,980 --> 00:09:53,469
实际上就是该文件的名称。 

212
00:09:53,669 --> 00:09:56,509
所以这只是重命名的一小部分

213
00:09:56,509 --> 00:09:59,289
因为有时您会为类型或变量选择一个名称

214
00:09:59,289 --> 00:10:00,639
然后你会决定， 

215
00:10:00,639 --> 00:10:02,360
我真的不喜欢那个名字，不是， 

216
00:10:02,360 --> 00:10:05,190
因为命名真的非常非常重要。 

217
00:10:05,190 --> 00:10:06,729
不能过分强调它的重要性

218
00:10:06,929 --> 00:10:08,879
为事物取好名字。 

219
00:10:08,879 --> 00:10:11,879
因此，当您改变主意后能够重命名， 

220
00:10:11,879 --> 00:10:13,409
非常非常重要

221
00:10:13,409 --> 00:10:17,449
但是，今天我们的话题将是这种反应。 

222
00:10:17,450 --> 00:10:19,690
我告诉你SwiftUI是反应式的。 

223
00:10:19,690 --> 00:10:21,729
反应是什么意思？ 

224
00:10:21,929 --> 00:10:24,129
我的意思是，当模型发生变化时， 

225
00:10:24,129 --> 00:10:28,429
它们将自动显示在“视图”中。 

226
00:10:28,429 --> 00:10:32,269
目前，我们的用户界面还没有反应。 

227
00:10:32,269 --> 00:10:33,779
所以这是一个问题。 

228
00:10:33,779 --> 00:10:37,149
让我们看看如何解决该问题

229
00:10:37,149 --> 00:10:38,819
并使其具有反应性。 

230
00:10:38,820 --> 00:10:42,609
我们不会在这里实现整个记忆游戏

231
00:10:42,809 --> 00:10:44,059
与所有匹配的卡片。 

232
00:10:44,059 --> 00:10:45,879
我们只是要向前迈出一步

233
00:10:45,879 --> 00:10:48,620
这就是我们要使卡片翻转的原因。 

234
00:10:48,620 --> 00:10:50,960
这是我们模型的一部分。 

235
00:10:50,960 --> 00:10:54,820
本质上，我们游戏逻辑的第一步是

236
00:10:54,820 --> 00:10:57,220
拥有卡片，当我们选择卡片时，翻转过来。 

237
00:10:57,220 --> 00:10:59,779
所以我已经移到了我的模型代码

238
00:10:59,779 --> 00:11:03,319
目前我们只说选择的卡片

239
00:11:03,320 --> 00:11:04,879
记得从上次开始。 

240
00:11:04,879 --> 00:11:07,889
现在我想开始实际实现我的游戏逻辑

241
00:11:07,889 --> 00:11:09,773
首先将卡翻转过来。 

242
00:11:11,029 --> 00:11:14,569
现在，您将对此进行查看，您会认为，哦，这很容易。 

243
00:11:14,570 --> 00:11:19,570
 Card.isFaceUp等于！card.isFaceUp，对吗？ 

244
00:11:20,789 --> 00:11:22,929
有人通过我们的卡

245
00:11:22,929 --> 00:11:25,009
他们想选择一个参数

246
00:11:25,009 --> 00:11:28,620
我只是要面对它

247
00:11:28,620 --> 00:11:32,720
在这里被切换或翻转为相反方向。 

248
00:11:32,720 --> 00:11:36,067
这有一个错误是

249
00:11:36,067 --> 00:11:39,259
 “无法分配给属性。'卡'是'let'常量。” 

250
00:11:39,259 --> 00:11:42,309
这都是争论

251
00:11:42,309 --> 00:11:44,809
功能本质上是让。 

252
00:11:44,809 --> 00:11:47,069
您不键入该让，但它们是一个让。 

253
00:11:47,070 --> 00:11:49,220
这是一个问题。 

254
00:11:49,220 --> 00:11:51,759
但这实际上比这糟得多。 

255
00:11:51,759 --> 00:11:54,850
这不只是让它出租。 

256
00:11:54,850 --> 00:11:56,850
这是一张卡。 

257
00:11:56,850 --> 00:11:58,769
卡是一种结构。 

258
00:11:58,769 --> 00:12:03,769
结构是我们上次谈到的值类型。 

259
00:12:04,480 --> 00:12:07,860
记住，复制了一个值类型

260
00:12:07,860 --> 00:12:10,379
每次将其作为参数传递给函数时

261
00:12:10,379 --> 00:12:13,409
甚至分配给另一个变量副本，副本，副本。 

262
00:12:13,409 --> 00:12:14,949
它总是被复制。 

263
00:12:14,950 --> 00:12:19,589
所以这里的这张卡是这里一张卡的副本。 

264
00:12:19,789 --> 00:12:24,169
新的ViewModel将其获取或分发给View 

265
00:12:24,169 --> 00:12:26,629
当视图获得时，它就是副本， 

266
00:12:26,629 --> 00:12:28,429
甚至一个副本。 

267
00:12:28,429 --> 00:12:31,819
所以这实际上不是阵列中的Card， 

268
00:12:31,820 --> 00:12:33,599
这是一个副本。 

269
00:12:33,799 --> 00:12:37,819
每次我们传递值类型时，它都会被复制。 

270
00:12:37,820 --> 00:12:39,570
所以即使我们可以做到

271
00:12:39,570 --> 00:12:41,109
因为那个问题我们不能

272
00:12:41,309 --> 00:12:43,739
基本上所有这些都是让

273
00:12:43,740 --> 00:12:45,500
无论如何，这不会做对的事情。 

274
00:12:45,500 --> 00:12:48,019
这只会改变这个人

275
00:12:48,019 --> 00:12:51,549
最多可以交换的空间无效

276
00:12:51,549 --> 00:12:53,309
就在这里

277
00:12:53,309 --> 00:12:55,819
因此，让我们在这里尝试完全不同的东西。 

278
00:12:55,820 --> 00:12:59,329
让我们尝试找出索引

279
00:12:59,529 --> 00:13:03,376
该卡在此阵列中的哪张卡。 

280
00:13:03,376 --> 00:13:06,719
我要说的是letedIndex， 

281
00:13:06,720 --> 00:13:08,599
这将是Int类型， 

282
00:13:08,799 --> 00:13:12,429
我等于，我要对自己调用一个函数， 

283
00:13:12,429 --> 00:13:15,329
该卡的索引。 

284
00:13:15,330 --> 00:13:18,109
所以索引我要写一个函数， 

285
00:13:18,109 --> 00:13:21,090
这将是这张卡的功能。 

286
00:13:21,090 --> 00:13:22,990
所以我要找到这张卡

287
00:13:22,990 --> 00:13:25,611
找出它在此数组中的索引。 

288
00:13:25,611 --> 00:13:29,679
因此，您具有的func索引将成为类型Card， 

289
00:13:29,679 --> 00:13:33,259
它会返回一个Int，而这个Int正在

290
00:13:33,259 --> 00:13:35,909
成为该数组的索引。 

291
00:13:35,909 --> 00:13:39,319
现在也许我会说让letedCard， 

292
00:13:39,320 --> 00:13:41,230
这将是类型卡

293
00:13:41,230 --> 00:13:46,173
在那个selectedIndex等于我的牌。 

294
00:13:47,149 --> 00:13:47,990
这听起来不错。 

295
00:13:47,990 --> 00:13:51,129
现在我可以说现在让我们翻转卡片， 

296
00:13:51,129 --> 00:13:55,062
 isFaceUp等于！chosenCard.isFaceUp。 

297
00:13:59,070 --> 00:14:01,320
所以这似乎是个好主意， 

298
00:14:01,320 --> 00:14:02,729
我们将在一分钟内实现它， 

299
00:14:02,929 --> 00:14:04,870
但这似乎很棒。 

300
00:14:04,870 --> 00:14:08,480
现在，我们从阵列中取出卡

301
00:14:08,480 --> 00:14:10,740
我们将其翻转过来。 

302
00:14:10,740 --> 00:14:15,480
但这也不会出于完全相同的原因而起作用。 

303
00:14:15,480 --> 00:14:20,330
当我们分配一个变种给这个选择的卡片时， 

304
00:14:20,330 --> 00:14:24,970
这等于将其复制到此处。 

305
00:14:24,970 --> 00:14:27,639
它将卡从阵列中复制出来。 

306
00:14:27,639 --> 00:14:29,990
所以即使只是做一个作业

307
00:14:29,990 --> 00:14:34,519
到另一个变量将复制值类型。 

308
00:14:34,519 --> 00:14:35,919
所以现在您可能会喜欢， 

309
00:14:35,919 --> 00:14:38,579
我们要如何改变这个东西？ 

310
00:14:38,580 --> 00:14:41,090
好吧，我们必须对其进行更改。 

311
00:14:41,090 --> 00:14:44,610
而不是在这里更改此副本， 

312
00:14:44,610 --> 00:14:46,899
我们将要更改此数组本身， 

313
00:14:46,899 --> 00:14:49,779
这一系列的卡片，我们将到达那里

314
00:14:49,779 --> 00:14:52,339
并更改正确的卡

315
00:14:52,340 --> 00:14:53,947
成为不同的FaceUp。 

316
00:14:55,009 --> 00:14:56,210
所以我们要去做。 

317
00:14:56,210 --> 00:15:00,479
仍然会做self.cards selectedIndex， 

318
00:15:00,679 --> 00:15:02,189
但不是这种间接的

319
00:15:02,190 --> 00:15:04,000
通过将其复制的变量

320
00:15:04,000 --> 00:15:06,799
我将直接拥有那个东西

321
00:15:06,799 --> 00:15:11,512
 FaceUp等于不是那个东西直接是FaceUp。 

322
00:15:13,182 --> 00:15:14,779
所以我要把卡片翻过来

323
00:15:14,779 --> 00:15:16,870
直接在数组内部。 

324
00:15:16,870 --> 00:15:18,940
这里发生了几件事。 

325
00:15:18,940 --> 00:15:21,479
一，注意我要放点

326
00:15:21,679 --> 00:15:25,719
在每次访问我的变量之前

327
00:15:25,720 --> 00:15:28,840
和功能，我呼吁自己。 

328
00:15:28,840 --> 00:15:33,389
在大多数情况下，此自圆点是可选的。 

329
00:15:33,389 --> 00:15:36,403
通常我什至会说，不要把它放在那里。 

330
00:15:36,403 --> 00:15:39,219
这只是额外的提示。 

331
00:15:39,419 --> 00:15:42,959
但是，由于这个原因，我上次谈到

332
00:15:42,960 --> 00:15:44,570
他们要去哪里

333
00:15:44,570 --> 00:15:47,590
因此，即使在少数情况下您确实需要一个自圆点， 

334
00:15:47,590 --> 00:15:51,149
像这里，在我们的视图中实际上需要自点

335
00:15:51,149 --> 00:15:53,439
当我们点击手势时，这个自圆点

336
00:15:53,440 --> 00:15:55,599
如果你把它拿走，那就有错误了， 

337
00:15:55,799 --> 00:15:58,959
您必须修复它，还记得吗？ 

338
00:15:58,960 --> 00:16:00,449
所以他们要把这个拿走。 

339
00:16:00,649 --> 00:16:02,199
当他们拿走那东西时， 

340
00:16:02,200 --> 00:16:04,980
那么您几乎无处需要自我标记。 

341
00:16:04,980 --> 00:16:06,409
所以在那个时候

342
00:16:06,409 --> 00:16:10,870
我不知道是从现在起两个月后，还是不清楚， 

343
00:16:10,870 --> 00:16:13,100
 WWDC是在六月初。 

344
00:16:13,100 --> 00:16:15,469
很多时候他们会推出新软件， 

345
00:16:15,669 --> 00:16:17,860
 Beta软件，至少在那时

346
00:16:17,860 --> 00:16:19,419
也许他们会解决的，我不知道。 

347
00:16:19,419 --> 00:16:20,490
我不在苹果公司工作

348
00:16:20,490 --> 00:16:23,000
我不知道他们的计划是什么， 

349
00:16:23,000 --> 00:16:26,039
但我们确实知道它已被公开批准

350
00:16:26,039 --> 00:16:28,000
摆脱这个自我点。 

351
00:16:28,000 --> 00:16:29,360
所以在这个过程中

352
00:16:29,360 --> 00:16:34,149
仅在本课程剩下的七八周内， 

353
00:16:34,149 --> 00:16:36,549
我有点推荐也许只是把自我点

354
00:16:36,549 --> 00:16:39,509
在一切面前，因为它不会伤害任何东西

355
00:16:39,509 --> 00:16:42,090
这样可以避免您遇到此问题

356
00:16:42,090 --> 00:16:43,953
您必须在哪里进行修复。 

357
00:16:44,929 --> 00:16:47,269
您只是在学习这些东西

358
00:16:47,269 --> 00:16:50,529
那会给你肌肉记忆

359
00:16:50,529 --> 00:16:52,209
总是输入自我点

360
00:16:52,210 --> 00:16:54,600
您必须训练自己

361
00:16:54,600 --> 00:16:59,350
在此公共修复程序发布后的几个月内。 

362
00:16:59,350 --> 00:17:01,659
但这会让您在本季度摆脱困境。 

363
00:17:01,659 --> 00:17:03,529
那是我的建议

364
00:17:03,529 --> 00:17:06,450
但是在您的作业中，我们不会说

365
00:17:06,450 --> 00:17:08,140
哦，那是错误的，你把自己加了点， 

366
00:17:08,140 --> 00:17:09,686
或哦，那是错误的，您没有设置自我标记。 

367
00:17:09,886 --> 00:17:11,940
这完全取决于您。 

368
00:17:11,940 --> 00:17:15,139
我只是想为您解决可能的问题。 

369
00:17:15,339 --> 00:17:19,302
因此，自我推荐可能是我的建议。 

370
00:17:21,834 --> 00:17:23,889
但是这里有什么？ 

371
00:17:24,089 --> 00:17:26,939
而且我们确信这会奏效。 

372
00:17:26,940 --> 00:17:30,630
我们确定要更改isFaceUp和该数组， 

373
00:17:30,630 --> 00:17:33,619
毫无疑问，selectedIndex的self.cards。 

374
00:17:33,819 --> 00:17:38,809
我们正在更改此数组以使其切换为isFaceUp， 

375
00:17:38,809 --> 00:17:40,836
但是我们这里仍然有一个错误， 

376
00:17:40,836 --> 00:17:45,269
 “无法分配给属性：'自我'是不可变的。” 

377
00:17:45,269 --> 00:17:48,309
并不是说这张卡是一成不变的

378
00:17:48,309 --> 00:17:50,909
因为卡不是，所以是变种。 

379
00:17:50,910 --> 00:17:52,839
如果放手，那将是一成不变的， 

380
00:17:53,039 --> 00:17:55,099
但这是一个变种，所以是可变的， 

381
00:17:55,099 --> 00:17:59,769
但是它本身就是一成不变的。 

382
00:17:59,769 --> 00:18:02,670
换句话说，我们自己的功能似乎

383
00:18:02,670 --> 00:18:06,473
能够改变我们的自我。 

384
00:18:07,680 --> 00:18:10,730
如果我们做不到，那该怎么办呢？ 

385
00:18:10,730 --> 00:18:13,829
好吧，这是怎么回事

386
00:18:13,829 --> 00:18:16,470
我告诉你这些值类型

387
00:18:16,470 --> 00:18:19,069
 Swift没有做按位复制， 

388
00:18:19,069 --> 00:18:21,019
实际上不是在复制它们

389
00:18:21,019 --> 00:18:23,980
从内存中的一个地方到另一个地方

390
00:18:23,980 --> 00:18:25,930
当你把它们传过来时。 

391
00:18:25,930 --> 00:18:27,170
这就是语义

392
00:18:27,170 --> 00:18:29,409
那就是你要想象它正在发生的方式， 

393
00:18:29,609 --> 00:18:33,119
但这实际上只是在内存中制作这些副本

394
00:18:33,119 --> 00:18:36,879
当您开始更改我们在这里所做的事情时。 

395
00:18:36,880 --> 00:18:41,880
我们正在更改此数组，这是我们的实际属性， 

396
00:18:42,380 --> 00:18:43,660
所以我们不复印

397
00:18:43,660 --> 00:18:45,220
实际上是在改变数组， 

398
00:18:45,220 --> 00:18:49,740
但是这种方法改变了我们的自我。 

399
00:18:49,740 --> 00:18:52,920
它改变了我们的自我，因为它改变了我们的牌。 

400
00:18:52,920 --> 00:18:55,529
所以我们必须通过说让Swift知道这一点

401
00:18:55,529 --> 00:18:58,170
这是一个变异函数。 

402
00:18:58,170 --> 00:19:01,630
所以所有修改自我的功能

403
00:19:01,630 --> 00:19:04,379
必须在结构中标记为变异。 

404
00:19:04,579 --> 00:19:06,369
这在课堂上是不正确的。 

405
00:19:06,369 --> 00:19:08,229
类在堆中。 

406
00:19:08,230 --> 00:19:09,400
我们有指向他们的指针。 

407
00:19:09,400 --> 00:19:11,849
我们总是可以更改堆中的内容， 

408
00:19:12,049 --> 00:19:14,869
总是通过指针修改事物， 

409
00:19:14,869 --> 00:19:16,589
正如我之前所说， 

410
00:19:16,589 --> 00:19:19,659
可以和一件好事一样是一件坏事。 

411
00:19:19,660 --> 00:19:21,589
但是对于结构，不，因为它们是值类型

412
00:19:21,789 --> 00:19:25,109
我们必须让Swift知道我们正在对此进行更改。 

413
00:19:25,109 --> 00:19:28,089
现在，索引，我们将在这里写一秒钟， 

414
00:19:28,089 --> 00:19:31,959
它只是获取此阵列中Card的索引。 

415
00:19:31,960 --> 00:19:33,579
它实际上并没有改变任何东西。 

416
00:19:33,579 --> 00:19:34,839
它只是获取索引。 

417
00:19:34,839 --> 00:19:38,240
因此，它不需要或不想在这里进行变异。 

418
00:19:38,240 --> 00:19:41,380
同样或相反， 

419
00:19:41,380 --> 00:19:45,380
我们的初始化器隐式地改变了我们的自我。 

420
00:19:45,380 --> 00:19:46,409
我们正在创造自我。 

421
00:19:46,609 --> 00:19:49,469
我们在这里设置所有变量。 

422
00:19:49,470 --> 00:19:51,319
所以这当然是变异的

423
00:19:51,319 --> 00:19:53,339
所以你不用说变异了。 

424
00:19:53,339 --> 00:19:55,490
所有的初始化都是变异的。 

425
00:19:55,490 --> 00:19:59,630
这都是值类型很酷的功能的一部分

426
00:19:59,630 --> 00:20:01,980
 Swift知道他们何时进行更改。 

427
00:20:01,980 --> 00:20:03,092
然后你会看到

428
00:20:03,292 --> 00:20:07,159
除此副本外，还有其他好处

429
00:20:07,160 --> 00:20:10,023
当我们复制事物时保持正确的行为。 

430
00:20:11,150 --> 00:20:13,960
卡的索引，我们如何找出

431
00:20:13,960 --> 00:20:17,139
我们在哪里获得这张卡的索引

432
00:20:17,339 --> 00:20:18,539
在这个数组中吗？ 

433
00:20:18,539 --> 00:20:22,159
我们想要具有该卡的数组的索引。 

434
00:20:22,160 --> 00:20:24,589
事实证明，这对我们来说超级容易

435
00:20:24,789 --> 00:20:28,730
因为卡是可识别的。 

436
00:20:28,730 --> 00:20:31,920
由于它是可识别的，因此我们只需查看其ID 

437
00:20:31,920 --> 00:20:34,619
并唯一地查看它是哪张卡。 

438
00:20:34,819 --> 00:20:37,240
所以我们只需要在这里做一些for循环

439
00:20:37,240 --> 00:20:42,240
如果零点索引小于我们的卡数， 

440
00:20:42,250 --> 00:20:44,309
还是再一次，如果我们正在做自我点， 

441
00:20:44,309 --> 00:20:47,072
 self.cards.count，无论哪种方式。 

442
00:20:48,592 --> 00:20:49,710
我只是要经历每一个

443
00:20:49,710 --> 00:20:52,250
我要说如果自我点卡

444
00:20:52,250 --> 00:20:56,720
在那个索引id等于

445
00:20:56,720 --> 00:20:59,083
这东西在这里， 

446
00:20:59,920 --> 00:21:04,920
顺便说一句，我猜是两个等号， 

447
00:21:04,930 --> 00:21:07,880
那么我可以返回该索引，因为我找到了它。 

448
00:21:07,880 --> 00:21:09,730
在这里，我正在看我的数组

449
00:21:09,730 --> 00:21:12,690
查看索引是否为该索引的Card， 

450
00:21:12,690 --> 00:21:16,029
它的ID与您传递的ID相同。 

451
00:21:16,029 --> 00:21:20,822
现在，您已经可以在这里真正看到一个问题了。 

452
00:21:21,680 --> 00:21:24,029
我们将这个变量称为，不。 

453
00:21:24,029 --> 00:21:25,910
我们不想这样称呼。 

454
00:21:25,910 --> 00:21:27,769
 Of只是让它变得不错的东西

455
00:21:27,769 --> 00:21:31,589
给打电话给我们说卡片自我索引的人。 

456
00:21:31,589 --> 00:21:36,589
这就是为什么我们要使用双重标签

457
00:21:36,789 --> 00:21:39,366
外部名称，内部名称。 

458
00:21:39,366 --> 00:21:43,319
这样我们就可以将此卡号称为ID 

459
00:21:43,319 --> 00:21:47,339
但是呼叫者仍然可以说出卡片索引。 

460
00:21:47,339 --> 00:21:48,869
希望这是一个很好的例子， 

461
00:21:48,869 --> 00:21:51,476
完全明白为什么我们有外部名称

462
00:21:51,477 --> 00:21:53,909
和参数的内部名称。 

463
00:21:54,109 --> 00:21:55,689
我们没有在这里做。 

464
00:21:55,690 --> 00:21:58,399
外部名称和内部名称相同。 

465
00:21:58,599 --> 00:22:00,009
这里有点争论

466
00:22:00,009 --> 00:22:03,170
您可能实际上选择了下栏

467
00:22:03,170 --> 00:22:05,649
因为很明显，我们正在选择一张卡

468
00:22:05,849 --> 00:22:07,629
这就是这种说法的类型

469
00:22:07,630 --> 00:22:09,599
无论如何我们还会选择什么？ 

470
00:22:09,799 --> 00:22:11,730
但是我要这样离开，只是我们没有

471
00:22:11,730 --> 00:22:12,819
更改我们的其他代码。 

472
00:22:12,819 --> 00:22:15,079
但是如果您阅读指南

473
00:22:15,079 --> 00:22:16,399
作为上周家庭作业的一部分， 

474
00:22:16,400 --> 00:22:17,619
您会看到这是一个

475
00:22:17,819 --> 00:22:20,200
那里可能有一个酒吧

476
00:22:20,200 --> 00:22:22,700
然后人们会选择

477
00:22:22,700 --> 00:22:24,390
并提供Card作为参数， 

478
00:22:24,390 --> 00:22:26,930
呼叫者将没有标签。 

479
00:22:26,930 --> 00:22:29,869
我们已经完成了for循环，我们找到了这个。 

480
00:22:30,069 --> 00:22:31,516
这里还在抱怨什么？ 

481
00:22:31,517 --> 00:22:35,149
 “函数中的期望返回Int缺少返回。” 

482
00:22:35,349 --> 00:22:38,779
哦，是的，如果这个for循环一直进行下去

483
00:22:38,779 --> 00:22:41,329
却找不到那个卡？ 

484
00:22:41,329 --> 00:22:44,143
然后我们必须在这里退货。 

485
00:22:45,039 --> 00:22:48,579
所以Swift实际上有一件很棒的事情

486
00:22:48,579 --> 00:22:51,220
发生这种情况时返回这里

487
00:22:51,220 --> 00:22:54,200
就像您去寻找东西一样，您找不到它。 

488
00:22:54,200 --> 00:22:57,880
在其他语言中，您可能会返回减一

489
00:22:57,880 --> 00:23:01,119
或一些伪造的东西。 

490
00:23:01,319 --> 00:23:04,349
我想我会回来，也许你会归零

491
00:23:04,349 --> 00:23:07,006
这是完全错误的第一个要素。 

492
00:23:07,007 --> 00:23:09,289
如果您去找卡，却找不到它， 

493
00:23:09,289 --> 00:23:11,149
你会说，好吧，归还第一张卡

494
00:23:11,150 --> 00:23:13,379
即使您知道那不是卡。 

495
00:23:13,579 --> 00:23:16,599
所以我们现在回到这里并不重要

496
00:23:16,599 --> 00:23:18,329
因为这都是错误的。 

497
00:23:18,329 --> 00:23:19,769
但是我要放一点东西

498
00:23:19,769 --> 00:23:23,859
在这里叫一个TODO，然后说假的。 

499
00:23:23,859 --> 00:23:26,699
 TODO是您以后可以回头的东西， 

500
00:23:26,700 --> 00:23:30,190
斜杠斜杠TODO，发现提醒自己

501
00:23:30,190 --> 00:23:31,690
您需要解决此问题。 

502
00:23:31,690 --> 00:23:34,149
这些出现在顶部

503
00:23:34,349 --> 00:23:35,349
它说索引。 

504
00:23:35,349 --> 00:23:38,659
如果您单击，这是我所有的变量和函数的列表， 

505
00:23:38,660 --> 00:23:40,440
看起来假货就在那里。 

506
00:23:40,440 --> 00:23:42,720
如果我单击它，则需要我进行虚假验证。 

507
00:23:42,720 --> 00:23:46,160
当我向您展示这种很酷的方式时，我们会回来的

508
00:23:46,160 --> 00:23:47,630
你可以退还东西

509
00:23:47,630 --> 00:23:50,150
就像我在Swift中找不到它一样。 

510
00:23:50,150 --> 00:23:52,359
我们将在下一次讲座中介绍

511
00:23:52,559 --> 00:23:54,226
我们将修复此问题，我们将修复此问题。 

512
00:23:54,227 --> 00:23:57,460
但是现在，我们要在这里做这个假的事情。 

513
00:23:57,460 --> 00:23:59,250
所以我们有卡索引。 

514
00:23:59,250 --> 00:24:02,009
我们绝对是在这里翻转卡。 

515
00:24:02,009 --> 00:24:05,250
因此，让我们运行，看看它是否有效。 

516
00:24:05,250 --> 00:24:07,369
因为我们知道我们已经对此进行了连接

517
00:24:07,369 --> 00:24:08,719
在那儿选择卡。 

518
00:24:08,720 --> 00:24:10,880
所以现在应该选择，例如选择卡片

519
00:24:10,880 --> 00:24:12,869
然后将它翻转过来，就可以开始了

520
00:24:13,069 --> 00:24:14,829
准备好了，鬼。 

521
00:24:14,829 --> 00:24:17,052
哦，南瓜。 

522
00:24:18,410 --> 00:24:21,609
好吧，这肯定是在这里访问模型

523
00:24:21,809 --> 00:24:24,240
因为我们正在选择这张卡。 

524
00:24:24,240 --> 00:24:26,849
但是，这些卡为何面朝上呢？ 

525
00:24:26,849 --> 00:24:29,079
这里发生了什么？ 

526
00:24:29,079 --> 00:24:30,869
好吧，这是怎么回事

527
00:24:30,869 --> 00:24:33,629
我们还没有实施反应式的东西。 

528
00:24:33,630 --> 00:24:35,400
我一开始就告诉你

529
00:24:35,400 --> 00:24:38,649
这就是为什么我们今天在这里要做这种反应性的事情。 

530
00:24:38,849 --> 00:24:41,279
您会看到为什么我们需要反应堆。 

531
00:24:41,279 --> 00:24:45,289
我们选择了一张卡片，它去了这里并更改了型号， 

532
00:24:45,289 --> 00:24:47,220
它翻转了一张卡片

533
00:24:47,220 --> 00:24:49,759
但是我们在用户界面中什么都没有看到。 

534
00:24:49,759 --> 00:24:53,369
而且在SwiftUI中永远不会是这种情况。 

535
00:24:53,369 --> 00:24:57,259
更改模型时，UI应更新。 

536
00:24:57,259 --> 00:24:59,660
我们如何做到这一点？ 

537
00:24:59,660 --> 00:25:02,509
如果您记得我的MVVM幻灯片， 

538
00:25:02,509 --> 00:25:06,089
我在屏幕上放了一些关键字，然后说： 

539
00:25:06,089 --> 00:25:08,899
这些Swift关键字，我们将使用这些关键字

540
00:25:08,900 --> 00:25:10,609
做这个反应，这就是

541
00:25:10,809 --> 00:25:12,450
我们现在要做什么。 

542
00:25:12,450 --> 00:25:14,759
我们将从ViewModel开始。 

543
00:25:14,759 --> 00:25:17,200
这是我们的ViewModel。 

544
00:25:17,200 --> 00:25:20,409
以及我们使ViewModel参与的方式

545
00:25:20,609 --> 00:25:24,309
在这种反应性的东西中使用约束

546
00:25:24,309 --> 00:25:27,539
并获得称为ObservableObject的东西。 

547
00:25:28,619 --> 00:25:31,469
现在记住限制和收获， 

548
00:25:31,470 --> 00:25:33,960
也被称为协议。 

549
00:25:33,960 --> 00:25:37,329
这些限制和收获，我们在这里使用了一个， 

550
00:25:37,329 --> 00:25:40,059
冒号的观点，那是一种制约和收获。 

551
00:25:40,059 --> 00:25:42,059
我们有点受制于

552
00:25:42,059 --> 00:25:43,519
实施这个机构

553
00:25:43,519 --> 00:25:46,389
但是我们获得了所有其他功能

554
00:25:46,390 --> 00:25:47,409
我们可以发送给View。 

555
00:25:47,609 --> 00:25:49,919
所以这是一个巨大的收获

556
00:25:49,920 --> 00:25:53,409
因为我们的限制很小，请点击此处查看。 

557
00:25:53,609 --> 00:25:56,299
我们也在模型，卡片中做到了。 

558
00:25:56,299 --> 00:25:59,309
我们进行了约束并取得了可识别的收益， 

559
00:25:59,309 --> 00:26:02,679
这要求我们执行此var id Int， 

560
00:26:02,680 --> 00:26:06,919
但是现在我们可以分辨哪张卡了。 

561
00:26:07,119 --> 00:26:10,639
用户界面将在此ForEach中使用

562
00:26:10,640 --> 00:26:13,339
确保我们的卡四处走动

563
00:26:13,539 --> 00:26:15,980
我们可以跟踪它们的位置并为其设置动画。 

564
00:26:15,980 --> 00:26:19,599
您将看到SwiftUI中的动画非常简单

565
00:26:19,599 --> 00:26:22,432
很大程度上是因为这种机制。 

566
00:26:23,509 --> 00:26:26,170
所以这就是制约和收获， 

567
00:26:26,170 --> 00:26:28,380
约束几乎没有。 

568
00:26:28,380 --> 00:26:31,169
您无需实现任何var或funcs， 

569
00:26:31,369 --> 00:26:34,289
没有身体或身份证或类似的东西。 

570
00:26:34,289 --> 00:26:37,609
微小的限制是它只能工作

571
00:26:37,609 --> 00:26:40,329
对于类，使用ObservableObject。 

572
00:26:40,329 --> 00:26:44,750
如果您是班级，则只能在此处成为ObservableObject， 

573
00:26:44,750 --> 00:26:47,309
所以那是次要的约束。 

574
00:26:47,309 --> 00:26:50,700
现在，通过这样做您获得的收益

575
00:26:50,700 --> 00:26:53,990
您是否获得了一个名为objectWillChange的变量。 

576
00:26:54,900 --> 00:26:56,390
这个变种在这里，你没有

577
00:26:56,390 --> 00:26:58,640
像我们对身体一样放在这里

578
00:26:58,640 --> 00:27:00,380
您可以在后台免费获得它。 

579
00:27:00,380 --> 00:27:01,809
所以这里不会。 

580
00:27:02,009 --> 00:27:04,349
我只是向您展示您所得到的。 

581
00:27:04,349 --> 00:27:07,949
而且这个var不是真正的这种类型， 

582
00:27:07,950 --> 00:27:10,700
 ObservableObjectPublisher， 

583
00:27:10,700 --> 00:27:12,269
比这复杂一点。 

584
00:27:12,269 --> 00:27:16,379
我们甚至不知道或不在乎它是什么

585
00:27:16,380 --> 00:27:19,859
但是我们需要了解有关此var的两件事。 

586
00:27:20,059 --> 00:27:22,809
一个是它是发布者， 

587
00:27:22,809 --> 00:27:25,329
意味着它可以发布给全世界， 

588
00:27:25,329 --> 00:27:26,689
对任何有兴趣的人， 

589
00:27:26,690 --> 00:27:29,019
我们的观点将会引起人们的兴趣， 

590
00:27:29,019 --> 00:27:30,829
当某些变化。 

591
00:27:30,829 --> 00:27:35,579
而且这个变数只能传送一个函数

592
00:27:35,579 --> 00:27:37,633
这是发送功能。 

593
00:27:38,539 --> 00:27:42,552
如果您调用该函数在objectWillChange上发送， 

594
00:27:43,410 --> 00:27:47,009
即将发布给世界

595
00:27:47,009 --> 00:27:51,690
关于这个对象，或者真的会很快改变

596
00:27:51,690 --> 00:27:53,869
所以准备好然后对它做出反应。 

597
00:27:54,069 --> 00:27:56,730
就是这样，这就是我们要做的，真的， 

598
00:27:56,730 --> 00:27:59,549
让我们的ViewModel参与其中。 

599
00:27:59,549 --> 00:28:02,049
所以每次我们的模型改变时

600
00:28:02,049 --> 00:28:05,690
我们想要做objectWillChange.send。 

601
00:28:05,690 --> 00:28:07,950
例如，这是一个意图。 

602
00:28:07,950 --> 00:28:10,029
显然，我们正在此处更改模型。 

603
00:28:10,029 --> 00:28:11,759
我们知道选择卡

604
00:28:11,759 --> 00:28:15,319
是一个可变的变异函数。 

605
00:28:15,319 --> 00:28:17,950
因此，这当然会改变我们的模型。 

606
00:28:17,950 --> 00:28:22,950
所以在这里我们只说objectWillChange.send。 

607
00:28:24,009 --> 00:28:27,220
这是唯一的功能，真的，我们要调用

608
00:28:27,220 --> 00:28:30,180
关于此对象将在此处更改。 

609
00:28:30,180 --> 00:28:33,023
这将要发布到全世界， 

610
00:28:34,017 --> 00:28:37,669
 objectWillChange表示此MemoryGame将更改。 

611
00:28:37,869 --> 00:28:38,702
就这样。 

612
00:28:38,702 --> 00:28:41,750
这并不是说它是如何改变的，它已经改变了。 

613
00:28:41,750 --> 00:28:43,920
这一点很重要

614
00:28:43,920 --> 00:28:46,400
因为如果此ViewModel更改， 

615
00:28:46,400 --> 00:28:48,129
模型上的此门户已更改， 

616
00:28:48,329 --> 00:28:50,679
希望该门户需要的视图

617
00:28:50,680 --> 00:28:52,220
重画自己。 

618
00:28:52,220 --> 00:28:53,839
我们将在短短一秒钟内告诉您

619
00:28:53,839 --> 00:28:56,829
他们如何注册才能做到这一点。 

620
00:28:56,829 --> 00:28:59,129
再说一次，我们不需要把它放在这里， 

621
00:28:59,130 --> 00:29:00,500
我们免费获得它。 

622
00:29:00,500 --> 00:29:02,859
而当我摆脱它时，您将看不到任何错误。 

623
00:29:02,859 --> 00:29:04,549
这完全是合法的。 

624
00:29:04,549 --> 00:29:06,819
您可以随时拨打此电话， 

625
00:29:06,819 --> 00:29:08,599
任何时候改变。 

626
00:29:08,599 --> 00:29:10,775
甚至不必改变您的模型。 

627
00:29:10,776 --> 00:29:14,220
例如，如果您要更改这些表情符号， 

628
00:29:14,220 --> 00:29:18,150
您可以完全由您来调用objectWillChange。 

629
00:29:18,150 --> 00:29:21,519
但是，在重要的应用中

630
00:29:21,519 --> 00:29:25,109
您可能会有很多意图， 

631
00:29:25,109 --> 00:29:27,599
许多可能会改变您的模型的不同事物。 

632
00:29:27,599 --> 00:29:29,329
这有点烦人

633
00:29:29,329 --> 00:29:31,279
不得不说objectWillChange.send， 

634
00:29:31,279 --> 00:29:32,379
 objectWillChange.send。 

635
00:29:32,380 --> 00:29:33,880
甚至容易出错。 

636
00:29:33,880 --> 00:29:37,480
如果我哎呀雏菊忘了把它放在那里

637
00:29:38,349 --> 00:29:39,939
然后您选择一张卡片，就像

638
00:29:39,940 --> 00:29:42,140
卡仍然不翻转，为什么？ 

639
00:29:42,140 --> 00:29:44,339
因为我忘了把它放在那里。 

640
00:29:44,539 --> 00:29:49,329
因此，尽管我们可以随时调用objectWillChange.send， 

641
00:29:49,329 --> 00:29:51,419
通常是我们处理这个问题的方式

642
00:29:51,420 --> 00:29:55,987
是我们采用此var并使其发布。 

643
00:29:57,730 --> 00:30:01,059
所以这不是Swift关键字， 

644
00:30:01,059 --> 00:30:02,769
你会看到它不是洋红色的

645
00:30:02,769 --> 00:30:05,269
这就是所谓的属性包装器

646
00:30:05,269 --> 00:30:07,420
这是一个财产。 

647
00:30:07,420 --> 00:30:11,169
属性包装器添加了一些功能

648
00:30:11,369 --> 00:30:13,139
周围的财产。 

649
00:30:13,140 --> 00:30:15,980
在这种情况下，这个包装器要做的是

650
00:30:15,980 --> 00:30:19,430
每当此属性，模型发生变化时， 

651
00:30:19,430 --> 00:30:22,150
它调用objectWillChange.send。 

652
00:30:22,150 --> 00:30:23,960
这就是它的作用。 

653
00:30:23,960 --> 00:30:27,977
确实如此，要使我们的ObservableObject在此处， 

654
00:30:27,977 --> 00:30:31,480
我们的ViewModel会在每次发生变化时广播， 

655
00:30:31,480 --> 00:30:35,659
我们只需要@Published我们所有的变量

656
00:30:35,859 --> 00:30:37,500
我们关心他们是否改变

657
00:30:37,500 --> 00:30:39,880
在这种情况下只是我们的一个Model var。 

658
00:30:39,880 --> 00:30:42,130
也可能是其他事情。 

659
00:30:42,130 --> 00:30:42,879
你可以有很多

660
00:30:43,079 --> 00:30:44,639
 @发布的vars，如果想要的话。 

661
00:30:44,640 --> 00:30:46,589
任何时候只要他们改变

662
00:30:46,789 --> 00:30:49,200
这将是objectWillChange.send， 

663
00:30:49,200 --> 00:30:50,363
这就是它的作用。 

664
00:30:51,490 --> 00:30:54,099
这看起来比记住要好得多

665
00:30:54,099 --> 00:30:58,309
将objectWillChange.send放入所有这些函数中。 

666
00:30:58,309 --> 00:30:59,440
您仍然可以选择

667
00:30:59,440 --> 00:31:02,680
即使使用这些，也可以执行objectWillChange.send 

668
00:31:02,680 --> 00:31:04,480
但是大多数时候你不会

669
00:31:04,480 --> 00:31:06,906
做objectWillChange.send。 

670
00:31:08,059 --> 00:31:09,440
所以我们快到了。 

671
00:31:09,440 --> 00:31:11,039
现在我们有了ViewModel 

672
00:31:11,039 --> 00:31:15,529
因此每次模型更改时都会发布。 

673
00:31:15,529 --> 00:31:18,470
现在我们只需要在这里修复我们的视图

674
00:31:18,470 --> 00:31:23,470
这样，当看到此ViewModel发布时，它将重新绘制。 

675
00:31:25,509 --> 00:31:28,660
每当看到这个东西时都会重画， 

676
00:31:28,660 --> 00:31:30,990
说出objectWillChange.send。 

677
00:31:30,990 --> 00:31:33,410
这样做的方法是使用另一个属性包装器

678
00:31:33,410 --> 00:31:36,692
在这个称为@ObservedObject的对象上。 

679
00:31:38,000 --> 00:31:42,589
就是说这个var中有一个ObservableObject， 

680
00:31:42,589 --> 00:31:46,099
这样做，EmojiMemoryGame是一个ObservableObject。 

681
00:31:46,099 --> 00:31:50,689
并且每当它说objectWillChange.send时，都要重画。 

682
00:31:50,690 --> 00:31:52,690
当然要重画这一个

683
00:31:52,690 --> 00:31:57,210
也会导致该笔重绘。 

684
00:31:57,210 --> 00:31:58,730
现在，您可能会觉得， 

685
00:31:58,730 --> 00:32:00,630
哇，这可能效率很低， 

686
00:32:00,630 --> 00:32:02,640
如果模型一直在变化，该怎么办？ 

687
00:32:02,640 --> 00:32:05,630
我们是否会每次都重新绘制视图？ 

688
00:32:05,630 --> 00:32:07,569
好，是的，不是。 

689
00:32:07,769 --> 00:32:11,349
是的，我们将对objectWillChange做出反应

690
00:32:11,349 --> 00:32:15,769
和重绘，但是SwiftUI很聪明地看到了

691
00:32:15,769 --> 00:32:17,900
是否确实发生了变化。 

692
00:32:17,900 --> 00:32:19,640
因此，如果我们翻转一张卡， 

693
00:32:19,640 --> 00:32:22,319
不会重提每张卡， 

694
00:32:22,519 --> 00:32:25,160
只是改变了，它知道

695
00:32:25,160 --> 00:32:27,430
因为卡是可识别的。 

696
00:32:27,430 --> 00:32:30,670
您开始明白为什么这ForEach 

697
00:32:30,670 --> 00:32:34,970
在这一系列卡片上，我们不得不对此进行识别吗？ 

698
00:32:34,970 --> 00:32:37,490
它有助于它了解这一变化

699
00:32:37,490 --> 00:32:39,910
所以我实际上需要重画。 

700
00:32:39,910 --> 00:32:42,680
因为实际上是在调用此代码

701
00:32:42,680 --> 00:32:44,670
可能不是很贵。 

702
00:32:44,670 --> 00:32:47,869
实际上是在屏幕上绘图，这非常昂贵。 

703
00:32:48,069 --> 00:32:51,192
因此，SwiftUI会尽一切可能避免这样做。 

704
00:32:52,349 --> 00:32:55,029
但是从概念上讲，这很简单。 

705
00:32:55,029 --> 00:32:57,129
每当我们的模型改变时， 

706
00:32:57,130 --> 00:33:00,849
这个@Published包装器注意到

707
00:33:01,049 --> 00:33:04,039
我们是一个ObservableObject，因此我们的View可以标记

708
00:33:04,039 --> 00:33:05,990
对那个出版感兴趣

709
00:33:05,990 --> 00:33:08,279
瞧，这会重绘。 

710
00:33:08,279 --> 00:33:12,000
这就是我们进行反应式编程的方式。 

711
00:33:12,000 --> 00:33:13,359
真的，这就是全部。 

712
00:33:13,359 --> 00:33:15,659
我们将看到一些小的改进

713
00:33:15,660 --> 00:33:19,919
做到这一点，但这实际上是它的工作方式。 

714
00:33:20,119 --> 00:33:21,379
因此，让我们看看它是否有效。 

715
00:33:21,380 --> 00:33:22,849
让我们运行我们的应用程序。 

716
00:33:23,049 --> 00:33:25,669
希望当我们点击卡片时， 

717
00:33:25,670 --> 00:33:27,019
我们会说选择了卡

718
00:33:27,019 --> 00:33:28,470
但它们也将翻转过来。 

719
00:33:28,470 --> 00:33:30,053
因此，让我们尝试一下。 

720
00:33:31,210 --> 00:33:34,640
幽灵，我点击它，它正在双向翻转。 

721
00:33:34,640 --> 00:33:37,200
我让这个家伙，这个家伙，这个家伙。 

722
00:33:37,200 --> 00:33:38,389
好吧。 

723
00:33:38,589 --> 00:33:42,529
所以这里发生的是我们点击这些， 

724
00:33:42,529 --> 00:33:44,369
它是在onTapGesture上完成的。 

725
00:33:44,369 --> 00:33:47,750
它在ViewModel中表达了这个Intent。 

726
00:33:47,750 --> 00:33:50,309
然后，ViewModel询问模型

727
00:33:50,309 --> 00:33:51,559
去做吧。 

728
00:33:51,559 --> 00:33:54,429
模型正在做这种变异的事情。 

729
00:33:54,430 --> 00:33:56,500
一旦完成了这种变异的事情， 

730
00:33:56,500 --> 00:33:59,859
很容易注意到这已经改变了

731
00:33:59,859 --> 00:34:02,779
它被发布，objectWillChange.send， 

732
00:34:02,779 --> 00:34:05,670
这个家伙观察到那些objectWillChange.send 

733
00:34:05,670 --> 00:34:07,019
并正在重画。 

734
00:34:07,019 --> 00:34:11,190
那是我给你看的幻灯片， 

735
00:34:11,190 --> 00:34:14,972
来回，这就是代码中的样子。 

736
00:34:17,000 --> 00:34:21,099
所以我们现在需要跳回幻灯片

737
00:34:21,099 --> 00:34:23,232
再谈一些协议。 

738
00:34:24,269 --> 00:34:26,409
一个协议会期待你

739
00:34:26,409 --> 00:34:29,940
就像是精简的类或结构， 

740
00:34:29,940 --> 00:34:33,500
剥离下来，因为它具有函数和变量

741
00:34:33,500 --> 00:34:35,460
但没有实施。 

742
00:34:35,460 --> 00:34:38,460
这是我制定的可移动协议。 

743
00:34:38,460 --> 00:34:40,769
它具有一个功能和两个变量。 

744
00:34:40,769 --> 00:34:43,239
 var之一仅在hasMoved处读取。 

745
00:34:43,239 --> 00:34:46,129
您可以看到它带有大括号。 

746
00:34:46,130 --> 00:34:47,530
然后distanceFromStart 

747
00:34:47,530 --> 00:34:49,864
实际上是可读写的

748
00:34:49,864 --> 00:34:51,889
这就是为什么它已经得到设置。 

749
00:34:51,889 --> 00:34:53,659
但是这里没有实现。 

750
00:34:53,659 --> 00:34:54,879
甚至那里的那些花括号， 

751
00:34:54,880 --> 00:34:57,090
那只是说这些变量是否是只读的， 

752
00:34:57,090 --> 00:34:58,452
这就是全部。 

753
00:34:59,539 --> 00:35:01,969
声明协议后， 

754
00:35:01,969 --> 00:35:05,378
现在任何类型，结构或类都可以出现， 

755
00:35:05,378 --> 00:35:09,619
是的，我要实现这一目标。 

756
00:35:09,619 --> 00:35:12,819
声称要实现该协议。 

757
00:35:12,820 --> 00:35:15,150
所以这里有一个结构轻便的东西

758
00:35:15,349 --> 00:35:18,739
它在此声明中表示冒号Moveable。 

759
00:35:18,739 --> 00:35:21,229
当它这么说时，立即意味着

760
00:35:21,230 --> 00:35:22,880
我注册实施

761
00:35:22,880 --> 00:35:25,230
因此，它必须实现每个var 

762
00:35:25,429 --> 00:35:28,099
以及Moveable中的每个功能。 

763
00:35:28,099 --> 00:35:30,769
现在我们已经在View之前看到了

764
00:35:30,769 --> 00:35:33,679
我们有ContentView，冒号视图。 

765
00:35:33,679 --> 00:35:35,809
它签约成为View，这就是为什么它拥有

766
00:35:35,809 --> 00:35:40,039
做var body，同一件事是Card，可识别。 

767
00:35:40,039 --> 00:35:41,929
它签署了实施Identifiable的协议。 

768
00:35:41,929 --> 00:35:44,623
它必须实现该var id。 

769
00:35:46,369 --> 00:35:50,969
现在也可以说一个协议

770
00:35:50,969 --> 00:35:52,609
它需要另一个协议。 

771
00:35:52,610 --> 00:35:54,769
这称为协议继承， 

772
00:35:54,769 --> 00:35:56,969
不要与类继承混淆

773
00:35:56,969 --> 00:35:59,079
因为我们在这里只是在谈论协议。 

774
00:35:59,079 --> 00:36:01,219
所以我这里有一个协议载具

775
00:36:01,219 --> 00:36:04,459
它是从Moveable继承的。 

776
00:36:04,460 --> 00:36:07,550
它在那里添加了自己的var，passengerCount。 

777
00:36:07,550 --> 00:36:11,150
因此，如果像汽车这样的课程出现在底部

778
00:36:11,349 --> 00:36:13,849
它说，我签署了您的车辆， 

779
00:36:13,849 --> 00:36:15,889
现在它必须执行所有三件事

780
00:36:15,889 --> 00:36:17,849
来自Moveable，它具有

781
00:36:17,849 --> 00:36:19,650
来实现Vehicle的东西。 

782
00:36:20,500 --> 00:36:23,309
如果您是结构或类，也可以

783
00:36:23,309 --> 00:36:25,719
声称实现多种协议。 

784
00:36:25,719 --> 00:36:27,559
所以这里有上课车。 

785
00:36:27,559 --> 00:36:29,710
不只是说这是一辆车

786
00:36:29,710 --> 00:36:32,429
而且它是可移植的

787
00:36:32,429 --> 00:36:35,529
现在汽车可能必须实现vars中的所有功能

788
00:36:35,530 --> 00:36:37,773
在所有这三个协议中。 

789
00:36:38,739 --> 00:36:41,250
现在，协议就是一种类型。 

790
00:36:41,250 --> 00:36:44,320
这意味着可以使用大多数协议

791
00:36:44,320 --> 00:36:46,650
在大多数情况下，您有类型。 

792
00:36:46,650 --> 00:36:51,369
例如，我可以有一个类型为Moveable的变量m。 

793
00:36:51,369 --> 00:36:54,295
那是m的类型，这是Moveable的类型。 

794
00:36:54,295 --> 00:36:55,289
那是什么意思呢？ 

795
00:36:55,289 --> 00:36:57,389
好吧，如果我还有另外两个变量， 

796
00:36:57,389 --> 00:37:00,170
例如汽车和便携式汽车，它们都是汽车类型

797
00:37:00,170 --> 00:37:03,480
然后输入PortableThing，然后我可以说， 

798
00:37:03,480 --> 00:37:06,110
 m等于汽车或m等于便携式。 

799
00:37:06,110 --> 00:37:07,039
我怎么这么说

800
00:37:07,239 --> 00:37:10,449
因为汽车是动车， 

801
00:37:10,449 --> 00:37:12,779
它实现了可移动协议。 

802
00:37:12,780 --> 00:37:16,820
实际上，汽车实现了Vehicle，Vehicle继承了Moveable， 

803
00:37:16,820 --> 00:37:19,130
因此汽车是可移动的。 

804
00:37:19,130 --> 00:37:22,210
这很棒，因为现在我有了这个变量m， 

805
00:37:22,210 --> 00:37:25,936
我可以开始发送它的功能，例如移动， 

806
00:37:25,936 --> 00:37:29,269
已经移动，因为我知道m是可移动的。 

807
00:37:29,269 --> 00:37:32,009
不管是那里的汽车还是PortableThing， 

808
00:37:32,010 --> 00:37:33,820
我们知道那些变量和函数

809
00:37:33,820 --> 00:37:35,809
将被实施，因为您需要

810
00:37:35,809 --> 00:37:39,340
如果您说自己是其中之一，就实施它们。 

811
00:37:39,340 --> 00:37:41,420
但是要注意一点， 

812
00:37:41,420 --> 00:37:45,559
你不能说便携式等于汽车。 

813
00:37:45,559 --> 00:37:49,269
那里的var便携式设备不是Moveable类型， 

814
00:37:49,269 --> 00:37:52,900
它是PortableThing类型，不同。 

815
00:37:52,900 --> 00:37:56,460
因此，汽车不是PortablePorting。 

816
00:37:56,659 --> 00:37:59,949
它们都是可移动的，但是汽车是不同的类型

817
00:37:59,949 --> 00:38:00,879
而不是PortableThing。 

818
00:38:00,880 --> 00:38:03,829
我认为汽车是一门课程，PortableThing是一种结构。 

819
00:38:03,829 --> 00:38:06,159
因此，甚至没有同样的事情。 

820
00:38:06,159 --> 00:38:07,969
所以你不能这么说。 

821
00:38:07,969 --> 00:38:09,980
我可以说m等于所有这些东西， 

822
00:38:09,980 --> 00:38:11,539
我不能说他们彼此平等

823
00:38:11,539 --> 00:38:14,719
因为Swift正在执行var的类型， 

824
00:38:14,719 --> 00:38:16,299
然后当我说便携式等于

825
00:38:16,300 --> 00:38:18,420
变量的类型是PortableThing， 

826
00:38:18,619 --> 00:38:20,762
不要在此处输入“可移动”。 

827
00:38:22,110 --> 00:38:24,320
一种考虑协议的方式， 

828
00:38:24,320 --> 00:38:26,900
我已经在演示中提到了这一点， 

829
00:38:27,099 --> 00:38:30,529
是制约和收获。 

830
00:38:30,530 --> 00:38:34,630
我用它是因为它押韵，所以希望容易记住， 

831
00:38:34,829 --> 00:38:37,130
它是这样的。 

832
00:38:37,130 --> 00:38:41,269
所以我在这里有这个结构，特斯拉，这是一辆车， 

833
00:38:41,469 --> 00:38:43,139
因此它实现了所有这些东西。 

834
00:38:43,139 --> 00:38:44,799
实际上，它受到限制

835
00:38:44,800 --> 00:38:47,320
实施车辆中的所有事物

836
00:38:47,320 --> 00:38:49,610
其中包括“可移动”中的所有内容， 

837
00:38:49,610 --> 00:38:53,820
但是受到限制会再次发生

838
00:38:53,820 --> 00:38:58,360
世界为车辆提供的所有东西。 

839
00:38:58,360 --> 00:39:01,673
现在，您可能会说，嗯，在这里稍等片刻， 

840
00:39:01,673 --> 00:39:05,269
车辆是协议，没有实现。 

841
00:39:05,269 --> 00:39:08,092
我们怎么可能在这里获得任何收益？ 

842
00:39:09,139 --> 00:39:12,839
似乎我在这里遇到了所有限制，但没有收获。 

843
00:39:12,840 --> 00:39:17,460
好吧，关键在于关键字扩展。 

844
00:39:17,659 --> 00:39:22,659
在Swift中，我们可以扩展协议以实现。 

845
00:39:23,869 --> 00:39:26,900
我们只说扩展名，协议名称， 

846
00:39:26,900 --> 00:39:28,300
然后我们可以放函数

847
00:39:28,300 --> 00:39:31,750
带有实现函数的vars中的实现函数。 

848
00:39:31,750 --> 00:39:34,920
现在我们不能在这里存储任何变量了。 

849
00:39:34,920 --> 00:39:38,170
因此有一个限制，它必须是计算的vars， 

850
00:39:38,170 --> 00:39:39,927
就像var body是经过计算的，请记住， 

851
00:39:39,927 --> 00:39:43,000
它在同一件事之后有花括号， 

852
00:39:43,000 --> 00:39:46,440
但是我们可以添加任意数量的东西。 

853
00:39:46,440 --> 00:39:49,170
随着车辆登记簿的扩展，DMV 

854
00:39:49,170 --> 00:39:51,639
现在是特斯拉和所有其他车辆

855
00:39:51,639 --> 00:39:53,269
可以在DMV中注册。 

856
00:39:53,269 --> 00:39:55,619
换句话说，他们获得了这种能力

857
00:39:55,619 --> 00:39:57,969
忍受他们所受的束缚

858
00:39:57,969 --> 00:40:00,039
实现那些方法和变量

859
00:40:00,039 --> 00:40:01,623
在那些协议中。 

860
00:40:02,730 --> 00:40:05,179
是的，这真的是中心

861
00:40:05,179 --> 00:40:07,889
 Swift中的函数式编程。 

862
00:40:07,889 --> 00:40:10,949
协议视图可能是

863
00:40:10,949 --> 00:40:13,379
这样做的发帖者。 

864
00:40:13,380 --> 00:40:14,960
我们将看到更多关于View的信息

865
00:40:15,159 --> 00:40:16,509
在这里有几张幻灯片。 

866
00:40:17,690 --> 00:40:20,210
除了添加功能之外， 

867
00:40:20,210 --> 00:40:23,481
像registerWithDMV一样，您也可以使用扩展名

868
00:40:23,681 --> 00:40:28,681
如果要添加默认实现，请选择协议。 

869
00:40:28,710 --> 00:40:30,389
所以我在这里扩展Moveable 

870
00:40:30,389 --> 00:40:33,059
我实际上是提供默认的实现

871
00:40:33,059 --> 00:40:36,369
 for hasMoved as hasMoved是变量之一

872
00:40:36,369 --> 00:40:37,719
在协议中

873
00:40:37,719 --> 00:40:39,809
但是我在这里提供了默认的实现。 

874
00:40:39,809 --> 00:40:42,380
我只是在看我的距离

875
00:40:42,380 --> 00:40:43,800
如果大于零， 

876
00:40:43,800 --> 00:40:45,697
我假设我已经搬家了。 

877
00:40:45,697 --> 00:40:49,550
而我正在通过对Moveable进行扩展。 

878
00:40:49,550 --> 00:40:52,550
因此，这使我有可能拥有一个结构， 

879
00:40:52,550 --> 00:40:55,260
我这里有一个叫ChessPiece的棋子，它是可移动的， 

880
00:40:55,260 --> 00:40:57,070
您可以移动棋子。 

881
00:40:57,070 --> 00:41:00,440
 ChessPiece不需要实现hasMoved。 

882
00:41:00,639 --> 00:41:03,210
如果ChessPiece只是实现moveBy 

883
00:41:03,210 --> 00:41:04,750
和distanceFromStart， 

884
00:41:04,750 --> 00:41:07,349
那么它将成功实现Moveable 

885
00:41:07,349 --> 00:41:10,610
因为它将采用默认实现

886
00:41:10,610 --> 00:41:12,500
从那扩展名那里。 

887
00:41:12,699 --> 00:41:15,909
现在，如果ChessPiece想要自己实现hasMoved， 

888
00:41:15,909 --> 00:41:18,129
可以，但是不必

889
00:41:18,130 --> 00:41:20,250
因为有一个默认的实现

890
00:41:20,250 --> 00:41:22,512
对于该扩展中的hasMoved。 

891
00:41:23,639 --> 00:41:25,690
现在，您当然可以使用扩展程序了， 

892
00:41:25,690 --> 00:41:28,019
还要向结构和类中添加代码， 

893
00:41:28,219 --> 00:41:30,619
不只是协议。 

894
00:41:30,619 --> 00:41:34,299
例如，在这里，我有一个名为Boat的结构

895
00:41:34,300 --> 00:41:37,400
它有自己的方法，无论它们是什么。 

896
00:41:37,400 --> 00:41:40,329
在这里，我将扩展添加到Boat中， 

897
00:41:40,329 --> 00:41:42,650
一个功能sailAroundTheWorld。 

898
00:41:42,650 --> 00:41:46,099
您可以看到，该扩展名带有花括号， 

899
00:41:46,099 --> 00:41:47,329
它有一个实现。 

900
00:41:47,329 --> 00:41:50,559
这是sailAroundTheWorld的实际实现

901
00:41:50,559 --> 00:41:52,232
我们已经添加到Boat中

902
00:41:53,409 --> 00:41:58,129
您甚至可以制作类似Boat的产品

903
00:41:58,130 --> 00:42:01,019
完全通过使用您的扩展协议。 

904
00:42:01,219 --> 00:42:04,609
所以Boat现在不执行任何协议

905
00:42:04,610 --> 00:42:07,130
但我可以使Boat工具可移动

906
00:42:07,130 --> 00:42:09,269
通过扩展到Boat 

907
00:42:09,469 --> 00:42:13,059
表示冒号Moveable，然后在该扩展名中， 

908
00:42:13,059 --> 00:42:16,070
实现moveBy和distanceFromStart。 

909
00:42:16,070 --> 00:42:18,400
现在船是可移动的。 

910
00:42:18,599 --> 00:42:20,732
我将其全部添加为扩展名。 

911
00:42:22,043 --> 00:42:23,750
这不是一件罕见的事

912
00:42:23,750 --> 00:42:27,309
采取结构或类别并使其符合标准

913
00:42:27,309 --> 00:42:30,029
纯粹使用扩展的协议

914
00:42:30,030 --> 00:42:31,830
或者您将代码添加到扩展程序中。 

915
00:42:33,880 --> 00:42:37,099
为什么我们要做所有这些协议呢？ 

916
00:42:37,099 --> 00:42:38,769
现在，对于那些即将到来的人

917
00:42:38,769 --> 00:42:40,420
来自面向对象的编程

918
00:42:40,420 --> 00:42:42,230
看起来就像是，这是怎么回事？ 

919
00:42:42,230 --> 00:42:43,440
我们为什么要做这个？ 

920
00:42:43,440 --> 00:42:45,940
嗯，有一个非常好的概念上的原因

921
00:42:45,940 --> 00:42:47,780
为什么我们要这样做。 

922
00:42:47,780 --> 00:42:51,000
协议不包含类型，结构和类， 

923
00:42:51,199 --> 00:42:55,449
其他我们没有讨论过的协议，甚至枚举， 

924
00:42:55,449 --> 00:42:58,139
说出他们的能力， 

925
00:42:58,139 --> 00:43:02,480
他们可以做什么功能，他们有什么变量， 

926
00:43:02,480 --> 00:43:04,440
这也是其他代码的一种方式

927
00:43:04,440 --> 00:43:07,800
要求其他物体的某些行为

928
00:43:07,800 --> 00:43:10,530
通过要求他们遵守协议， 

929
00:43:10,530 --> 00:43:12,860
通过具有该类型的变量

930
00:43:12,860 --> 00:43:16,190
他们正在尝试为函数分配或参数化。 

931
00:43:16,190 --> 00:43:18,869
您甚至还会看到其他机制

932
00:43:18,869 --> 00:43:21,329
当我们谈论泛型和协议时

933
00:43:21,329 --> 00:43:24,340
要求您希望该东西是可移动的。 

934
00:43:24,340 --> 00:43:25,940
无论如何，它必须是一辆载具。 

935
00:43:26,139 --> 00:43:29,839
现在，有了此协议，就可以要求它了。 

936
00:43:29,840 --> 00:43:33,320
但在所有这些方面，双方都不必透露

937
00:43:33,320 --> 00:43:35,820
您是哪种结构类。 

938
00:43:35,820 --> 00:43:38,340
您完全可以随心所欲。 

939
00:43:38,340 --> 00:43:40,539
你只是说你实现了Moveable 

940
00:43:40,539 --> 00:43:43,360
现在您可以将其作为可移动设备进行操作， 

941
00:43:43,360 --> 00:43:44,250
但你可以是任何人。 

942
00:43:44,449 --> 00:43:46,369
您可能是汽车，也可能是PortableThing。 

943
00:43:46,369 --> 00:43:47,813
你可能是一条船。 

944
00:43:48,949 --> 00:43:51,349
我们知道什么时候双方都不在乎。 

945
00:43:51,349 --> 00:43:54,019
一方面，您可以做可移动的事情

946
00:43:54,019 --> 00:43:55,449
而所有其他副作用是

947
00:43:55,449 --> 00:43:58,282
它实现了所有那些可移动的东西。 

948
00:43:59,590 --> 00:44:01,690
这就是函数式编程

949
00:44:01,690 --> 00:44:05,349
或实际上我们可以称之为面向协议的编程， 

950
00:44:05,349 --> 00:44:06,500
关于一切。 

951
00:44:06,500 --> 00:44:09,219
这是关于规范数据结构的方式

952
00:44:09,219 --> 00:44:12,969
在我们的应用程序功能中，它们的行为方式。 

953
00:44:12,969 --> 00:44:16,179
即使我们在协议的上下文中谈论var， 

954
00:44:16,179 --> 00:44:19,250
我们没有定义它们的存储或计算方式， 

955
00:44:19,250 --> 00:44:21,539
我们甚至不说它们的存储或计算位置， 

956
00:44:21,539 --> 00:44:24,179
我们只是在谈论它们是只读还是读，写。 

957
00:44:24,179 --> 00:44:27,980
通过所有这些，我们专注于功能。 

958
00:44:27,980 --> 00:44:30,409
我们隐藏了实现细节。 

959
00:44:30,409 --> 00:44:32,539
这是最终的承诺

960
00:44:32,539 --> 00:44:35,269
面向对象程序设计的封装

961
00:44:35,269 --> 00:44:37,170
但这确实是一个更高的层次

962
00:44:37,170 --> 00:44:39,849
因为它不会无情地混合它

963
00:44:39,849 --> 00:44:41,132
有了数据和所有这些， 

964
00:44:41,132 --> 00:44:44,532
只是在谈论功能。 

965
00:44:45,820 --> 00:44:49,059
所有这些都变得更加强大

966
00:44:49,059 --> 00:44:51,802
当我们将其与泛型结合使用时。 

967
00:44:52,730 --> 00:44:55,929
协议加上泛型等于

968
00:44:55,929 --> 00:44:58,690
正如我在这里所说的，超级大国。 

969
00:44:58,690 --> 00:45:01,309
让我们来看看泛型

970
00:45:01,309 --> 00:45:03,500
记住那是无关紧要的东西

971
00:45:03,500 --> 00:45:05,090
我们上次谈到的

972
00:45:05,090 --> 00:45:08,760
它如何与协议结合以产生超能力。 

973
00:45:08,760 --> 00:45:09,690
开始了。 

974
00:45:09,889 --> 00:45:11,400
让我们以示例方式进行操作。 

975
00:45:11,400 --> 00:45:14,519
假设我有一个名为Greatness的协议， 

976
00:45:14,719 --> 00:45:16,809
这个协议里面只有一个功能

977
00:45:16,809 --> 00:45:19,362
就是比其他大。 

978
00:45:20,369 --> 00:45:23,099
此函数的另一个参数是GreaterThan。 

979
00:45:23,099 --> 00:45:25,190
顺便说一句，这是一个有趣的功能

980
00:45:25,190 --> 00:45:29,980
因为其他类型是大写S Self。 

981
00:45:30,840 --> 00:45:34,320
这是协议中一种特殊的类型名称

982
00:45:34,320 --> 00:45:35,980
表示实际类型

983
00:45:36,179 --> 00:45:38,129
正在实施该协议， 

984
00:45:38,130 --> 00:45:40,039
因为请记住，协议本身

985
00:45:40,239 --> 00:45:42,259
没有实现，他们就实现了

986
00:45:42,260 --> 00:45:43,730
通过结构和类。 

987
00:45:43,929 --> 00:45:46,429
因此，Self表示实际的结构类

988
00:45:46,429 --> 00:45:50,909
实现了这一点，当时正在执行它。 

989
00:45:50,909 --> 00:45:51,742
所以这很酷。 

990
00:45:51,742 --> 00:45:52,576
我要告诉你它是如何工作的

991
00:45:52,576 --> 00:45:54,762
只需点击几下。 

992
00:45:55,769 --> 00:45:59,349
因此，如果我们有此协议，请看我们能做什么。 

993
00:45:59,349 --> 00:46:03,679
扩展数组，所以我要在数组中添加一些内容， 

994
00:46:03,679 --> 00:46:08,679
元素不在乎Array， 

995
00:46:08,750 --> 00:46:12,860
符合伟大，冒号伟大。 

996
00:46:12,860 --> 00:46:14,750
这样我放在红色的地方

997
00:46:14,949 --> 00:46:17,239
因为这真的是关键

998
00:46:17,239 --> 00:46:19,639
泛型和协议的连接。 

999
00:46:19,639 --> 00:46:22,460
在这里，我实际上要添加一个变量， 

1000
00:46:22,460 --> 00:46:23,760
或者我可以通过功能来做到这一点

1001
00:46:23,760 --> 00:46:25,510
但是我要在这里添加一个变量

1002
00:46:25,510 --> 00:46:29,630
数组，以便每个数组元素所在的位置， 

1003
00:46:29,630 --> 00:46:33,133
不在乎，符合Greatness会得到此var。 

1004
00:46:34,460 --> 00:46:36,090
让它沉入。 

1005
00:46:36,090 --> 00:46:39,039
现在，此变量将不存在于数组中

1006
00:46:39,239 --> 00:46:42,479
不在乎的地方

1007
00:46:42,480 --> 00:46:43,539
协议伟大。 

1008
00:46:43,539 --> 00:46:45,340
该变量只是不会存在。 

1009
00:46:45,340 --> 00:46:46,900
如果您尝试在代码中键入它， 

1010
00:46:47,099 --> 00:46:48,079
编译器会说， 

1011
00:46:48,079 --> 00:46:51,239
这个数组没有实现最大

1012
00:46:51,239 --> 00:46:52,809
它只会说它实现了最大

1013
00:46:52,809 --> 00:46:56,130
只允许您正确输入

1014
00:46:56,130 --> 00:46:57,630
如果它是某物的数组

1015
00:46:57,630 --> 00:46:59,510
实现了协议Greatness 

1016
00:46:59,510 --> 00:47:03,833
现在我喜欢这样称呼，我们有点关心。 

1017
00:47:05,000 --> 00:47:07,969
通常我们称泛型不在乎， 

1018
00:47:07,969 --> 00:47:09,699
元素是不在乎， 

1019
00:47:09,699 --> 00:47:12,319
数组不在乎其中的内容。 

1020
00:47:12,320 --> 00:47:14,039
好吧，这有点

1021
00:47:14,039 --> 00:47:17,800
这个对Array的扩展有点关心元素。 

1022
00:47:17,800 --> 00:47:19,420
真的不在乎什么元素

1023
00:47:19,420 --> 00:47:22,840
可以是任何结构或类，但我们会注意

1024
00:47:22,840 --> 00:47:24,309
它实现了伟大。 

1025
00:47:24,309 --> 00:47:26,210
所以这有点关怀， 

1026
00:47:26,210 --> 00:47:28,070
你想那样想。 

1027
00:47:28,070 --> 00:47:33,070
然后，这个无穷大，看看它的类型是什么，元素。 

1028
00:47:33,119 --> 00:47:35,210
不在乎，因为我要看

1029
00:47:35,210 --> 00:47:37,869
通过数组找到最伟大的那个

1030
00:47:37,869 --> 00:47:40,509
通过调用isGreatThan 

1031
00:47:40,510 --> 00:47:41,670
在数组中的所有事物上

1032
00:47:41,869 --> 00:47:45,069
我知道我可以做，因为这个对Array的扩展

1033
00:47:45,070 --> 00:47:48,750
只是元素实现伟大的地方。 

1034
00:47:48,750 --> 00:47:50,750
在这里看到一切如何？ 

1035
00:47:50,750 --> 00:47:52,940
您可以轻松想象，我不会在这里显示代码， 

1036
00:47:52,940 --> 00:47:55,112
但您可以轻松想象构建一个for循环

1037
00:47:55,112 --> 00:47:57,049
只是涉及所有要素， 

1038
00:47:57,050 --> 00:47:58,710
通话比所有通话都好， 

1039
00:47:58,710 --> 00:48:00,820
找出哪一个是最大的

1040
00:48:00,820 --> 00:48:02,170
那只是返回它。 

1041
00:48:03,469 --> 00:48:07,439
因此，让我们看看如何使用这样的数组。 

1042
00:48:07,440 --> 00:48:10,280
假设我使用另一个扩展

1043
00:48:10,280 --> 00:48:12,039
使Int类型为Int 

1044
00:48:12,239 --> 00:48:14,719
这是一个结构，实现伟大。 

1045
00:48:14,719 --> 00:48:16,589
没问题，这很容易

1046
00:48:16,590 --> 00:48:19,420
实现一个比其他更好的Int， 

1047
00:48:19,420 --> 00:48:22,050
只是我自己比其他Int伟大， 

1048
00:48:22,050 --> 00:48:23,300
您可以使用大于

1049
00:48:23,300 --> 00:48:26,030
看看某物是否大于某物。 

1050
00:48:26,030 --> 00:48:28,150
但是想象一下我有完全不同的类型。 

1051
00:48:28,150 --> 00:48:31,039
这是总统的延伸。 

1052
00:48:31,039 --> 00:48:33,059
那是美国总统。 

1053
00:48:33,059 --> 00:48:34,710
我要让它实现伟大， 

1054
00:48:34,710 --> 00:48:36,992
 func比其他总统大。 

1055
00:48:38,090 --> 00:48:39,059
我要实施... 

1056
00:48:39,059 --> 00:48:40,650
其实我有唐纳德·特朗普， 

1057
00:48:40,650 --> 00:48:44,210
来宾iOS程序员来实现这一点。 

1058
00:48:44,409 --> 00:48:46,644
他说那比

1059
00:48:46,644 --> 00:48:48,650
只是self.name等于Trump。 

1060
00:48:48,650 --> 00:48:51,800
如果是这样，那当然是大于， 

1061
00:48:51,800 --> 00:48:54,269
他是一位出色的iOS程序员，每个人都告诉我， 

1062
00:48:54,469 --> 00:48:56,039
我到处都听到。 

1063
00:48:56,039 --> 00:48:57,889
所以我们开始，我们得到了。 

1064
00:48:57,889 --> 00:48:59,779
现在，我想指出的一件事

1065
00:48:59,780 --> 00:49:03,010
关于您看到的这张幻灯片

1066
00:49:03,010 --> 00:49:04,800
这里是紫色的东西。 

1067
00:49:04,800 --> 00:49:08,190
还记得顶部的“其他自我”吗？ 

1068
00:49:08,190 --> 00:49:09,860
还记得资本S Self吗？ 

1069
00:49:09,860 --> 00:49:12,500
看一下，当我创建这些扩展后， 

1070
00:49:12,699 --> 00:49:16,039
自我变成了我要延伸的类型

1071
00:49:16,039 --> 00:49:19,820
我正在实现该协议的类型。 

1072
00:49:19,820 --> 00:49:21,809
希望可以帮助您了解自我。 

1073
00:49:21,809 --> 00:49:24,079
我提出这一点是因为有很多协议

1074
00:49:24,079 --> 00:49:27,639
在Swift UI中执行此操作的地方

1075
00:49:27,639 --> 00:49:30,429
或其中一种类型的功能

1076
00:49:30,429 --> 00:49:32,879
论据的关键是实现这一点。 

1077
00:49:32,880 --> 00:49:35,123
因此，这并不少见。 

1078
00:49:36,010 --> 00:49:38,110
所以现在我有诚信和总裁。 

1079
00:49:38,309 --> 00:49:41,750
他们都实现了这个协议，伟大。 

1080
00:49:41,750 --> 00:49:44,730
因此，我应该能够在它们上调用该Array var。 

1081
00:49:44,730 --> 00:49:46,900
我应该可以使用Array var 

1082
00:49:46,900 --> 00:49:50,059
我在那定义的最大，最大的东西。 

1083
00:49:50,059 --> 00:49:52,329
因此，让我们看一下Int的外观。 

1084
00:49:52,329 --> 00:49:54,409
所以对于Int，假设我有一个numbersArray 

1085
00:49:54,409 --> 00:49:56,889
它是类型的Int数组。 

1086
00:49:56,889 --> 00:50:00,629
我将在这里将其设置为等于常数Array， 

1087
00:50:00,630 --> 00:50:02,070
我们在演示中看到了。 

1088
00:50:02,070 --> 00:50:03,190
我们是用表情符号来做的。 

1089
00:50:03,190 --> 00:50:05,659
在这里，我正在处理数字3、7和42 

1090
00:50:05,659 --> 00:50:07,739
所以这只是一个数组，现在我可以说， 

1091
00:50:07,739 --> 00:50:10,639
让foo等于numbersArray.greatest。 

1092
00:50:10,639 --> 00:50:15,019
编译和工作是因为Int是

1093
00:50:15,019 --> 00:50:17,289
该Array和Int实现的内容

1094
00:50:17,289 --> 00:50:21,059
伟大的协议，所以最大的变种

1095
00:50:21,059 --> 00:50:22,086
因此被定义。 

1096
00:50:22,086 --> 00:50:25,880
因此foo将是42，因为我们确实实现了它

1097
00:50:25,880 --> 00:50:26,750
只说更大一点。 

1098
00:50:26,949 --> 00:50:28,750
我可以做完全一样的事情

1099
00:50:28,750 --> 00:50:30,050
如果我在这个数组中有一个总裁。 

1100
00:50:30,050 --> 00:50:32,440
假设可以创建struct President 

1101
00:50:32,440 --> 00:50:33,539
以总统的名字。 

1102
00:50:33,539 --> 00:50:35,742
因此，我在这里创建了一系列总裁。 

1103
00:50:35,742 --> 00:50:37,449
现在，我要说让foo等于

1104
00:50:37,449 --> 00:50:40,219
 PresidentsArray.greatest。 

1105
00:50:40,219 --> 00:50:42,047
那会把我还给我

1106
00:50:42,047 --> 00:50:43,909
或名字叫Trump的foo， 

1107
00:50:43,909 --> 00:50:47,779
当然，基于他在此处编写的代码。 

1108
00:50:47,780 --> 00:50:50,000
所以希望这能使您清楚

1109
00:50:50,199 --> 00:50:53,329
我们如何一起使用泛型和协议。 

1110
00:50:53,329 --> 00:50:56,190
我们将在SwiftUI的所有位置进行此操作。 

1111
00:50:58,170 --> 00:50:59,590
你们当中有些人正在看这一切， 

1112
00:50:59,590 --> 00:51:02,913
就像我在这里所说的，我确定您正在发抖。 

1113
00:51:03,969 --> 00:51:06,039
你必须要思考，圣牛， 

1114
00:51:06,039 --> 00:51:08,409
我应该怎么知道

1115
00:51:08,409 --> 00:51:11,929
如何使用这项技术设计代码？ 

1116
00:51:11,929 --> 00:51:14,219
我的意思是，这对我来说是全新的。 

1117
00:51:14,219 --> 00:51:18,079
这确实是一个非常强大的基础

1118
00:51:18,079 --> 00:51:20,659
对于设计事物，功能非常强大。 

1119
00:51:20,659 --> 00:51:23,759
但是函数式编程确实需要一定的掌握

1120
00:51:23,760 --> 00:51:27,289
那只有经验。 

1121
00:51:27,489 --> 00:51:30,259
好消息是您可以做很多事情

1122
00:51:30,260 --> 00:51:31,980
在SwiftUI中，大多数事情

1123
00:51:32,179 --> 00:51:35,549
无需真正掌握功能编程。 

1124
00:51:35,550 --> 00:51:38,289
但是在这里，您正在斯坦福大学努力接受良好的教育。 

1125
00:51:38,489 --> 00:51:41,559
所以我现在向你解释的原因

1126
00:51:41,559 --> 00:51:44,320
以便您在SwiftUI中使用它的次数增加， 

1127
00:51:44,320 --> 00:51:46,289
您在文档中看到的越多

1128
00:51:46,289 --> 00:51:49,019
您看到这些商品在发生， 

1129
00:51:49,019 --> 00:51:50,759
我们看到像View这样的协议

1130
00:51:50,760 --> 00:51:53,000
并且可以确定的是， 

1131
00:51:53,199 --> 00:51:56,159
你不只是在说，我必须在这里放冒号， 

1132
00:51:56,159 --> 00:51:57,539
你实际上是在理解

1133
00:51:57,539 --> 00:51:59,599
它是如何设计的。 

1134
00:51:59,599 --> 00:52:01,896
而且您看到的越多，它就会越陷进去

1135
00:52:01,896 --> 00:52:04,929
最终您可能会开始变得更有能力

1136
00:52:04,929 --> 00:52:07,772
同时进行功能编程设计。 

1137
00:52:08,780 --> 00:52:10,733
但是现在没有人期望你

1138
00:52:10,733 --> 00:52:13,190
能够设计东西

1139
00:52:13,190 --> 00:52:15,179
在其中添加协议扩展的地方

1140
00:52:15,179 --> 00:52:16,859
与泛型和所有。 

1141
00:52:16,860 --> 00:52:18,670
但是最终您将能够。 

1142
00:52:18,869 --> 00:52:20,829
同时，您会知道

1143
00:52:20,829 --> 00:52:22,319
 SwiftUI中发生了什么。 

1144
00:52:25,289 --> 00:52:28,230
所以我只是把这张幻灯片放在这里，关于枚举， 

1145
00:52:28,230 --> 00:52:33,230
但是再一次，在本讲座中，我们将不再讨论枚举。 

1146
00:52:33,880 --> 00:52:36,492
我们会尽快谈论，不用担心。 

1147
00:52:37,440 --> 00:52:40,320
所以这几乎涵盖了我们要做的事情

1148
00:52:40,320 --> 00:52:42,269
今天谈论建筑

1149
00:52:42,469 --> 00:52:46,209
我们几乎涵盖了整个主题。 

1150
00:52:46,210 --> 00:52:48,119
现在我要完全换档

1151
00:52:48,119 --> 00:52:52,409
然后转到一个完全不同的主题，即布局， 

1152
00:52:52,409 --> 00:52:54,369
换句话说，我们如何决定

1153
00:52:54,369 --> 00:52:57,259
屏幕上所有视图的位置？ 

1154
00:52:57,260 --> 00:53:00,840
 SwiftUI做到这一点的方法非常简单。 

1155
00:53:01,039 --> 00:53:04,400
这是所有SwiftUI中最精美的东西之一。 

1156
00:53:04,400 --> 00:53:07,230
确实只有三个步骤。 

1157
00:53:07,230 --> 00:53:10,360
第一个是容器Views， 

1158
00:53:10,360 --> 00:53:13,420
例如HStacks和VStacks之类的东西。 

1159
00:53:13,420 --> 00:53:17,480
它们为内部的视图提供了空间。 

1160
00:53:17,480 --> 00:53:21,130
然后，这些视图自行选择尺寸， 

1161
00:53:21,130 --> 00:53:22,480
他们想要成为什么。 

1162
00:53:22,679 --> 00:53:23,929
根据该报价， 

1163
00:53:23,929 --> 00:53:26,119
他们可以选择与报价相同的尺寸， 

1164
00:53:26,119 --> 00:53:27,339
这是最常见的

1165
00:53:27,340 --> 00:53:29,480
他们可以选择比报价要小的尺寸， 

1166
00:53:29,480 --> 00:53:32,742
他们可以选择比报价更大的尺寸。 

1167
00:53:32,742 --> 00:53:35,739
因此，它们以一种很好的封装方式使用

1168
00:53:35,739 --> 00:53:38,609
视图决定了它们的大小。 

1169
00:53:38,610 --> 00:53:40,210
没有人告诉他们要多大。 

1170
00:53:40,210 --> 00:53:42,829
他们决定，我们只是为他们提供空间。 

1171
00:53:42,829 --> 00:53:46,909
但是之后，容器Views就像堆栈一样， 

1172
00:53:46,909 --> 00:53:50,559
将视图放置在自己的内部是他们的工作。 

1173
00:53:50,559 --> 00:53:52,969
就是这样，这是三个步骤

1174
00:53:52,969 --> 00:53:56,669
以便将所有内容布置在SwiftUI中。 

1175
00:53:56,670 --> 00:53:58,030
因此，让我们深入了解一下。 

1176
00:53:58,030 --> 00:54:00,690
让我们谈谈容器视图。 

1177
00:54:00,690 --> 00:54:02,480
所以最常见的容器视图

1178
00:54:02,480 --> 00:54:06,070
您已经熟悉的是HStack和VStack。 

1179
00:54:06,070 --> 00:54:08,103
当然，还有Zstack 

1180
00:54:08,302 --> 00:54:10,619
这种堆叠在一起

1181
00:54:10,619 --> 00:54:13,079
但是HStack和VStack很有趣

1182
00:54:13,079 --> 00:54:16,429
因为他们将提供给他们的空间分开了

1183
00:54:16,429 --> 00:54:18,219
在所有子视图中

1184
00:54:18,219 --> 00:54:20,809
稍后我们将讨论其工作原理。 

1185
00:54:20,809 --> 00:54:25,009
 ForEach是一种不寻常的容器视图。 

1186
00:54:25,010 --> 00:54:28,840
它实际上推迟了定位

1187
00:54:28,840 --> 00:54:31,289
并调整其所在容器的尺寸， 

1188
00:54:31,489 --> 00:54:33,349
这就是为什么我们把CardViews 

1189
00:54:33,349 --> 00:54:35,719
将ForEach放入HStack中。 

1190
00:54:35,719 --> 00:54:39,719
因此，他们的ForEach正在推迟让HStack做出决定。 

1191
00:54:39,719 --> 00:54:44,349
布局中隐藏着的一件事是修饰符， 

1192
00:54:44,349 --> 00:54:46,739
例如点填充和其他。 

1193
00:54:46,739 --> 00:54:50,549
它们本质上包含它们修改的视图， 

1194
00:54:50,550 --> 00:54:51,880
如果你想这样想， 

1195
00:54:51,880 --> 00:54:55,090
其中一些元素（例如填充）进行布局。 

1196
00:54:55,090 --> 00:54:56,730
所以让我们再详细一点

1197
00:54:56,929 --> 00:55:00,339
关于HStack和VStack，最重要的一个

1198
00:55:00,340 --> 00:55:02,940
或至少是布局最多的一个。 

1199
00:55:03,139 --> 00:55:05,440
堆栈划分空间的方式

1200
00:55:05,440 --> 00:55:08,789
提供给他们的情况是平均分配的

1201
00:55:08,789 --> 00:55:13,400
然后他们首先将其提供给最不灵活的视图。 

1202
00:55:13,400 --> 00:55:15,119
那是什么意思呢？ 

1203
00:55:15,119 --> 00:55:20,119
因此，非常灵活的视图就是图像。 

1204
00:55:20,769 --> 00:55:22,969
所以我们还没有谈论图像

1205
00:55:22,969 --> 00:55:24,639
但这只是一个显示图像的视图， 

1206
00:55:24,639 --> 00:55:25,769
如您所想。 

1207
00:55:25,769 --> 00:55:28,639
当然，它希望是图像的大小， 

1208
00:55:28,639 --> 00:55:30,779
那种方式很不灵活。 

1209
00:55:30,780 --> 00:55:32,710
所以通常图像会得到

1210
00:55:32,710 --> 00:55:34,710
他们首先要的空间。 

1211
00:55:34,710 --> 00:55:37,559
另一个非常僵化的视图示例

1212
00:55:37,559 --> 00:55:40,750
文字不像图像那么僵化。 

1213
00:55:40,750 --> 00:55:42,849
文字总是想自行调整大小

1214
00:55:42,849 --> 00:55:46,289
使其内部的文本可以理解

1215
00:55:46,289 --> 00:55:48,829
但是它确实可以缩小一点

1216
00:55:48,829 --> 00:55:50,840
并在文本末尾加点号

1217
00:55:50,840 --> 00:55:52,880
正如我们稍后将在这里讨论的那样。 

1218
00:55:52,880 --> 00:55:56,539
因此，它不像图像那么灵活。 

1219
00:55:56,539 --> 00:55:59,059
而且大多数视图都非常灵活。 

1220
00:55:59,059 --> 00:56:00,570
例如，所有形状

1221
00:56:00,570 --> 00:56:02,980
就像我们看到的RoundedRectangle 

1222
00:56:02,980 --> 00:56:05,670
无论您提供什么尺寸，它都差不多

1223
00:56:05,670 --> 00:56:09,190
并且它将以该大小适当地绘制自身。 

1224
00:56:09,190 --> 00:56:13,349
因此，在其中一种视图选择了自己的尺寸之后

1225
00:56:13,349 --> 00:56:14,960
并采用所需的尺寸， 

1226
00:56:14,960 --> 00:56:18,260
从空间中删除了那个大小

1227
00:56:18,260 --> 00:56:20,090
堆栈正在尝试分配

1228
00:56:20,289 --> 00:56:24,360
然后进入下一个最不灵活的视图

1229
00:56:24,360 --> 00:56:26,432
冲洗并重复直到所有空间用完。 

1230
00:56:26,632 --> 00:56:28,089
就是这么简单。 

1231
00:56:28,090 --> 00:56:32,840
这就是HStack和VStack分配空间的方式。 

1232
00:56:32,840 --> 00:56:35,230
现在，在所有视图选择了它们的大小之后

1233
00:56:35,429 --> 00:56:40,069
然后HStack和VStack调整自身大小以适合这些视图

1234
00:56:40,070 --> 00:56:42,920
两者之间的间距很小。 

1235
00:56:44,000 --> 00:56:47,329
 HStack和VStack可以与任何View一起使用， 

1236
00:56:47,329 --> 00:56:48,269
但是有几个

1237
00:56:48,269 --> 00:56:50,219
我要在这里介绍给你

1238
00:56:50,219 --> 00:56:52,199
确实有助于布局。 

1239
00:56:52,199 --> 00:56:54,539
其中之一称为垫片。 

1240
00:56:54,539 --> 00:56:58,389
因此，Spacer只是一个占据所有空间的视图

1241
00:56:58,389 --> 00:56:59,639
提供给它。 

1242
00:56:59,639 --> 00:57:02,389
因此，如果您给它空间，它将使用该空间。 

1243
00:57:02,389 --> 00:57:04,609
因此，它用于填充空间。 

1244
00:57:04,610 --> 00:57:06,360
现在它实际上并没有画任何东西， 

1245
00:57:06,360 --> 00:57:09,820
只是浪费了HStack或VStack中的空间， 

1246
00:57:09,820 --> 00:57:11,539
这就是为什么它被称为垫片。 

1247
00:57:11,739 --> 00:57:14,029
它具有minLength参数

1248
00:57:14,030 --> 00:57:16,789
这是应该的最小尺寸

1249
00:57:16,989 --> 00:57:19,189
在我们水平布置的方向

1250
00:57:19,190 --> 00:57:22,329
还是垂直，具体取决于是HStack还是VStack， 

1251
00:57:22,329 --> 00:57:24,000
尽管我们通常不指定

1252
00:57:24,000 --> 00:57:26,820
因为默认值是正确的金额

1253
00:57:26,820 --> 00:57:28,750
在这个平台上的空间。 

1254
00:57:28,949 --> 00:57:30,389
你要开始的一件事

1255
00:57:30,389 --> 00:57:31,853
习惯了本季度的发展， 

1256
00:57:31,853 --> 00:57:35,039
即使我们专注于iOS， 

1257
00:57:35,039 --> 00:57:39,250
您可以在Apple Watch和Apple TV上使用SwiftUI 

1258
00:57:39,250 --> 00:57:42,449
间距和布局有些不同

1259
00:57:42,449 --> 00:57:43,759
在这些平台上。 

1260
00:57:43,760 --> 00:57:47,190
 SwiftUI真的很聪明地说： 

1261
00:57:47,389 --> 00:57:50,339
我在Apple Watch上，所以我要用这么多空间

1262
00:57:50,340 --> 00:57:52,300
默认情况下在我的垫片中。 

1263
00:57:52,300 --> 00:57:55,539
这就是为什么我们真正想要尝试使用这些默认值的原因

1264
00:57:55,539 --> 00:57:59,329
并且在使用Spacer时不指定minLength。 

1265
00:57:59,329 --> 00:58:01,605
 HStack本身也有间距

1266
00:58:01,605 --> 00:58:02,471
 HStack间距。 

1267
00:58:02,471 --> 00:58:03,469
而且我们不想那样做。 

1268
00:58:03,469 --> 00:58:06,789
即使是填充，通常也可以放填充

1269
00:58:06,789 --> 00:58:08,880
但是如果你开始把数字放在那里

1270
00:58:08,880 --> 00:58:12,349
并像我们看到的那样指定确切的填充， 

1271
00:58:12,349 --> 00:58:13,639
你在打败一点

1272
00:58:13,639 --> 00:58:15,670
此平台独立性的目的。 

1273
00:58:15,670 --> 00:58:18,000
现在，有时您需要它，您只需

1274
00:58:18,199 --> 00:58:21,739
但是我们尝试尽可能多地使用这些默认值。 

1275
00:58:21,739 --> 00:58:23,596
因此，另一个很酷的View可以放入HStack 

1276
00:58:23,597 --> 00:58:25,420
或VStack是Divider。 

1277
00:58:25,619 --> 00:58:28,269
所以分频器只是画一条分界线， 

1278
00:58:28,269 --> 00:58:29,679
同样，特定于平台

1279
00:58:29,679 --> 00:58:31,879
这取决于分隔线的外观

1280
00:58:31,880 --> 00:58:33,960
在它的上下文中。 

1281
00:58:33,960 --> 00:58:37,210
当然，分频器不像垫片

1282
00:58:37,210 --> 00:58:38,400
它不会占用所有的空间。 

1283
00:58:38,400 --> 00:58:41,519
它仅使用足够的空间来绘制该线。 

1284
00:58:41,519 --> 00:58:44,369
而且该线显然与方向相反

1285
00:58:44,369 --> 00:58:45,219
我们正在布局。 

1286
00:58:45,219 --> 00:58:47,980
因此，对于HStack来说，分频器显然是

1287
00:58:47,980 --> 00:58:49,440
垂直线，对于VStack， 

1288
00:58:49,440 --> 00:58:51,639
这将是一条水平线。 

1289
00:58:51,639 --> 00:58:54,989
所以您几乎肯定会想要使用一个

1290
00:58:54,989 --> 00:58:58,179
或在下一个作业中同时使用这两种方法。 

1291
00:58:58,179 --> 00:59:01,919
它们对于使用堆栈进行布局真的很有价值。 

1292
00:59:01,920 --> 00:59:03,250
这些HStack和VStack， 

1293
00:59:03,250 --> 00:59:05,809
我告诉过你他们是有选择的

1294
00:59:05,809 --> 00:59:10,809
它的哪些观点为下一个优先领域提供了空间

1295
00:59:11,349 --> 00:59:13,039
用这个最不灵活的东西， 

1296
00:59:13,039 --> 00:59:15,059
但实际上您可以覆盖

1297
00:59:15,059 --> 00:59:18,029
使用此视图修改器layoutPriority。 

1298
00:59:18,030 --> 00:59:20,480
这是一个HStack的例子

1299
00:59:20,480 --> 00:59:22,869
它的文本非常重要。 

1300
00:59:22,869 --> 00:59:26,349
它有一张我们知道非常不灵活的图片， 

1301
00:59:26,349 --> 00:59:29,849
因此通常会引起HStack的关注。 

1302
00:59:29,849 --> 00:59:33,549
然后有另一个不那么重要的文本。 

1303
00:59:33,550 --> 00:59:38,420
所以我添加了View修饰符点layoutPriority 100 

1304
00:59:38,420 --> 00:59:40,530
我可以选择任何我真正想要的号码， 

1305
00:59:40,530 --> 00:59:42,400
没关系，这是一个浮点数。 

1306
00:59:42,400 --> 00:59:45,329
这不仅仅是默认的layoutPriority 

1307
00:59:45,329 --> 00:59:46,289
这是零。 

1308
00:59:46,289 --> 00:59:48,820
因此，当该HStack提供其空间时， 

1309
00:59:48,820 --> 00:59:51,610
它将首先提供此文本空间。 

1310
00:59:51,610 --> 00:59:53,210
那文本会说， 

1311
00:59:53,210 --> 00:59:54,880
好吧，当然，我想变得这么大

1312
00:59:54,880 --> 00:59:58,110
所以我可以很重要地一直使用这个词

1313
00:59:58,110 --> 00:59:59,250
那会说，好吧， 

1314
00:59:59,449 --> 01:00:01,599
好吧，没有其他高优先级的产品了。 

1315
01:00:01,599 --> 01:00:03,769
可能还有其他数字不同的数字。 

1316
01:00:03,769 --> 01:00:05,949
它以最高优先级开始，然后下降。 

1317
01:00:05,949 --> 01:00:07,649
所以现在去做图像

1318
01:00:07,650 --> 01:00:09,730
因为它不如文本灵活， 

1319
01:00:09,929 --> 01:00:13,009
图像获得空​​间，然后不重要的文本出现

1320
01:00:13,010 --> 01:00:15,960
以适应剩余的空间。 

1321
01:00:15,960 --> 01:00:17,250
正如我们之前提到的

1322
01:00:17,250 --> 01:00:19,530
当文本没有足够的空间时， 

1323
01:00:19,530 --> 01:00:23,269
它会在其中放点

1324
01:00:23,269 --> 01:00:26,630
或缩短文本以适合其实际空间。 

1325
01:00:26,630 --> 01:00:28,039
它一直想成为它的空间。 

1326
01:00:28,039 --> 01:00:31,679
它从不希望超出其文本的大小。 

1327
01:00:31,679 --> 01:00:33,239
它总是想要确切的尺寸

1328
01:00:33,239 --> 01:00:34,969
但是如果被迫变小， 

1329
01:00:34,969 --> 01:00:36,682
它知道如何做点点。 

1330
01:00:37,650 --> 01:00:40,987
 HStack的另一个重要部分

1331
01:00:40,987 --> 01:00:44,579
 VStack的布局就是它们的一致性。 

1332
01:00:44,579 --> 01:00:48,349
因此，假设您有一个VStack，即垂直的View堆栈。 

1333
01:00:48,349 --> 01:00:50,960
如果这些视图自行选择大小

1334
01:00:50,960 --> 01:00:53,059
它们的宽度不一样。 

1335
01:00:53,059 --> 01:00:56,029
所以它们不能全部填满整个宽度

1336
01:00:56,030 --> 01:00:57,289
这个垂直堆栈。 

1337
01:00:57,489 --> 01:00:59,799
 VStack也会左对齐吗

1338
01:00:59,800 --> 01:01:02,070
或将它们居中或使其对齐？ 

1339
01:01:02,070 --> 01:01:04,809
它怎么知道将它们放在哪里？ 

1340
01:01:04,809 --> 01:01:07,610
好吧，实际上有一个关于VStack和HStack的争论。 

1341
01:01:07,610 --> 01:01:08,277
我们已经知道VStack 

1342
01:01:08,476 --> 01:01:11,029
和HStack具有参数间距

1343
01:01:11,030 --> 01:01:13,360
确定视图之间的间距。 

1344
01:01:13,559 --> 01:01:16,119
它还有另一个论点，对齐。 

1345
01:01:16,119 --> 01:01:19,579
对齐方式以对齐方式为准。 

1346
01:01:19,579 --> 01:01:23,259
例如，其中一个对齐向导处于领先地位。 

1347
01:01:23,260 --> 01:01:27,250
现在，为什么要领导这里而不是离开？ 

1348
01:01:27,250 --> 01:01:28,710
如果我只想要这个VStack 

1349
01:01:28,710 --> 01:01:30,289
使所有这些保持对齐， 

1350
01:01:30,289 --> 01:01:31,237
我为什么不说左点？ 

1351
01:01:31,237 --> 01:01:34,349
实际上，不存在像点这样的东西。 

1352
01:01:34,349 --> 01:01:38,130
点领导意味着拥有事物

1353
01:01:38,130 --> 01:01:41,460
在VStack中排列，以便其边缘开始

1354
01:01:41,460 --> 01:01:44,050
文字的来源

1355
01:01:44,050 --> 01:01:46,460
有时用不同的语言来文字

1356
01:01:46,460 --> 01:01:48,019
从右边移到左边， 

1357
01:01:48,219 --> 01:01:49,839
像希伯来语和阿拉伯语。 

1358
01:01:49,840 --> 01:01:54,269
因此，我们希望我们的VStack一般能够匹配

1359
01:01:54,469 --> 01:01:56,372
文字来自那一边。 

1360
01:01:57,750 --> 01:02:00,460
文本基线也可以排列。 

1361
01:02:00,460 --> 01:02:04,019
因此，HStacks，仅在HStack中才有意义。 

1362
01:02:04,019 --> 01:02:06,449
您可以将其对齐，以使文本的底部， 

1363
01:02:06,449 --> 01:02:09,379
即使它们是不同的字体，也会全部对齐。 

1364
01:02:09,380 --> 01:02:11,900
对于您所熟悉的字体，有两个基准。 

1365
01:02:11,900 --> 01:02:12,829
我不会谈论这个

1366
01:02:12,829 --> 01:02:15,150
但您可以与第一个文本基线对齐

1367
01:02:15,150 --> 01:02:18,570
或HStack中的第二个文本基线。 

1368
01:02:18,570 --> 01:02:20,800
您甚至可以定义自己的东西

1369
01:02:20,800 --> 01:02:23,480
对齐对齐指南。 

1370
01:02:23,679 --> 01:02:26,210
这超出了本课程的范围。 

1371
01:02:26,210 --> 01:02:29,250
所以我们将使用点中心等内置的

1372
01:02:29,250 --> 01:02:31,280
通常默认的对齐方式是

1373
01:02:31,280 --> 01:02:32,670
把东西居中

1374
01:02:32,869 --> 01:02:34,869
 VStack或HStack。 

1375
01:02:34,869 --> 01:02:35,809
但也有顶部

1376
01:02:35,809 --> 01:02:38,279
和底部尾随这些东西。 

1377
01:02:38,280 --> 01:02:40,090
可以想象，当您开始输入时

1378
01:02:40,289 --> 01:02:42,539
在Xcode，VStack对齐冒号中， 

1379
01:02:42,539 --> 01:02:44,329
当然，Xcode会帮助您并告诉您

1380
01:02:44,329 --> 01:02:46,523
这些内置的东西是什么。 

1381
01:02:48,619 --> 01:02:50,746
堆栈就是这样。 

1382
01:02:50,746 --> 01:02:52,130
堆栈非常重要。 

1383
01:02:52,130 --> 01:02:54,019
但是还有另外一件事，修饰符

1384
01:02:54,219 --> 01:02:57,429
像点填充一样，我说的是一种行为

1385
01:02:57,429 --> 01:03:00,179
就像是容器视图

1386
01:03:00,179 --> 01:03:03,460
请记住，点填充等这些东西， 

1387
01:03:03,460 --> 01:03:05,369
他们返回一个视图。 

1388
01:03:05,369 --> 01:03:07,319
您可能以为他们只是返回一个View 

1389
01:03:07,320 --> 01:03:09,420
这样我们就可以再寄给他们

1390
01:03:09,619 --> 01:03:12,049
在它们上调用另一个函数，点groundColor 

1391
01:03:12,050 --> 01:03:13,860
然后给我们一个View， 

1392
01:03:14,059 --> 01:03:15,029
我们称其为点填充。 

1393
01:03:15,030 --> 01:03:18,610
这给了我们一个View，并在其上调用了点字体。 

1394
01:03:18,809 --> 01:03:20,849
因此，不只是给我们一个“视图” 

1395
01:03:20,849 --> 01:03:23,150
因此我们可以在其上调用另一个函数。 

1396
01:03:23,150 --> 01:03:26,880
那些返回的视图实际上可能正在参与

1397
01:03:26,880 --> 01:03:28,590
在布局中。 

1398
01:03:28,590 --> 01:03:30,559
现在，大多数人不参加， 

1399
01:03:30,559 --> 01:03:32,320
像font和foregroundColor。 

1400
01:03:32,320 --> 01:03:36,380
它们不会影响布局，因此可以提供任何空间

1401
01:03:36,380 --> 01:03:38,010
通过HStack或其他容器， 

1402
01:03:38,010 --> 01:03:42,090
他们只是将其传递给包含的任何视图。 

1403
01:03:42,289 --> 01:03:44,009
为了这张幻灯片的目的，我们将认为

1404
01:03:44,010 --> 01:03:48,170
这些修饰符被修改为包含的视图的外观

1405
01:03:48,170 --> 01:03:52,440
根据该视图，修饰符返回的是它的种类。 

1406
01:03:52,440 --> 01:03:56,860
我们将在下周看到如何制作这些视图修饰符， 

1407
01:03:56,860 --> 01:04:00,019
大概还是下一周，取决于情况如何。 

1408
01:04:00,019 --> 01:04:01,670
你会看到那种真的

1409
01:04:01,670 --> 01:04:03,420
发生的是它包含

1410
01:04:03,420 --> 01:04:04,980
正在修改的视图。 

1411
01:04:04,980 --> 01:04:08,829
这些实际参与的修饰符呢？ 

1412
01:04:08,829 --> 01:04:10,960
在布局过程中像填充。 

1413
01:04:10,960 --> 01:04:12,840
让我们看一下填充。 

1414
01:04:12,840 --> 01:04:16,579
点填充，此修饰符返回的视图， 

1415
01:04:16,579 --> 01:04:20,559
它提供了它正在修改空间的视图

1416
01:04:20,559 --> 01:04:23,449
与提供的尺寸相同

1417
01:04:23,449 --> 01:04:25,909
但在这种情况下降低了10分， 

1418
01:04:25,909 --> 01:04:26,879
无论填充是什么。 

1419
01:04:26,880 --> 01:04:28,500
如果那10个不存在， 

1420
01:04:28,699 --> 01:04:31,869
那么它将是任何适合系统的填充。 

1421
01:04:31,869 --> 01:04:33,969
基本上是删除那10个

1422
01:04:33,969 --> 01:04:36,619
因为它知道应该提供10。 

1423
01:04:36,619 --> 01:04:38,819
然后返回该视图

1424
01:04:38,820 --> 01:04:40,960
通过填充选择自己的尺寸

1425
01:04:41,159 --> 01:04:43,599
东西大小

1426
01:04:43,599 --> 01:04:46,299
它正在修改最终是加10。 

1427
01:04:46,300 --> 01:04:47,670
这就是填充的作用

1428
01:04:47,670 --> 01:04:51,500
它在外面增加了10点

1429
01:04:51,500 --> 01:04:53,969
或您所说的任何优势。 

1430
01:04:53,969 --> 01:04:55,480
另一件事是修改。 

1431
01:04:55,480 --> 01:04:59,429
因此，您将看到点填充修饰符只是一个视图

1432
01:04:59,429 --> 01:05:01,899
参与布局。 

1433
01:05:01,900 --> 01:05:03,440
另一个例子是什么？ 

1434
01:05:03,440 --> 01:05:05,340
您已经在作业中使用了它， 

1435
01:05:05,340 --> 01:05:07,150
点宽高比。 

1436
01:05:07,349 --> 01:05:10,420
点AspectRatio修饰符返回的View， 

1437
01:05:10,420 --> 01:05:12,769
它占用了提供的空间

1438
01:05:12,769 --> 01:05:15,059
并自行选择大小

1439
01:05:15,059 --> 01:05:18,039
小于提供的尺寸

1440
01:05:18,039 --> 01:05:19,759
并具有长宽比， 

1441
01:05:19,760 --> 01:05:22,840
那就是如果我们选择AspectRatio的点拟合选项， 

1442
01:05:23,039 --> 01:05:26,269
或者它可能大于所提供的大小， 

1443
01:05:26,269 --> 01:05:30,610
这是使用所有提供的空间的点填充选项。 

1444
01:05:30,610 --> 01:05:33,090
因此，是的，当您使用View时， 

1445
01:05:33,090 --> 01:05:34,590
当您有一定的空间时， 

1446
01:05:34,590 --> 01:05:37,210
您可以选择更大的尺寸。 

1447
01:05:37,210 --> 01:05:39,059
现在很少见了。 

1448
01:05:39,059 --> 01:05:41,389
我们通常不希望Views溢出

1449
01:05:41,389 --> 01:05:44,359
互相贯穿，但这是有道理的， 

1450
01:05:44,360 --> 01:05:47,780
像在这方面比率填充，也许这是有道理的。 

1451
01:05:47,780 --> 01:05:51,090
因此，现在调整自身大小的AspectRatio视图

1452
01:05:51,090 --> 01:05:55,230
具有长宽比，提供它选择的空间

1453
01:05:55,230 --> 01:05:58,849
修改它的任何视图，例如CardView。 

1454
01:05:58,849 --> 01:06:00,920
这样我们的CardView就适合自己了

1455
01:06:00,920 --> 01:06:03,063
在那个不错的宽高比空间中。 

1456
01:06:04,550 --> 01:06:08,170
我们来看一个完整布局的例子

1457
01:06:08,369 --> 01:06:10,829
在传递的大小之类的东西上。 

1458
01:06:10,829 --> 01:06:14,809
所以这是一个类似于我们的HStack 

1459
01:06:14,809 --> 01:06:17,909
在我们的记忆游戏中，并不完全相同

1460
01:06:17,909 --> 01:06:19,429
但非常相似

1461
01:06:19,429 --> 01:06:23,309
这个东西的空间如何分配？ 

1462
01:06:23,309 --> 01:06:24,639
好，首先要了解的是

1463
01:06:24,639 --> 01:06:27,509
将提供空间的第一个视图

1464
01:06:27,510 --> 01:06:31,880
整个绿色元素就是填充视图。 

1465
01:06:31,880 --> 01:06:33,130
这是最外面的视图。 

1466
01:06:33,130 --> 01:06:37,630
最终，实际上就是视图

1467
01:06:37,630 --> 01:06:40,079
但无论有多少空间都会提供

1468
01:06:40,079 --> 01:06:42,639
对于这里的整个绿色建筑。 

1469
01:06:42,639 --> 01:06:45,940
现在要做的是减少

1470
01:06:45,940 --> 01:06:48,510
从它的边缘拿走10分

1471
01:06:48,510 --> 01:06:52,269
并将剩下的空间传递到下一个视图

1472
01:06:52,469 --> 01:06:56,649
这是前景色修改器返回的视图。 

1473
01:06:56,650 --> 01:06:59,630
现在，修饰符并没有真正参与布局， 

1474
01:06:59,630 --> 01:07:01,820
确实对尺寸没有任何影响

1475
01:07:01,820 --> 01:07:02,650
摆好东西

1476
01:07:02,849 --> 01:07:07,429
因此它只是将其原封不动地传递给HStack。 

1477
01:07:07,429 --> 01:07:11,309
现在，众所周知，HStack是大型布局视图。 

1478
01:07:11,309 --> 01:07:15,239
它将开始平均分配其空间

1479
01:07:15,239 --> 01:07:18,959
由于aspectRatio不是像Images这样的东西

1480
01:07:18,960 --> 01:07:20,760
或固定大小的文字， 

1481
01:07:20,760 --> 01:07:23,250
最终将空间平均分配

1482
01:07:23,449 --> 01:07:27,879
在ForEach的所有AspectRatio视图中， 

1483
01:07:27,880 --> 01:07:30,610
因为我们知道ForEach本身就顺应了

1484
01:07:30,610 --> 01:07:31,980
到HStack。 

1485
01:07:31,980 --> 01:07:34,389
所以现在是aspectRatio Views 

1486
01:07:34,389 --> 01:07:36,960
正在HStack中进行布局。 

1487
01:07:36,960 --> 01:07:39,789
每个aspectRatio视图将设置其宽度

1488
01:07:39,989 --> 01:07:42,639
占HStack宽度的份额

1489
01:07:42,639 --> 01:07:45,269
然后选择与宽高比匹配的高度， 

1490
01:07:45,269 --> 01:07:49,659
 2/3的宽高比，或者如果此处的高度受限制， 

1491
01:07:49,659 --> 01:07:51,159
可能是相反的方式

1492
01:07:51,159 --> 01:07:53,649
其中aspectRatio视图占所有

1493
01:07:53,650 --> 01:07:56,809
所提供的高度，而是选择宽度

1494
01:07:56,809 --> 01:07:58,559
那不太适合。 

1495
01:07:58,559 --> 01:07:59,630
因此，它可能以任何方式进行。 

1496
01:07:59,630 --> 01:08:02,269
这取决于哪个最合适

1497
01:08:02,469 --> 01:08:04,829
在提供的空间中。 

1498
01:08:04,829 --> 01:08:07,679
然后AspectRatio选择了该大小。 

1499
01:08:07,679 --> 01:08:09,629
它将提供给CardView 

1500
01:08:09,630 --> 01:08:11,670
而CardView将使用所有空间

1501
01:08:11,670 --> 01:08:13,409
因为就像普通的视图一样

1502
01:08:13,409 --> 01:08:16,949
无论您提供多少空间，它几乎都会被使用。 

1503
01:08:16,949 --> 01:08:20,579
在所有这些提供和调整大小之后， 

1504
01:08:20,579 --> 01:08:23,619
整个绿色视图的大小将是多少？ 

1505
01:08:23,619 --> 01:08:24,729
好吧，这将是大小

1506
01:08:24,729 --> 01:08:27,009
任何View.padding 10返回

1507
01:08:27,010 --> 01:08:30,289
这是HStack调整自身大小的结果

1508
01:08:30,289 --> 01:08:32,449
适合所有这些方面

1509
01:08:32,449 --> 01:08:34,789
在各方面加10分。 

1510
01:08:34,789 --> 01:08:38,109
那将是整个绿色物体的大小。 

1511
01:08:38,109 --> 01:08:40,289
让我们来讨论一下占据所有空间的视图

1512
01:08:40,289 --> 01:08:41,609
提供给他们。 

1513
01:08:41,609 --> 01:08:43,420
显然，诸如RoundedRectangle， 

1514
01:08:43,420 --> 01:08:44,819
对他们来说真的很容易。 

1515
01:08:44,819 --> 01:08:47,920
他们只是一直沿矩形爬行到边缘

1516
01:08:47,920 --> 01:08:50,109
他们所提供的。 

1517
01:08:50,109 --> 01:08:52,889
但是，像CardView这样的自定义视图呢？ 

1518
01:08:52,890 --> 01:08:55,220
我们使用ZStack构建的CardView 

1519
01:08:55,220 --> 01:08:58,029
使用RoundedRectangle，Texts，我们正在构建此东西。 

1520
01:08:58,229 --> 01:09:00,899
它占用了所有提供的空间， 

1521
01:09:00,899 --> 01:09:02,449
而且没有理由不应该

1522
01:09:02,449 --> 01:09:05,079
但它确实应该适应自己

1523
01:09:05,079 --> 01:09:06,949
到提供的任何空间。 

1524
01:09:06,949 --> 01:09:09,170
我们真的拼命地看到了这一点

1525
01:09:09,170 --> 01:09:11,489
带有表情符号的字体大小。 

1526
01:09:11,689 --> 01:09:13,109
在你的作业中我问你

1527
01:09:13,109 --> 01:09:16,439
用于将很小的卡片切换为较小的字体。 

1528
01:09:16,439 --> 01:09:17,879
而且我相信您可能会意识到， 

1529
01:09:17,880 --> 01:09:21,289
哇，这真是解决这个问题的好方法。 

1530
01:09:21,289 --> 01:09:22,539
当然是。 

1531
01:09:22,539 --> 01:09:25,939
确实，在演示中我们需要做的是，我们要做的， 

1532
01:09:25,939 --> 01:09:29,359
选择相关的字体大小

1533
01:09:29,359 --> 01:09:31,219
到提供的尺寸。 

1534
01:09:31,220 --> 01:09:33,539
由于我们要接受提供给我们的尺寸， 

1535
01:09:33,539 --> 01:09:36,720
我们应该选择适合的字体大小。 

1536
01:09:36,720 --> 01:09:40,600
那么，视图如何知道为其提供了什么空间

1537
01:09:40,600 --> 01:09:44,333
并可以做出例如字体选择的决定？ 

1538
01:09:44,533 --> 01:09:46,389
好吧，我们使用特殊的视图来实现。 

1539
01:09:46,390 --> 01:09:48,500
它只是一个视图，但是有点特殊， 

1540
01:09:48,500 --> 01:09:51,130
称为GeometryReader。 

1541
01:09:51,130 --> 01:09:53,680
以及您使用GeometryReader视图做什么

1542
01:09:53,680 --> 01:09:56,369
它包裹着您想要的任何东西吗

1543
01:09:56,569 --> 01:09:58,969
适应大小。 

1544
01:09:58,970 --> 01:10:01,529
因此，这通常会吸收您体内的任何物质

1545
01:10:01,729 --> 01:10:05,809
您只需像这样将GeometryReader包裹起来即可。 

1546
01:10:05,810 --> 01:10:07,420
 GeometryReader只是一个视图。 

1547
01:10:07,420 --> 01:10:11,092
我没有在这里向您展示显而易见的东西。 

1548
01:10:11,092 --> 01:10:13,539
 GeometryReader，开括号，内容， 

1549
01:10:13,539 --> 01:10:16,090
冒号，所有这些，就像在HStack中一样

1550
01:10:16,090 --> 01:10:17,960
这仅仅是内容。 

1551
01:10:17,960 --> 01:10:20,840
但是您确实注意到那里有一点争论

1552
01:10:20,840 --> 01:10:23,949
几何形状，类似于ForEach具有参数的方式

1553
01:10:23,949 --> 01:10:25,739
这就是我们要迭代的事情。 

1554
01:10:25,739 --> 01:10:27,652
这也有一个论点。 

1555
01:10:28,659 --> 01:10:31,930
因此，此参数的类型为GeometryProxy。 

1556
01:10:32,984 --> 01:10:35,246
而这个GeometryProxy只是一个结构

1557
01:10:35,247 --> 01:10:37,067
它里面有一些很好的信息， 

1558
01:10:37,067 --> 01:10:39,640
最重要的是您看到的第一个

1559
01:10:39,640 --> 01:10:43,430
 var size，即您所提供的大小。 

1560
01:10:43,430 --> 01:10:46,119
宽度和高度CGSize是宽度和高度

1561
01:10:46,319 --> 01:10:47,197
被提供给你。 

1562
01:10:47,197 --> 01:10:49,556
您可以使用该尺寸，以磅为单位， 

1563
01:10:49,556 --> 01:10:51,420
当然，字体大小以磅为单位。 

1564
01:10:51,420 --> 01:10:52,760
所以对我们来说这很容易

1565
01:10:52,760 --> 01:10:56,680
选择适合该大小的字体大小。 

1566
01:10:56,680 --> 01:10:58,409
你在这里看到其他一些东西， 

1567
01:10:58,409 --> 01:11:00,760
像框架实际上不仅大小

1568
01:11:00,760 --> 01:11:03,159
但这是一个矩形

1569
01:11:03,359 --> 01:11:05,279
在某个坐标空间

1570
01:11:05,279 --> 01:11:08,639
我们的父母坐标空间或全局坐标空间

1571
01:11:08,640 --> 01:11:12,079
我们甚至可以看一下是否愿意。 

1572
01:11:12,079 --> 01:11:13,739
我要谈谈那里的最后一个， 

1573
01:11:13,739 --> 01:11:16,143
 safeAreaInsets，在下一张幻灯片上。 

1574
01:11:17,350 --> 01:11:19,850
关于GeometeryReader要记住的一件事， 

1575
01:11:19,850 --> 01:11:23,960
它只是一个视图，但它始终接受

1576
01:11:23,960 --> 01:11:25,542
提供给它的空间。 

1577
01:11:26,560 --> 01:11:29,842
我强调这是因为它需要一点点沉入

1578
01:11:30,042 --> 01:11:33,889
因为你不想在这里进入递归循环

1579
01:11:33,890 --> 01:11:37,090
 GeometryReader正在读取其大小的位置

1580
01:11:37,090 --> 01:11:39,239
然后您尝试实际更改大小

1581
01:11:39,239 --> 01:11:41,849
基于GeometryReader读取的大小。 

1582
01:11:41,850 --> 01:11:42,619
那样行不通。 

1583
01:11:42,819 --> 01:11:46,329
 GeometryReader始终接受大小，空间， 

1584
01:11:46,329 --> 01:11:47,162
提供给他们的， 

1585
01:11:47,162 --> 01:11:48,489
你必须这样想。 

1586
01:11:48,489 --> 01:11:51,670
因此，GeometryReaders实用程序受到限制

1587
01:11:51,670 --> 01:11:54,210
知道您要提供的尺寸

1588
01:11:54,210 --> 01:11:56,670
并调整您的内在外观， 

1589
01:11:56,670 --> 01:11:58,130
这就是GeometryReader的目的。 

1590
01:11:58,130 --> 01:12:01,869
不要试图将GeometryReader变成不是的东西。 

1591
01:12:01,869 --> 01:12:03,510
它只是在读取您的几何图形。 

1592
01:12:03,510 --> 01:12:04,800
它叫做GeometryReader，它读取几何

1593
01:12:06,720 --> 01:12:09,579
并适应它，以便可以更改字体

1594
01:12:09,579 --> 01:12:10,693
之类的。 

1595
01:12:12,539 --> 01:12:14,519
我们提到的安全区， 

1596
01:12:14,520 --> 01:12:15,353
该safeAreaInsets 

1597
01:12:15,353 --> 01:12:18,130
 GeometryReader告诉您的信息。 

1598
01:12:18,130 --> 01:12:21,739
通过思考可以最好地可视化安全区域

1599
01:12:21,739 --> 01:12:24,170
 iPhone 10上的缺口

1600
01:12:24,170 --> 01:12:27,149
大多数时候，你不想草拟

1601
01:12:27,149 --> 01:12:29,119
根据缺口所在的尺寸， 

1602
01:12:29,119 --> 01:12:30,399
并非总是如此。 

1603
01:12:30,399 --> 01:12:33,099
有时您可能实际上想在那里画画。 

1604
01:12:33,100 --> 01:12:34,890
还有其他安全区域的事情。 

1605
01:12:34,890 --> 01:12:37,289
有时，视图会添加装饰

1606
01:12:37,289 --> 01:12:40,090
或他们在屏幕上绘画的方式

1607
01:12:40,090 --> 01:12:42,680
他们不希望您在某些空间中绘画的地方

1608
01:12:42,680 --> 01:12:46,250
因此他们会创建一个安全区域供您使用。 

1609
01:12:46,250 --> 01:12:49,630
但是，如果您想离开自己的安全区域，则可以， 

1610
01:12:49,630 --> 01:12:50,989
而你这样做的方式是

1611
01:12:50,989 --> 01:12:54,386
通过此处的View修饰符edgeIgnoringSafeArea， 

1612
01:12:54,386 --> 01:12:57,159
然后指定所需的边缘

1613
01:12:57,159 --> 01:12:58,930
忽略那个安全区域。 

1614
01:12:58,930 --> 01:13:01,529
因此，如果我说edgesIgnoringSafeArea回到顶部， 

1615
01:13:01,729 --> 01:13:04,069
然后ZStack及其所有内容

1616
01:13:04,069 --> 01:13:06,799
忽略顶部有安全区域

1617
01:13:06,800 --> 01:13:10,789
然后就在那刻痕的下方画上去

1618
01:13:10,789 --> 01:13:13,529
因此，它可能是照片查看应用程序之类的东西， 

1619
01:13:13,529 --> 01:13:15,460
也许你想一直到边缘

1620
01:13:15,460 --> 01:13:16,672
所以你可以在这里做。 

1621
01:13:18,869 --> 01:13:20,149
让我们谈一点

1622
01:13:20,149 --> 01:13:22,509
容器如何工作

1623
01:13:22,510 --> 01:13:25,869
这是为其视图提供空间，然后定位它们的位置。 

1624
01:13:25,869 --> 01:13:29,319
它为此修改器框架提供了空间。 

1625
01:13:29,319 --> 01:13:32,289
现在，我在这里不再详细讨论框架。 

1626
01:13:32,289 --> 01:13:34,329
你可以去看看文件架

1627
01:13:34,329 --> 01:13:36,420
有很多争论，你知道， 

1628
01:13:36,420 --> 01:13:39,909
理想宽度，最小宽度，所有这些种类的东西

1629
01:13:39,909 --> 01:13:44,909
尝试与景观交流，这里是空间

1630
01:13:44,920 --> 01:13:46,103
我在给你。 

1631
01:13:47,069 --> 01:13:48,409
这就是空间。 

1632
01:13:48,409 --> 01:13:51,159
然后，视图选择了自己的尺寸后， 

1633
01:13:51,159 --> 01:13:53,899
那么我们将使用这个修饰符位置

1634
01:13:53,899 --> 01:13:56,389
把它放在我们坐标空间的某个地方

1635
01:13:56,390 --> 01:13:57,600
在容器之前。 

1636
01:13:57,600 --> 01:14:00,699
因此，他们就是这样做的。 

1637
01:14:00,899 --> 01:14:02,219
非常简单。 

1638
01:14:02,220 --> 01:14:05,810
例如，堆栈将使用其对齐信息

1639
01:14:05,810 --> 01:14:08,630
以及所有的间距

1640
01:14:08,630 --> 01:14:10,970
弄清楚他们的观点应该去哪里， 

1641
01:14:10,970 --> 01:14:13,329
它会设置这个CGPoint 

1642
01:14:13,329 --> 01:14:16,340
这是CGPoint视图的中心

1643
01:14:16,340 --> 01:14:17,819
对于每个视图。 

1644
01:14:17,819 --> 01:14:20,279
顺便说一句，这里有点酷

1645
01:14:20,279 --> 01:14:23,759
称为偏移量，它将偏移视图

1646
01:14:23,760 --> 01:14:25,279
从容器放到哪里。 

1647
01:14:25,479 --> 01:14:27,529
因此，您可以让容器完成其工作， 

1648
01:14:27,529 --> 01:14:28,569
把东西放在某处

1649
01:14:28,569 --> 01:14:31,340
然后您仍然可以通过一些方式抵消它。 

1650
01:14:31,340 --> 01:14:32,420
容器可以做到这一点

1651
01:14:32,420 --> 01:14:33,680
但其他人也可以做到。 

1652
01:14:33,680 --> 01:14:34,750
视图可以做到这一点。 

1653
01:14:34,949 --> 01:14:36,500
我想抵消一点。 

1654
01:14:36,500 --> 01:14:38,539
因此，抵消是一个有趣的小家伙。 

1655
01:14:38,539 --> 01:14:39,890
我们不用太多的偏移量

1656
01:14:39,890 --> 01:14:41,949
但我只想让你知道它的存在。 

1657
01:14:42,149 --> 01:14:44,889
现在，为了记住，我们将使用框架和位置

1658
01:14:44,890 --> 01:14:46,579
创建我们自己的容器视图

1659
01:14:46,779 --> 01:14:48,420
有点像堆栈。 

1660
01:14:48,420 --> 01:14:52,350
它被称为网格，它是2D，行和列， 

1661
01:14:52,350 --> 01:14:54,270
而不只是水平行

1662
01:14:54,270 --> 01:14:55,920
这是一个非常可悲的游戏， 

1663
01:14:56,119 --> 01:14:58,136
如果我现在就这样说的话。 

1664
01:14:58,136 --> 01:15:00,269
我们显然希望它是行和列。 

1665
01:15:00,270 --> 01:15:02,989
我们将通过使用框架和位置来做到这一点

1666
01:15:03,189 --> 01:15:04,589
创建我们自己的容器。 

1667
01:15:06,689 --> 01:15:09,039
所以我们今天要回到演示。 

1668
01:15:09,039 --> 01:15:11,710
我很想有时间去做那个容器， 

1669
01:15:11,710 --> 01:15:14,970
但是我们没有，第三节课结束。 

1670
01:15:14,970 --> 01:15:17,640
我会做一个简短的演示

1671
01:15:17,640 --> 01:15:19,890
只是向您展示GeometryReader的工作原理。 

1672
01:15:19,890 --> 01:15:22,250
而我们要做的就是我一直在谈论的东西， 

1673
01:15:22,449 --> 01:15:26,439
使我们的字体，表情符号字体变大

1674
01:15:26,439 --> 01:15:30,000
使用GeometryReader提供给我们的空间。 

1675
01:15:30,000 --> 01:15:31,710
当我在那里的时候，我可能会做一件小事

1676
01:15:31,710 --> 01:15:33,500
我要告诉你最好的方法

1677
01:15:33,500 --> 01:15:35,939
或我们大家都同意的那种方式

1678
01:15:35,939 --> 01:15:39,259
在我们的代码中收集魔术数字。 

1679
01:15:39,260 --> 01:15:41,600
如果您已经有一个如cornerRadius 10这样的设备， 

1680
01:15:41,600 --> 01:15:43,500
那10是个魔术数字， 

1681
01:15:43,500 --> 01:15:45,020
它确实不应该嵌入我们的代码中。 

1682
01:15:45,020 --> 01:15:46,930
 Swift中有一种规范的方式

1683
01:15:46,930 --> 01:15:50,460
把它拿出来放在自己的小空间

1684
01:15:50,460 --> 01:15:52,262
因此，它有充分的文档记录和类型。 

1685
01:15:54,130 --> 01:15:56,170
现在，我们开始下一个演讲， 

1686
01:15:56,170 --> 01:15:59,380
使用GeometryReader以及带有协议的泛型

1687
01:15:59,380 --> 01:16:01,449
和功能作为类型

1688
01:16:01,449 --> 01:16:05,289
使这个美丽的小简单的网格视图

1689
01:16:05,289 --> 01:16:06,439
那就像是一个HStack。 

1690
01:16:06,439 --> 01:16:10,029
我们将仅使用此Grid View来替换HStack 

1691
01:16:10,029 --> 01:16:12,300
并使我们的卡片排列在一个漂亮的网格中

1692
01:16:12,300 --> 01:16:13,829
因此，让我们跳入该演示

1693
01:16:13,829 --> 01:16:15,939
然后这将是本讲座的结尾。 

1694
01:16:15,939 --> 01:16:18,189
现在，您在作业中被问到

1695
01:16:18,189 --> 01:16:21,359
在这里调整字体选择

1696
01:16:21,359 --> 01:16:24,546
适合小卡片，因为小卡片， 

1697
01:16:24,546 --> 01:16:27,529
我们选择的字体，大标题太大。 

1698
01:16:27,529 --> 01:16:30,170
这可能已经解决了，仅适用于小卡片

1699
01:16:30,170 --> 01:16:32,720
但是我让你这样做几乎是为了意识到， 

1700
01:16:32,720 --> 01:16:34,579
好吧，那不是一个好的解决方案， 

1701
01:16:34,579 --> 01:16:36,569
特别是当我们在风景中

1702
01:16:36,569 --> 01:16:39,439
甚至大标题也太小了。 

1703
01:16:39,439 --> 01:16:42,989
所以我们真正想要的是我们的卡

1704
01:16:42,989 --> 01:16:45,050
选择使用所有空间的字体。 

1705
01:16:45,050 --> 01:16:47,279
那确实是我们想要做的。 

1706
01:16:47,279 --> 01:16:49,289
那么我们该怎么做呢？ 

1707
01:16:49,289 --> 01:16:51,859
好吧，我们将使用特殊的View来做到这一点。 

1708
01:16:51,859 --> 01:16:54,179
这是另一个视图，就像HStack是一个视图

1709
01:16:54,180 --> 01:16:57,880
 ForEach是一个视图，ZStack是几个，Text是一个视图。 

1710
01:16:57,880 --> 01:16:59,569
这些都是视图。 

1711
01:16:59,569 --> 01:17:02,729
有一个特殊的视图称为

1712
01:17:02,729 --> 01:17:07,519
 GeometryReader视图。 

1713
01:17:07,520 --> 01:17:09,920
所以GeometryReader有一个参数

1714
01:17:10,119 --> 01:17:12,340
这是要去的内容

1715
01:17:12,340 --> 01:17:14,090
显示在自己的内部

1716
01:17:14,090 --> 01:17:17,113
就像我们的名片一样， 

1717
01:17:18,247 --> 01:17:20,099
 ZStack可以制作我们的卡， 

1718
01:17:20,100 --> 01:17:24,329
但是这里有一个很好的论点，叫做几何

1719
01:17:24,329 --> 01:17:28,199
就像ForEach是在这里有论点的View 

1720
01:17:28,199 --> 01:17:30,720
但它也有这种内容论点

1721
01:17:30,720 --> 01:17:34,470
它提供了要遍历的Card。 

1722
01:17:34,470 --> 01:17:37,130
同样，GeometryReader，它具有内容， 

1723
01:17:37,130 --> 01:17:41,050
要求一个视图，但它提供了这种特殊的几何形状。 

1724
01:17:41,050 --> 01:17:43,210
我们将看看这个小变量

1725
01:17:43,210 --> 01:17:45,260
在这里给你的

1726
01:17:45,260 --> 01:17:46,590
因为我们可以看一下

1727
01:17:46,590 --> 01:17:48,600
我们视图的大小是多少。 

1728
01:17:48,600 --> 01:17:52,041
现在请注意，当我们放置代码时，我们的ZStack 

1729
01:17:52,041 --> 01:17:54,779
在GeometryReader内容中， 

1730
01:17:54,979 --> 01:17:58,119
我们得到了这些需要自我加点的东西。 

1731
01:17:58,119 --> 01:18:02,457
因此，请通过此处并对此进行修复， 

1732
01:18:02,457 --> 01:18:04,652
修理那个，捡起来。 

1733
01:18:06,029 --> 01:18:07,659
那是什么

1734
01:18:07,659 --> 01:18:10,771
让我们看一下GeometryReader的文档。 

1735
01:18:10,771 --> 01:18:14,140
因此，我将执行Option +单击以查看GeometryReader。 

1736
01:18:14,140 --> 01:18:16,079
您可以在这里看到struct GeometryReader结构。 

1737
01:18:16,279 --> 01:18:19,289
不用管它叫Content 

1738
01:18:19,289 --> 01:18:21,439
该内容是一个视图。 

1739
01:18:21,439 --> 01:18:24,299
所以现在，希望您开始了

1740
01:18:24,300 --> 01:18:25,770
了解这意味着什么， 

1741
01:18:25,770 --> 01:18:27,779
内容是视图在哪里，对不对？ 

1742
01:18:27,979 --> 01:18:30,779
内容不在乎，视图是协议。 

1743
01:18:30,779 --> 01:18:32,939
所以我们已经把无关紧要变成了

1744
01:18:32,939 --> 01:18:34,949
好吧，我们有点在意吧？ 

1745
01:18:34,949 --> 01:18:38,220
我们关心的是GeometryReader的内容是一个View， 

1746
01:18:38,220 --> 01:18:40,320
但是否则它可以是它想要的任何东西。 

1747
01:18:41,449 --> 01:18:44,489
所以我要在文档中打开它

1748
01:18:44,489 --> 01:18:46,079
看看它怎么说。 

1749
01:18:46,079 --> 01:18:47,609
这是初始化。 

1750
01:18:47,609 --> 01:18:50,529
您可以看到它需要这一参数内容

1751
01:18:50,529 --> 01:18:53,939
您实际上应该在这里识别此语法

1752
01:18:53,939 --> 01:18:56,829
因为真的，它需要一个功能

1753
01:18:56,829 --> 01:18:59,539
返回此内容的内容不在乎， 

1754
01:18:59,539 --> 01:19:02,720
我们知道实际上是我们关心的一点内容

1755
01:19:02,720 --> 01:19:06,430
 Content Content View所在的位置，因此我们知道它必须是View。 

1756
01:19:06,430 --> 01:19:09,561
这就是一个带有参数的函数

1757
01:19:09,761 --> 01:19:14,279
 GeometryProxy，并返回此无关内容。 

1758
01:19:14,279 --> 01:19:17,059
不用担心在那逃脱。 

1759
01:19:17,060 --> 01:19:19,699
我们将在接下来的几周内谈论这一点。 

1760
01:19:19,899 --> 01:19:22,960
因此，让我们单击此GeometryProxy 

1761
01:19:22,960 --> 01:19:25,029
并查看其装饰。 

1762
01:19:25,229 --> 01:19:26,659
在这里，您可以看到它具有

1763
01:19:26,659 --> 01:19:29,130
我们在幻灯片中讨论的事情。 

1764
01:19:29,130 --> 01:19:32,510
现在，我将重点显然放在此处的尺寸上。 

1765
01:19:32,510 --> 01:19:34,890
因此，让我们单击它。 

1766
01:19:34,890 --> 01:19:37,210
您会看到大小只是CGSize， 

1767
01:19:37,409 --> 01:19:38,806
它只有get，它是只读的。 

1768
01:19:38,806 --> 01:19:41,210
只是要告诉我们宽度和高度

1769
01:19:41,210 --> 01:19:44,302
我们已经提供了绘制此视图的方法。 

1770
01:19:45,789 --> 01:19:47,430
这正是我们想要的。 

1771
01:19:47,430 --> 01:19:49,810
我们希望此几何尺寸就在这里。 

1772
01:19:49,810 --> 01:19:51,630
我要去做的是

1773
01:19:51,630 --> 01:19:54,569
我的CardView拥有所有权

1774
01:19:54,569 --> 01:19:58,279
在这里设置自己的字体。 

1775
01:19:58,279 --> 01:19:59,639
因此，它将使用字体。 

1776
01:19:59,640 --> 01:20:02,550
因此，我不再在游戏本身中设置字体。 

1777
01:20:02,550 --> 01:20:04,670
我让卡设置自己的字体

1778
01:20:04,670 --> 01:20:07,210
无论如何，这可能是更好的封装。 

1779
01:20:07,210 --> 01:20:08,470
为什么我们在这里， 

1780
01:20:08,470 --> 01:20:12,317
我们不需要像HStack这样的冒号内容

1781
01:20:12,317 --> 01:20:13,390
以及所有其他这些东西。 

1782
01:20:13,390 --> 01:20:16,310
我们可以摆脱它，摆脱它

1783
01:20:16,310 --> 01:20:18,739
所以这看起来很干净。 

1784
01:20:18,939 --> 01:20:22,189
所以我们想在这里做一个字体，所以写一些字体， 

1785
01:20:22,189 --> 01:20:25,639
其尺寸基于该几何尺寸。 

1786
01:20:25,640 --> 01:20:27,353
所以我要创建系统字体， 

1787
01:20:27,353 --> 01:20:29,810
只是在这里制作系统字体的不同方法， 

1788
01:20:29,810 --> 01:20:30,930
样式和大小。 

1789
01:20:30,930 --> 01:20:33,717
所以我只是选择尺寸。 

1790
01:20:33,717 --> 01:20:37,139
我想要一个CGFloat，其大小为磅值。 

1791
01:20:37,140 --> 01:20:39,840
并记住字体的磅值是相关的

1792
01:20:39,840 --> 01:20:42,909
到点的宽度和点的高度。 

1793
01:20:42,909 --> 01:20:45,199
所以我实际上要选择最小的

1794
01:20:45,199 --> 01:20:46,229
宽度到高度的

1795
01:20:46,229 --> 01:20:47,919
因为我不一定要依靠

1796
01:20:47,920 --> 01:20:50,600
了解我的长宽比是多少。 

1797
01:20:50,600 --> 01:20:52,539
所以我只选择这两个中的最小值

1798
01:20:52,739 --> 01:20:55,289
确保我选择合适的字体。 

1799
01:20:55,289 --> 01:21:00,289
所以这是最小几何尺寸宽度

1800
01:21:00,329 --> 01:21:03,569
以及几何尺寸高度。 

1801
01:21:03,569 --> 01:21:05,949
所以我使用的是我们看到的那个大小变量

1802
01:21:05,949 --> 01:21:08,840
就在这里的GeometryProxy中。 

1803
01:21:08,840 --> 01:21:10,850
也许我们可以尝试一下。 

1804
01:21:10,850 --> 01:21:12,869
让我们选择一个字体大小

1805
01:21:13,069 --> 01:21:15,439
这是这两个中的最小值

1806
01:21:15,439 --> 01:21:16,929
然后看看它是什么样子。 

1807
01:21:16,930 --> 01:21:17,972
因此，让我们运行它。 

1808
01:21:20,470 --> 01:21:21,640
看那个。 

1809
01:21:21,640 --> 01:21:25,619
这样的尺寸要小得多，甚至会更小。 

1810
01:21:25,619 --> 01:21:27,539
但这实际上太大了。 

1811
01:21:27,539 --> 01:21:30,029
那里太大了。 

1812
01:21:30,029 --> 01:21:33,920
也许只是因为绘图点大小

1813
01:21:33,920 --> 01:21:36,380
不完全是字体的宽度。 

1814
01:21:36,380 --> 01:21:39,329
它可能与高度有关， 

1815
01:21:39,329 --> 01:21:42,930
但是我们也确实在边缘上做了一些笔触

1816
01:21:42,930 --> 01:21:45,340
也会占用一点空间。 

1817
01:21:45,340 --> 01:21:49,289
所以可能我需要某种常数乘数

1818
01:21:49,289 --> 01:21:54,289
大概是75％，0.75等等。 

1819
01:21:56,850 --> 01:22:00,539
而75％的人看起来确实不错。 

1820
01:22:00,539 --> 01:22:03,493
大的时候看起来不错，小的时候看起来不错。 

1821
01:22:04,640 --> 01:22:07,090
在完成第三讲之前， 

1822
01:22:07,090 --> 01:22:09,159
我想在这里花点时间

1823
01:22:09,159 --> 01:22:12,239
谈论编码风格问题。 

1824
01:22:12,239 --> 01:22:15,779
我很少谈论编码风格， 

1825
01:22:15,779 --> 01:22:19,069
纯粹出于时间限制

1826
01:22:19,069 --> 01:22:20,829
但是这次我要提一下。 

1827
01:22:20,829 --> 01:22:23,399
因为这有点塞古

1828
01:22:23,399 --> 01:22:27,009
我们将如何构建我们的View代码

1829
01:22:27,010 --> 01:22:29,500
使其更具可读性。 

1830
01:22:29,500 --> 01:22:33,390
我担心的问题是这些幻数。 

1831
01:22:33,390 --> 01:22:35,710
我们已经创建了这些蓝色魔术数字

1832
01:22:35,710 --> 01:22:38,590
并开始在整个代码中散布它们。 

1833
01:22:38,590 --> 01:22:41,405
那不是很好的编码风格。 

1834
01:22:41,405 --> 01:22:43,609
 SwiftUI是声明性的。 

1835
01:22:43,609 --> 01:22:46,599
我们实质上是在这里直接声明UI。 

1836
01:22:46,600 --> 01:22:49,470
我们不是在调用函数来告诉它自己构建， 

1837
01:22:49,470 --> 01:22:51,310
我们在这里宣布。 

1838
01:22:51,310 --> 01:22:53,960
当我们这样做时，这些蓝色数字最终

1839
01:22:53,960 --> 01:22:57,010
是我们可以转动的旋钮

1840
01:22:57,010 --> 01:23:01,220
调整View的外观并使其正确。 

1841
01:23:01,220 --> 01:23:02,390
好吧，现在我们的旋钮

1842
01:23:02,390 --> 01:23:04,869
散布在这里

1843
01:23:04,869 --> 01:23:08,559
如果我们能有一个控制面板，那真是太好了。 

1844
01:23:08,560 --> 01:23:11,670
因此，我将创建一个小的控制面板。 

1845
01:23:11,869 --> 01:23:15,649
我要在这里评论以标记它的绘制常数， 

1846
01:23:15,649 --> 01:23:16,929
我要称呼它

1847
01:23:16,930 --> 01:23:19,800
并把我所有的绘画常数放在这里

1848
01:23:19,800 --> 01:23:24,130
就像vars一样，让和在我的结构上起作用。 

1849
01:23:24,130 --> 01:23:26,699
而把vars和let 

1850
01:23:26,899 --> 01:23:28,819
和功能在您的结构

1851
01:23:28,819 --> 01:23:32,069
清理或修复魔术数字

1852
01:23:32,069 --> 01:23:34,539
在您看来，非常重要。 

1853
01:23:34,539 --> 01:23:38,529
您会看到大多数视图都有一些变量

1854
01:23:38,529 --> 01:23:40,359
并让我们在这里玩

1855
01:23:40,359 --> 01:23:44,929
使外观看起来尽可能整洁易懂。 

1856
01:23:44,930 --> 01:23:48,779
因此，让我们使用这个想法来获得这些神奇的数字。 

1857
01:23:48,979 --> 01:23:50,389
这些碰巧是常数。 

1858
01:23:50,390 --> 01:23:52,430
所以我要用let。 

1859
01:23:52,430 --> 01:23:55,079
记住，让我们就像var一样

1860
01:23:55,279 --> 01:23:57,449
因为let表示它是一个常数。 

1861
01:23:57,449 --> 01:24:01,269
因此，让我们在此处进行转角半径cornerRadius的设置。 

1862
01:24:01,270 --> 01:24:04,710
您可能会认为您可以说cornerRadius等于10 

1863
01:24:04,710 --> 01:24:07,869
但这是行不通的，我将向您展示为什么。 

1864
01:24:07,869 --> 01:24:10,579
如果按住Option键，请记住， 

1865
01:24:10,579 --> 01:24:13,880
然后点击，它将告诉您声明

1866
01:24:13,880 --> 01:24:16,340
您点击的东西

1867
01:24:16,340 --> 01:24:17,920
就我们而言，这是我们的角落

1868
01:24:17,920 --> 01:24:20,819
并且已将其键入为Int。 

1869
01:24:20,819 --> 01:24:23,929
请记住，如果我们说让var等于某物

1870
01:24:23,930 --> 01:24:26,907
而且我们没有指定它的类型，Swift会推断出来。 

1871
01:24:26,907 --> 01:24:28,529
这里是看这十个

1872
01:24:28,729 --> 01:24:31,369
和引用，看起来像一个Int。 

1873
01:24:31,369 --> 01:24:33,099
那不是我们想要的。 

1874
01:24:33,100 --> 01:24:37,340
这些蓝色的数字都是CGFloats， 

1875
01:24:37,340 --> 01:24:40,069
我们用来绘制的浮点数。 

1876
01:24:40,069 --> 01:24:42,670
现在，我什至不能说10.0。 

1877
01:24:42,670 --> 01:24:46,340
如果我这样做，并且按住Option键并单击，则认为它是Double。 

1878
01:24:46,340 --> 01:24:48,760
这些不是双精度浮点数。 

1879
01:24:48,760 --> 01:24:52,810
此Double结构与CGFloat结构不同。 

1880
01:24:52,810 --> 01:24:56,003
因此，我必须明确键入CGFloat。 

1881
01:24:57,140 --> 01:25:01,289
那并不一定是那么繁重或繁重， 

1882
01:25:01,289 --> 01:25:03,640
提醒自己的方式很好

1883
01:25:03,640 --> 01:25:05,802
这些在这里画出常数。 

1884
01:25:06,890 --> 01:25:07,800
让我们做其他的吧。 

1885
01:25:07,800 --> 01:25:10,300
我们得到了edgeLineWidth。 

1886
01:25:10,300 --> 01:25:12,020
我们还有一个常数

1887
01:25:12,020 --> 01:25:15,930
这个数字三，我们当然有这个.75 

1888
01:25:15,930 --> 01:25:18,869
这真的像我们字体的缩放比例。 

1889
01:25:19,069 --> 01:25:21,136
我将其命名为fontScaleFactor 

1890
01:25:22,369 --> 01:25:24,722
这也是CGFloat，0.75。 

1891
01:25:26,470 --> 01:25:28,520
现在我将这些放在这里， 

1892
01:25:28,520 --> 01:25:31,550
我可以用这些替换所有的魔术数字

1893
01:25:31,550 --> 01:25:35,119
这将成为我控制面板上的旋钮。 

1894
01:25:35,119 --> 01:25:35,952
因此，让我们这样做。 

1895
01:25:35,953 --> 01:25:37,083
我们有这个。 

1896
01:25:38,238 --> 01:25:41,282
我要复制并粘贴，使此过程更快一点。 

1897
01:25:42,670 --> 01:25:47,149
在这里，这三个是这里的边缘线

1898
01:25:48,750 --> 01:25:53,693
这里的fontScaleFactor是这个.75。 

1899
01:25:55,100 --> 01:25:55,739
很好

1900
01:25:55,939 --> 01:26:00,460
实际上，这也使这段代码很好看， 

1901
01:26:00,460 --> 01:26:02,210
非常像英语

1902
01:26:02,210 --> 01:26:03,890
试图了解正在发生的事情。 

1903
01:26:03,890 --> 01:26:05,489
但是，您会注意到它的引入

1904
01:26:05,689 --> 01:26:08,019
这里有很多错误。 

1905
01:26:08,020 --> 01:26:09,960
它们实际上都是相同的错误。 

1906
01:26:09,960 --> 01:26:12,770
这是可怕的显式自我点

1907
01:26:12,770 --> 01:26:15,600
使捕获语义明确。 

1908
01:26:15,600 --> 01:26:18,140
我们可以，也许可以解决这个问题

1909
01:26:18,140 --> 01:26:19,909
然后单击此处，然后修复此问题

1910
01:26:20,109 --> 01:26:21,279
然后我单击并修复它， 

1911
01:26:21,279 --> 01:26:23,750
但我要告诉你避免的窍门

1912
01:26:23,750 --> 01:26:28,479
在GeometryReader的这种常见情况下，这个自圆点的东西。 

1913
01:26:28,479 --> 01:26:30,599
因此，每当您执行GeometryReader时， 

1914
01:26:30,600 --> 01:26:32,760
里面的东西总会抱怨

1915
01:26:32,760 --> 01:26:33,880
关于这个自我点。 

1916
01:26:33,880 --> 01:26:35,681
顺便说一句，ForEach也是如此。 

1917
01:26:35,881 --> 01:26:38,889
里面的每样东西都会抱怨自我点。 

1918
01:26:38,890 --> 01:26:40,617
并非每个视图都这样做

1919
01:26:40,617 --> 01:26:43,960
但是这两个确实很常用。 

1920
01:26:43,960 --> 01:26:45,369
我要创建一个功能

1921
01:26:45,369 --> 01:26:50,369
我要称呼它的尺寸CGSize 

1922
01:26:50,801 --> 01:26:52,470
它会归还我的身体， 

1923
01:26:52,470 --> 01:26:55,369
这样就可以像某些视图一样

1924
01:26:55,569 --> 01:26:59,019
我可以使用一些View作为此变量的类型， 

1925
01:26:59,020 --> 01:27:02,680
我可以让一些View作为此函子的返回类型。 

1926
01:27:02,680 --> 01:27:05,693
然后我要把我的身体剪下来， 

1927
01:27:05,693 --> 01:27:09,739
放在这里，然后调用此函数

1928
01:27:09,939 --> 01:27:13,569
在我的GeometryReader中，self.body 

1929
01:27:13,569 --> 01:27:16,382
几何尺寸。 

1930
01:27:18,600 --> 01:27:20,670
这段代码实际上清理得很好。 

1931
01:27:20,869 --> 01:27:22,500
这是很合理的。 

1932
01:27:22,500 --> 01:27:26,149
现在该代码不再嵌入

1933
01:27:26,149 --> 01:27:28,199
在这样的GeometryReader中

1934
01:27:28,199 --> 01:27:30,289
因此您不需要这些自我点。 

1935
01:27:30,289 --> 01:27:31,867
所以我可以摆脱那一个

1936
01:27:31,867 --> 01:27:33,579
还有那个和那个

1937
01:27:33,579 --> 01:27:35,529
所有那些自我点都消失了。 

1938
01:27:35,529 --> 01:27:38,659
更重要的是，我没有通过整个几何

1939
01:27:38,659 --> 01:27:42,630
到这个物体，只是尺寸，几何尺寸var。 

1940
01:27:42,630 --> 01:27:46,529
所以在这里，我不需要说geometry.size。 

1941
01:27:46,729 --> 01:27:50,189
现在这个geometry.size就是size， 

1942
01:27:50,189 --> 01:27:52,489
我传入的这个大小。 

1943
01:27:52,489 --> 01:27:54,889
这样使这段代码看起来更好

1944
01:27:54,890 --> 01:27:57,380
我几乎总是建议， 

1945
01:27:57,380 --> 01:27:59,079
至少接下来的几个月

1946
01:27:59,079 --> 01:28:03,579
直到他们把Swift的自圆点变化放在那里

1947
01:28:03,579 --> 01:28:06,559
因此自点不再引起此问题。 

1948
01:28:06,560 --> 01:28:09,890
这是没有此代码的真正干净的方法

1949
01:28:09,890 --> 01:28:11,300
担心自己的点。 

1950
01:28:11,300 --> 01:28:15,363
您可以在ForEach中为项目做相同的事情

1951
01:28:16,350 --> 01:28:17,869
因为每个人都会造成

1952
01:28:17,869 --> 01:28:20,329
那个自我点问题。 

1953
01:28:20,329 --> 01:28:21,880
我们可以在这里做另一件事。 

1954
01:28:21,880 --> 01:28:23,560
在这里，我可以有一个功能

1955
01:28:23,560 --> 01:28:26,403
对于称为fontSize的字体大小， 

1956
01:28:27,470 --> 01:28:30,829
它返回的字体大小也是CGFloat， 

1957
01:28:30,829 --> 01:28:35,350
并将这段代码放在这里

1958
01:28:35,350 --> 01:28:39,113
这样就可以读取fontSize的大小。 

1959
01:28:40,060 --> 01:28:42,949
您可能会认为这是一个非常简单的表达， 

1960
01:28:43,149 --> 01:28:46,420
我真的不需要在这里将其变成自己的功能， 

1961
01:28:46,420 --> 01:28:50,420
但是同样，您不能使它变得太简单。 

1962
01:28:50,420 --> 01:28:52,699
您真的想让它尽可能简单。 

1963
01:28:52,699 --> 01:28:54,539
有时您不得不使其变得简单。 

1964
01:28:54,539 --> 01:28:56,229
正如我所解释的， 

1965
01:28:56,229 --> 01:28:59,099
不能是任意复杂的表达式。 

1966
01:28:59,100 --> 01:29:00,789
所以有时候这需要一个函数

1967
01:29:00,789 --> 01:29:02,659
返回布尔，在这种情况下， 

1968
01:29:02,659 --> 01:29:04,769
因为这是简单的布尔。 

1969
01:29:04,770 --> 01:29:08,300
但是让这些小班轮发挥作用

1970
01:29:08,300 --> 01:29:13,029
使这个身体看起来更干净，非常普遍。 

1971
01:29:13,029 --> 01:29:14,939
在这里，我们甚至可能没有

1972
01:29:14,939 --> 01:29:19,729
使这个fontScaleFactor成为其自己的单独

1973
01:29:19,729 --> 01:29:21,799
因为您可以考虑字体大小

1974
01:29:21,800 --> 01:29:23,869
作为绘图常量的一部分。 

1975
01:29:23,869 --> 01:29:28,313
这是给定大小的恒定字体大小。 

1976
01:29:29,539 --> 01:29:31,449
这就是第三讲。 

1977
01:29:31,449 --> 01:29:34,260
我们要马上潜回去

1978
01:29:34,260 --> 01:29:36,619
从第四讲开始，并继续进行此演示

1979
01:29:36,819 --> 01:29:40,979
并使我们的HStack成为2D网格。 

1980
01:29:40,979 --> 01:29:44,069
我们将学到很多东西。 

1981
01:29:44,069 --> 01:29:49,069
 -[旁白]有关更多信息，请访问stanford.edu。 

