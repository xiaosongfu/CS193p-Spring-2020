1
00:00:02,330 --> 00:00:04,919
 （音乐照亮） 

2
00:00:04,919 --> 00:00:06,570
 -[旁白]斯坦福大学。 

3
00:00:08,119 --> 00:00:09,799
 -[老师]大家好，欢迎光临， 

4
00:00:09,800 --> 00:00:13,313
斯坦福CS193p 2020年春季。 

5
00:00:13,313 --> 00:00:15,320
这是第三讲。 

6
00:00:15,320 --> 00:00:18,315
我今天将从演示开始， 

7
00:00:18,315 --> 00:00:22,620
我们正在讨论的反应式SwiftUI内容的演示。 

8
00:00:22,620 --> 00:00:24,769
然后我要跳一些幻灯片， 

9
00:00:24,969 --> 00:00:28,269
多说一些Swift类型的系统， 

10
00:00:28,269 --> 00:00:31,769
具体来说就是协议，然后

11
00:00:31,769 --> 00:00:33,619
之后一个完全不同的话题， 

12
00:00:33,619 --> 00:00:36,479
这是视图的布局系统， 

13
00:00:36,479 --> 00:00:39,839
它们如何在屏幕上布置。 

14
00:00:39,840 --> 00:00:42,099
如果时间允许，我实际上会做一些演示

15
00:00:42,299 --> 00:00:44,689
到今天结束时， 

16
00:00:44,689 --> 00:00:47,119
如果没有，它将被推迟到下一次。 

17
00:00:47,119 --> 00:00:50,890
下次我们一定要布置卡片

18
00:00:50,890 --> 00:00:53,320
行和列而不是全部

19
00:00:53,320 --> 00:00:55,890
像现在这样水平排列

20
00:00:55,890 --> 00:00:59,090
我们还将开始实际拥有

21
00:00:59,090 --> 00:01:03,670
我们的模型玩游戏并实现我们的一些逻辑。 

22
00:01:03,670 --> 00:01:06,373
但是现在，让我们来做这个反应式Swift演示。 

23
00:01:07,290 --> 00:01:11,969
希望您现在对MVVM非常熟悉， 

24
00:01:11,969 --> 00:01:13,409
但是在我开始这个演示之前， 

25
00:01:13,409 --> 00:01:15,340
我要花一秒钟

26
00:01:15,340 --> 00:01:18,280
复习一下，以防万一已经几天了

27
00:01:18,280 --> 00:01:19,890
因为你做了功课。 

28
00:01:19,890 --> 00:01:23,359
这是我们的模型，称为MemoryGame。 

29
00:01:23,359 --> 00:01:25,429
它有这个不在乎CardContent 

30
00:01:25,430 --> 00:01:26,759
卡上有什么

31
00:01:26,959 --> 00:01:29,119
作为模型，我们不在乎。 

32
00:01:29,120 --> 00:01:31,079
这取决于用户界面来决定它想要什么

33
00:01:31,079 --> 00:01:34,179
在卡片上显示。 

34
00:01:34,180 --> 00:01:35,400
这是我们的卡。 

35
00:01:35,400 --> 00:01:39,149
这是此Card结构的数组。 

36
00:01:39,349 --> 00:01:43,449
这个选择让我们从本质上玩游戏。 

37
00:01:43,450 --> 00:01:45,310
我们还没有实现

38
00:01:45,310 --> 00:01:46,519
但是当您选择一张卡时， 

39
00:01:46,519 --> 00:01:50,119
那就是匹配发生的时间，诸如此类。 

40
00:01:50,120 --> 00:01:54,369
这是我们初始化或创建MemoryGame的方法。 

41
00:01:54,569 --> 00:01:56,109
我们显然想指定

42
00:01:56,109 --> 00:01:58,359
我们的游戏中有几副牌， 

43
00:01:58,359 --> 00:02:01,370
我们需要一个cardContentFactory函数

44
00:02:01,370 --> 00:02:03,500
制作卡片上的内容

45
00:02:03,500 --> 00:02:05,569
因为对我们来说，这不在乎。 

46
00:02:05,569 --> 00:02:08,852
因此，需要照顾的人必须为我们做到这一点。 

47
00:02:09,830 --> 00:02:11,930
这是我们的ViewModel。 

48
00:02:12,129 --> 00:02:15,669
我们的ViewModel有一个var，即Model。 

49
00:02:15,669 --> 00:02:18,829
我们的ViewModel可以一次与模型对话。 

50
00:02:18,830 --> 00:02:22,469
它是视图模型的门户或门口

51
00:02:22,669 --> 00:02:25,019
因此它必须能够做到这一点。 

52
00:02:25,020 --> 00:02:29,370
请注意，这里没有指向视图的变量。 

53
00:02:29,370 --> 00:02:32,689
 ViewModel从不与其视图对话。 

54
00:02:32,689 --> 00:02:35,599
与ViewModel对话的是View。 

55
00:02:35,599 --> 00:02:37,826
我们将看看

56
00:02:37,826 --> 00:02:41,819
和ViewModel互动，只需片刻

57
00:02:41,819 --> 00:02:44,269
但永远不会有任何连接

58
00:02:44,270 --> 00:02:45,969
从ViewModel到Views 

59
00:02:45,969 --> 00:02:47,889
因为很多很多不同的观点

60
00:02:47,889 --> 00:02:50,179
将使用此ViewModel，此门户， 

61
00:02:50,180 --> 00:02:52,280
这个门口，进入模型。 

62
00:02:52,280 --> 00:02:54,240
他们将使用它，共享它。 

63
00:02:54,240 --> 00:02:56,710
同样，这就是为什么我们的ViewModel是一个类。 

64
00:02:56,710 --> 00:02:58,710
它是指向堆中某物的指针。 

65
00:02:58,710 --> 00:03:01,689
分享指向的内容很容易。 

66
00:03:01,889 --> 00:03:06,399
因此，我们的ViewModel还提供了对模型的公共访问

67
00:03:06,400 --> 00:03:08,710
否则是私有的。 

68
00:03:08,710 --> 00:03:11,250
而且访问都在获取信息， 

69
00:03:11,250 --> 00:03:12,449
喜欢拿卡

70
00:03:12,449 --> 00:03:16,409
并让视图表达其意图，在这种情况下， 

71
00:03:16,409 --> 00:03:18,479
选择一张卡。 

72
00:03:18,479 --> 00:03:21,659
两者都非常容易通过我们的模型实施

73
00:03:21,659 --> 00:03:24,629
但这就是我们的ViewModels工作。 

74
00:03:24,629 --> 00:03:26,689
最后，我们有自己的观点。 

75
00:03:26,689 --> 00:03:31,689
在MVVM视图意义上，我们的视图中有两个视图。 

76
00:03:32,349 --> 00:03:35,079
一个是代表一张卡片的视图

77
00:03:35,080 --> 00:03:39,210
然后是此视图，这是我们在此处组合的所有卡。 

78
00:03:39,210 --> 00:03:42,379
根据我得到的反馈

79
00:03:42,379 --> 00:03:43,430
你们中的一些人

80
00:03:43,430 --> 00:03:44,689
在本周的家庭作业中， 

81
00:03:44,889 --> 00:03:48,879
我想澄清一点，我们的想法

82
00:03:48,879 --> 00:03:53,019
通过澄清我们用来描述事物的词语。 

83
00:03:53,020 --> 00:03:56,157
你们当中有些人在说

84
00:03:56,157 --> 00:03:57,826
 “哦，我正在使用此功能

85
00:03:58,026 --> 00:04:03,026
 “设置卡的字体。” 

86
00:04:03,069 --> 00:04:07,616
虽然我认为这是不正确的， 

87
00:04:09,479 --> 00:04:11,829
真的更好的说法是

88
00:04:11,830 --> 00:04:16,830
这个功能在这里修改了我们发送给它的视图

89
00:04:17,149 --> 00:04:21,229
以便使用此字体进行绘制。 

90
00:04:21,230 --> 00:04:22,699
那有什么区别？ 

91
00:04:22,899 --> 00:04:26,099
嗯，这是声明式编程之间的区别

92
00:04:26,100 --> 00:04:28,129
和命令式编程。 

93
00:04:28,129 --> 00:04:31,980
在声明中，我们只是声明这是字体

94
00:04:31,980 --> 00:04:34,910
用于绘制此视图， 

95
00:04:34,910 --> 00:04:38,069
而当务之急是，您在想诸如此类的事情， 

96
00:04:38,269 --> 00:04:41,740
我正在调用此函数来设置字体

97
00:04:41,740 --> 00:04:44,387
在某个时刻，我正在设置它。 

98
00:04:44,387 --> 00:04:47,769
并且没有及时使用此声明。 

99
00:04:47,769 --> 00:04:51,659
在任何时候，这应该绘制视图

100
00:04:51,660 --> 00:04:53,980
反映模型，它应该能够

101
00:04:53,980 --> 00:04:58,189
随时要求该机构这样做。 

102
00:04:58,189 --> 00:05:00,719
景气，应该是一个视图

103
00:05:00,720 --> 00:05:03,000
反映了模型的状态， 

104
00:05:03,000 --> 00:05:04,603
本质上对时间不敏感。 

105
00:05:05,579 --> 00:05:08,719
关于这个身体的另一件事是这个变种， 

106
00:05:08,720 --> 00:05:11,850
您永远不会访问此变量。 

107
00:05:11,850 --> 00:05:15,480
下半身永远不会出现在您的代码中。 

108
00:05:15,480 --> 00:05:18,629
该主体由系统调用。 

109
00:05:18,829 --> 00:05:20,639
每当系统想要

110
00:05:20,639 --> 00:05:24,639
绘制一个表示该模型的视图， 

111
00:05:24,639 --> 00:05:28,129
它将调用此变量以获取该视图。 

112
00:05:28,129 --> 00:05:29,659
因此，这由系统调用。 

113
00:05:29,660 --> 00:05:33,449
您的工作是通过声明实现它

114
00:05:33,649 --> 00:05:36,702
为视图提供了模型的当前状态

115
00:05:36,702 --> 00:05:40,529
通过该门户ViewModel看到的

116
00:05:40,529 --> 00:05:42,799
我想说的最后一件事是

117
00:05:42,800 --> 00:05:46,920
有些人在这些ViewBuilder中

118
00:05:46,920 --> 00:05:51,560
例如在ForEach中，甚至在ZStack或HStack中。 

119
00:05:51,560 --> 00:05:54,860
记住这些是ViewBuilders，而ViewBuilders很酷

120
00:05:54,860 --> 00:05:57,810
因为它们是返回View的函数

121
00:05:57,810 --> 00:06:00,339
而且他们确实允许这种限制

122
00:06:00,339 --> 00:06:03,409
并且它们允许您仅列出视图而不是

123
00:06:03,410 --> 00:06:06,177
将它们放入数组或其他内容中，您可以列出它们。 

124
00:06:06,177 --> 00:06:08,800
人们想在这里放一个变种， 

125
00:06:08,800 --> 00:06:11,319
 var x在这里等于某物。 

126
00:06:11,319 --> 00:06:13,209
当然，您不能创建var 

127
00:06:13,209 --> 00:06:14,592
在ViewBuilder中。 

128
00:06:15,439 --> 00:06:19,269
无法在这些ViewBuilder中创建变量， 

129
00:06:19,269 --> 00:06:21,569
只是不允许创建var。 

130
00:06:21,569 --> 00:06:22,740
你是怎么做到的？ 

131
00:06:22,740 --> 00:06:23,970
有两种方法可以做到这一点。 

132
00:06:23,970 --> 00:06:27,060
第一，您可以将vars放在ViewBuilders之外， 

133
00:06:27,060 --> 00:06:29,329
只是在正常的功能上

134
00:06:29,329 --> 00:06:33,000
然后我可以在这里使用x 

135
00:06:33,000 --> 00:06:34,269
但是如果我现在就这样做， 

136
00:06:34,269 --> 00:06:35,519
我已经创建了这两行， 

137
00:06:35,519 --> 00:06:38,339
我不得不说返回ZStack， 

138
00:06:38,339 --> 00:06:40,659
没关系，我可以做到。 

139
00:06:40,660 --> 00:06:42,930
另一种方法，也许是更常见的方法

140
00:06:42,930 --> 00:06:46,980
是创建另一个，假设这是一个Int， 

141
00:06:46,980 --> 00:06:49,579
计算属性，然后返回任何内容

142
00:06:49,779 --> 00:06:51,219
您希望x为的值

143
00:06:51,220 --> 00:06:52,740
现在您可以在这里使用x 

144
00:06:52,740 --> 00:06:55,519
它将仅使用此计算属性

145
00:06:55,519 --> 00:06:58,289
计算它想要的x的值。 

146
00:06:58,290 --> 00:07:00,160
这就是我们处理的方式

147
00:07:00,160 --> 00:07:03,509
基本创建局部变量

148
00:07:03,709 --> 00:07:08,709
或我们在此处绘制所需的变量。 

149
00:07:09,029 --> 00:07:12,449
顺便说一下，这目前称为ContentView 

150
00:07:12,449 --> 00:07:15,110
因为那是我们开始的地方

151
00:07:15,110 --> 00:07:17,286
使用Xcode中的模板。 

152
00:07:17,286 --> 00:07:20,610
 Xcode当时不知道我们在做一个记忆游戏

153
00:07:20,610 --> 00:07:22,509
因此将其称为ContentView。 

154
00:07:22,509 --> 00:07:23,779
在我们开始之前就想过

155
00:07:23,779 --> 00:07:25,939
我会告诉你如何重命名

156
00:07:25,939 --> 00:07:29,110
成为一个更好的名字。 

157
00:07:29,110 --> 00:07:31,790
现在您可能会想在导航器中执行此操作

158
00:07:31,790 --> 00:07:35,629
使用此处的搜索和替换功能。 

159
00:07:35,829 --> 00:07:38,199
您可以通过替换此处来做到这一点， 

160
00:07:38,199 --> 00:07:40,979
然后您可以搜索例如ContentView 

161
00:07:42,757 --> 00:07:44,969
它会找到它所引用的所有地方， 

162
00:07:44,970 --> 00:07:46,000
那么你可以更换它

163
00:07:46,000 --> 00:07:48,927
带有EmojiMemoryGameView之类的东西

164
00:07:49,829 --> 00:07:51,339
或类似的东西。 

165
00:07:51,339 --> 00:07:54,669
但是实际上，这不是我们要做的。 

166
00:07:54,670 --> 00:07:58,500
如果我们要更改var或类型的名称， 

167
00:07:58,500 --> 00:08:01,029
我们将使用重构。 

168
00:08:01,029 --> 00:08:03,329
所以我们要做的就是压低

169
00:08:03,329 --> 00:08:07,091
 Command键，Command +单击。 

170
00:08:07,091 --> 00:08:09,329
当我们按Command +单击时，我们会在这里得到这个漂亮的菜单

171
00:08:09,329 --> 00:08:11,199
我们可以跳到定义

172
00:08:11,199 --> 00:08:14,339
类型或var之类的东西。 

173
00:08:14,339 --> 00:08:15,612
我们也可以重命名。 

174
00:08:16,454 --> 00:08:19,930
所以我们执行Command +单击，然后我们将重命名。 

175
00:08:19,930 --> 00:08:22,290
它向我们展示了所有地方

176
00:08:22,290 --> 00:08:24,000
它发现了ContentView， 

177
00:08:24,199 --> 00:08:27,009
本质上与我们在此处进行搜索相同。 

178
00:08:27,009 --> 00:08:28,550
其中一些会改变， 

179
00:08:28,550 --> 00:08:31,319
你可以用这个小勾号告诉

180
00:08:31,319 --> 00:08:32,779
事情只会改变。 

181
00:08:32,779 --> 00:08:35,850
因此，它将更改此文件名， 

182
00:08:35,850 --> 00:08:38,009
因此，它将要更改其名称，这很好。 

183
00:08:38,009 --> 00:08:41,539
这里显示了评论ContentView 

184
00:08:41,539 --> 00:08:42,860
但这不会改变。 

185
00:08:42,860 --> 00:08:44,730
您会看到它不是蓝色，而是灰色。 

186
00:08:44,730 --> 00:08:46,019
只是说，我发现了这个， 

187
00:08:46,019 --> 00:08:48,529
但我不会改变，因为我不确定

188
00:08:48,529 --> 00:08:50,709
那真的是指这种类型

189
00:08:50,710 --> 00:08:51,750
因为它在评论中

190
00:08:51,750 --> 00:08:54,220
所以我们必须自己改变它。 

191
00:08:54,220 --> 00:08:57,100
这个var preViews将会在这里改变。 

192
00:08:57,100 --> 00:08:59,889
那实际上是我们滚开的代码

193
00:08:59,889 --> 00:09:03,259
一开始显示我们的ContentView 

194
00:09:03,259 --> 00:09:05,590
在此处的灰色preView窗口中， 

195
00:09:05,590 --> 00:09:07,570
因此显然需要进行更改。 

196
00:09:07,570 --> 00:09:09,939
这是场景委托中的代码

197
00:09:10,139 --> 00:09:12,730
我们实际上在创建记忆游戏的地方

198
00:09:12,730 --> 00:09:16,850
然后将其传递到此顶级ContentView中。 

199
00:09:16,850 --> 00:09:20,120
因此，当您执行此Command +单击并重命名时， 

200
00:09:20,120 --> 00:09:23,220
它实际上选择了Command +单击的内容

201
00:09:23,220 --> 00:09:24,740
您可以输入新内容。 

202
00:09:24,740 --> 00:09:29,740
所以EmojiMemoryGameView，看看，它正在改变它

203
00:09:30,340 --> 00:09:32,840
在所有其他地方，虽然不在这里。 

204
00:09:32,840 --> 00:09:33,673
就是这样。 

205
00:09:33,673 --> 00:09:35,799
所以你就在这里点击这个重命名

206
00:09:35,799 --> 00:09:37,399
它已重命名，甚至是名称

207
00:09:37,399 --> 00:09:40,399
此处文件的名称已重命名。 

208
00:09:40,399 --> 00:09:43,069
我们可以回去修复这些东西

209
00:09:43,070 --> 00:09:46,210
不确定，例如此处的评论， 

210
00:09:46,210 --> 00:09:50,980
说，这是我们的EmojiMemoryGameView.swift 

211
00:09:50,980 --> 00:09:53,469
实际上就是该文件的名称。 

212
00:09:53,669 --> 00:09:56,509
所以这只是重命名的一小部分

213
00:09:56,509 --> 00:09:59,289
因为有时您会为类型或变量选择一个名称

214
00:09:59,289 --> 00:10:00,639
然后你会决定， 

215
00:10:00,639 --> 00:10:02,360
我真的不喜欢那个名字，不是， 

216
00:10:02,360 --> 00:10:05,190
因为命名真的非常非常重要。 

217
00:10:05,190 --> 00:10:06,729
不能过分强调它的重要性

218
00:10:06,929 --> 00:10:08,879
为事物取好名字。 

219
00:10:08,879 --> 00:10:11,879
因此，当您改变主意后能够重命名， 

220
00:10:11,879 --> 00:10:13,409
非常非常重要

221
00:10:13,409 --> 00:10:17,449
但是，今天我们的话题将是这种反应。 

222
00:10:17,450 --> 00:10:19,690
我告诉你SwiftUI是反应式的。 

223
00:10:19,690 --> 00:10:21,729
反应是什么意思？ 

224
00:10:21,929 --> 00:10:24,129
我的意思是，当模型发生变化时， 

225
00:10:24,129 --> 00:10:28,429
它们将自动显示在“视图”中。 

226
00:10:28,429 --> 00:10:32,269
目前，我们的用户界面还没有反应。 

227
00:10:32,269 --> 00:10:33,779
所以这是一个问题。 

228
00:10:33,779 --> 00:10:37,149
让我们看看如何解决该问题

229
00:10:37,149 --> 00:10:38,819
并使其具有反应性。 

230
00:10:38,820 --> 00:10:42,609
我们不会在这里实现整个记忆游戏

231
00:10:42,809 --> 00:10:44,059
与所有匹配的卡片。 

232
00:10:44,059 --> 00:10:45,879
我们只是要向前迈出一步

233
00:10:45,879 --> 00:10:48,620
这就是我们要使卡片翻转的原因。 

234
00:10:48,620 --> 00:10:50,960
这是我们模型的一部分。 

235
00:10:50,960 --> 00:10:54,820
本质上，我们游戏逻辑的第一步是

236
00:10:54,820 --> 00:10:57,220
拥有卡片，当我们选择卡片时，翻转过来。 

237
00:10:57,220 --> 00:10:59,779
所以我已经移到了我的模型代码

238
00:10:59,779 --> 00:11:03,319
目前我们只说选择的卡片

239
00:11:03,320 --> 00:11:04,879
记得从上次开始。 

240
00:11:04,879 --> 00:11:07,889
现在我想开始实际实现我的游戏逻辑

241
00:11:07,889 --> 00:11:09,773
首先将卡翻转过来。 

242
00:11:11,029 --> 00:11:14,569
现在，您将对此进行查看，您会认为，哦，这很容易。 

243
00:11:14,570 --> 00:11:19,570
 Card.isFaceUp等于！card.isFaceUp，对吗？ 

244
00:11:20,789 --> 00:11:22,929
有人通过我们的卡

245
00:11:22,929 --> 00:11:25,009
他们想选择一个参数

246
00:11:25,009 --> 00:11:28,620
我只是要面对它

247
00:11:28,620 --> 00:11:32,720
在这里被切换或翻转为相反方向。 

248
00:11:32,720 --> 00:11:36,067
这有一个错误是

249
00:11:36,067 --> 00:11:39,259
 “无法分配给属性。'卡'是'let'常量。” 

250
00:11:39,259 --> 00:11:42,309
这都是争论

251
00:11:42,309 --> 00:11:44,809
功能本质上是让。 

252
00:11:44,809 --> 00:11:47,069
您不键入该让，但它们是一个让。 

253
00:11:47,070 --> 00:11:49,220
这是一个问题。 

254
00:11:49,220 --> 00:11:51,759
但这实际上比这糟得多。 

255
00:11:51,759 --> 00:11:54,850
这不只是让它出租。 

256
00:11:54,850 --> 00:11:56,850
这是一张卡。 

257
00:11:56,850 --> 00:11:58,769
卡是一种结构。 

258
00:11:58,769 --> 00:12:03,769
结构是我们上次谈到的值类型。 

259
00:12:04,480 --> 00:12:07,860
记住，复制了一个值类型

260
00:12:07,860 --> 00:12:10,379
每次将其作为参数传递给函数时

261
00:12:10,379 --> 00:12:13,409
甚至分配给另一个变量副本，副本，副本。 

262
00:12:13,409 --> 00:12:14,949
它总是被复制。 

263
00:12:14,950 --> 00:12:19,589
所以这里的这张卡是这里一张卡的副本。 

264
00:12:19,789 --> 00:12:24,169
新的ViewModel将其获取或分发给View 

265
00:12:24,169 --> 00:12:26,629
当视图获得时，它就是副本， 

266
00:12:26,629 --> 00:12:28,429
甚至一个副本。 

267
00:12:28,429 --> 00:12:31,819
所以这实际上不是阵列中的Card， 

268
00:12:31,820 --> 00:12:33,599
这是一个副本。 

269
00:12:33,799 --> 00:12:37,819
每次我们传递值类型时，它都会被复制。 

270
00:12:37,820 --> 00:12:39,570
所以即使我们可以做到

271
00:12:39,570 --> 00:12:41,109
因为那个问题我们不能

272
00:12:41,309 --> 00:12:43,739
基本上所有这些都是让

273
00:12:43,740 --> 00:12:45,500
无论如何，这不会做对的事情。 

274
00:12:45,500 --> 00:12:48,019
这只会改变这个人

275
00:12:48,019 --> 00:12:51,549
最多可以交换的空间无效

276
00:12:51,549 --> 00:12:53,309
就在这里

277
00:12:53,309 --> 00:12:55,819
因此，让我们在这里尝试完全不同的东西。 

278
00:12:55,820 --> 00:12:59,329
让我们尝试找出索引

279
00:12:59,529 --> 00:13:03,376
该卡在此阵列中的哪张卡。 

280
00:13:03,376 --> 00:13:06,719
我要说的是letedIndex， 

281
00:13:06,720 --> 00:13:08,599
这将是Int类型， 

282
00:13:08,799 --> 00:13:12,429
我等于，我要对自己调用一个函数， 

283
00:13:12,429 --> 00:13:15,329
该卡的索引。 

284
00:13:15,330 --> 00:13:18,109
所以索引我要写一个函数， 

285
00:13:18,109 --> 00:13:21,090
这将是这张卡的功能。 

286
00:13:21,090 --> 00:13:22,990
所以我要找到这张卡

287
00:13:22,990 --> 00:13:25,611
找出它在此数组中的索引。 

288
00:13:25,611 --> 00:13:29,679
因此，您具有的func索引将成为类型Card， 

289
00:13:29,679 --> 00:13:33,259
它会返回一个Int，而这个Int正在

290
00:13:33,259 --> 00:13:35,909
成为该数组的索引。 

291
00:13:35,909 --> 00:13:39,319
现在也许我会说让letedCard， 

292
00:13:39,320 --> 00:13:41,230
这将是类型卡

293
00:13:41,230 --> 00:13:46,173
在那个selectedIndex等于我的牌。 

294
00:13:47,149 --> 00:13:47,990
这听起来不错。 

295
00:13:47,990 --> 00:13:51,129
现在我可以说现在让我们翻转卡片， 

296
00:13:51,129 --> 00:13:55,062
 isFaceUp等于！chosenCard.isFaceUp。 

297
00:13:59,070 --> 00:14:01,320
所以这似乎是个好主意， 

298
00:14:01,320 --> 00:14:02,729
我们将在一分钟内实现它， 

299
00:14:02,929 --> 00:14:04,870
但这似乎很棒。 

300
00:14:04,870 --> 00:14:08,480
现在，我们从阵列中取出卡

301
00:14:08,480 --> 00:14:10,740
我们将其翻转过来。 

302
00:14:10,740 --> 00:14:15,480
但这也不会出于完全相同的原因而起作用。 

303
00:14:15,480 --> 00:14:20,330
当我们分配一个变种给这个选择的卡片时， 

304
00:14:20,330 --> 00:14:24,970
这等于将其复制到此处。 

305
00:14:24,970 --> 00:14:27,639
它将卡从阵列中复制出来。 

306
00:14:27,639 --> 00:14:29,990
所以即使只是做一个作业

307
00:14:29,990 --> 00:14:34,519
到另一个变量将复制值类型。 

308
00:14:34,519 --> 00:14:35,919
所以现在您可能会喜欢， 

309
00:14:35,919 --> 00:14:38,579
我们要如何改变这个东西？ 

310
00:14:38,580 --> 00:14:41,090
好吧，我们必须对其进行更改。 

311
00:14:41,090 --> 00:14:44,610
而不是在这里更改此副本， 

312
00:14:44,610 --> 00:14:46,899
我们将要更改此数组本身， 

313
00:14:46,899 --> 00:14:49,779
这一系列的卡片，我们将到达那里

314
00:14:49,779 --> 00:14:52,339
并更改正确的卡

315
00:14:52,340 --> 00:14:53,947
成为不同的FaceUp。 

316
00:14:55,009 --> 00:14:56,210
所以我们要去做。 

317
00:14:56,210 --> 00:15:00,479
仍然会做self.cards selectedIndex， 

318
00:15:00,679 --> 00:15:02,189
但不是这种间接的

319
00:15:02,190 --> 00:15:04,000
通过将其复制的变量

320
00:15:04,000 --> 00:15:06,799
我将直接拥有那个东西

321
00:15:06,799 --> 00:15:11,512
 FaceUp等于不是那个东西直接是FaceUp。 

322
00:15:13,182 --> 00:15:14,779
所以我要把卡片翻过来

323
00:15:14,779 --> 00:15:16,870
直接在数组内部。 

324
00:15:16,870 --> 00:15:18,940
这里发生了几件事。 

325
00:15:18,940 --> 00:15:21,479
一，注意我要放点

326
00:15:21,679 --> 00:15:25,719
在每次访问我的变量之前

327
00:15:25,720 --> 00:15:28,840
和功能，我呼吁自己。 

328
00:15:28,840 --> 00:15:33,389
在大多数情况下，此自圆点是可选的。 

329
00:15:33,389 --> 00:15:36,403
通常我什至会说，不要把它放在那里。 

330
00:15:36,403 --> 00:15:39,219
这只是额外的提示。 

331
00:15:39,419 --> 00:15:42,959
但是，由于这个原因，我上次谈到

332
00:15:42,960 --> 00:15:44,570
他们要去哪里

333
00:15:44,570 --> 00:15:47,590
因此，即使在少数情况下您确实需要一个自圆点， 

334
00:15:47,590 --> 00:15:51,149
像这里，在我们的视图中实际上需要自点

335
00:15:51,149 --> 00:15:53,439
当我们点击手势时，这个自圆点

336
00:15:53,440 --> 00:15:55,599
如果你把它拿走，那就有错误了， 

337
00:15:55,799 --> 00:15:58,959
您必须修复它，还记得吗？ 

338
00:15:58,960 --> 00:16:00,449
所以他们要把这个拿走。 

339
00:16:00,649 --> 00:16:02,199
当他们拿走那东西时， 

340
00:16:02,200 --> 00:16:04,980
那么您几乎无处需要自我标记。 

341
00:16:04,980 --> 00:16:06,409
所以在那个时候

342
00:16:06,409 --> 00:16:10,870
我不知道是从现在起两个月后，还是不清楚， 

343
00:16:10,870 --> 00:16:13,100
 WWDC是在六月初。 

344
00:16:13,100 --> 00:16:15,469
很多时候他们会推出新软件， 

345
00:16:15,669 --> 00:16:17,860
 Beta软件，至少在那时

346
00:16:17,860 --> 00:16:19,419
也许他们会解决的，我不知道。 

347
00:16:19,419 --> 00:16:20,490
我不在苹果公司工作

348
00:16:20,490 --> 00:16:23,000
我不知道他们的计划是什么， 

349
00:16:23,000 --> 00:16:26,039
但我们确实知道它已被公开批准

350
00:16:26,039 --> 00:16:28,000
摆脱这个自我点。 

351
00:16:28,000 --> 00:16:29,360
所以在这个过程中

352
00:16:29,360 --> 00:16:34,149
仅在本课程剩下的七八周内， 

353
00:16:34,149 --> 00:16:36,549
我有点推荐也许只是把自我点

354
00:16:36,549 --> 00:16:39,509
在一切面前，因为它不会伤害任何东西

355
00:16:39,509 --> 00:16:42,090
这样可以避免您遇到此问题

356
00:16:42,090 --> 00:16:43,953
您必须在哪里进行修复。 

357
00:16:44,929 --> 00:16:47,269
您只是在学习这些东西

358
00:16:47,269 --> 00:16:50,529
那会给你肌肉记忆

359
00:16:50,529 --> 00:16:52,209
总是输入自我点

360
00:16:52,210 --> 00:16:54,600
您必须训练自己

361
00:16:54,600 --> 00:16:59,350
在此公共修复程序发布后的几个月内。 

362
00:16:59,350 --> 00:17:01,659
但这会让您在本季度摆脱困境。 

363
00:17:01,659 --> 00:17:03,529
那是我的建议

364
00:17:03,529 --> 00:17:06,450
但是在您的作业中，我们不会说

365
00:17:06,450 --> 00:17:08,140
哦，那是错误的，你把自己加了点， 

366
00:17:08,140 --> 00:17:09,686
或哦，那是错误的，您没有设置自我标记。 

367
00:17:09,886 --> 00:17:11,940
这完全取决于您。 

368
00:17:11,940 --> 00:17:15,139
我只是想为您解决可能的问题。 

369
00:17:15,339 --> 00:17:19,302
因此，自我推荐可能是我的建议。 

370
00:17:21,834 --> 00:17:23,889
但是这里有什么？ 

371
00:17:24,089 --> 00:17:26,939
而且我们确信这会奏效。 

372
00:17:26,940 --> 00:17:30,630
我们确定要更改isFaceUp和该数组， 

373
00:17:30,630 --> 00:17:33,619
毫无疑问，selectedIndex的self.cards。 

374
00:17:33,819 --> 00:17:38,809
我们正在更改此数组以使其切换为isFaceUp， 

375
00:17:38,809 --> 00:17:40,836
但是我们这里仍然有一个错误， 

376
00:17:40,836 --> 00:17:45,269
 “无法分配给属性：'自我'是不可变的。” 

377
00:17:45,269 --> 00:17:48,309
并不是说这张卡是一成不变的

378
00:17:48,309 --> 00:17:50,909
因为卡不是，所以是变种。 

379
00:17:50,910 --> 00:17:52,839
如果放手，那将是一成不变的， 

380
00:17:53,039 --> 00:17:55,099
但这是一个变种，所以是可变的， 

381
00:17:55,099 --> 00:17:59,769
但是它本身就是一成不变的。 

382
00:17:59,769 --> 00:18:02,670
换句话说，我们自己的功能似乎

383
00:18:02,670 --> 00:18:06,473
能够改变我们的自我。 

384
00:18:07,680 --> 00:18:10,730
如果我们做不到，那该怎么办呢？ 

385
00:18:10,730 --> 00:18:13,829
好吧，这是怎么回事

386
00:18:13,829 --> 00:18:16,470
我告诉你这些值类型

387
00:18:16,470 --> 00:18:19,069
 Swift没有做按位复制， 

388
00:18:19,069 --> 00:18:21,019
实际上不是在复制它们

389
00:18:21,019 --> 00:18:23,980
从内存中的一个地方到另一个地方

390
00:18:23,980 --> 00:18:25,930
当你把它们传过来时。 

391
00:18:25,930 --> 00:18:27,170
这就是语义

392
00:18:27,170 --> 00:18:29,409
那就是你要想象它正在发生的方式， 

393
00:18:29,609 --> 00:18:33,119
但这实际上只是在内存中制作这些副本

394
00:18:33,119 --> 00:18:36,879
当您开始更改我们在这里所做的事情时。 

395
00:18:36,880 --> 00:18:41,880
我们正在更改此数组，这是我们的实际属性， 

396
00:18:42,380 --> 00:18:43,660
所以我们不复印

397
00:18:43,660 --> 00:18:45,220
实际上是在改变数组， 

398
00:18:45,220 --> 00:18:49,740
但是这种方法改变了我们的自我。 

399
00:18:49,740 --> 00:18:52,920
它改变了我们的自我，因为它改变了我们的牌。 

400
00:18:52,920 --> 00:18:55,529
所以我们必须通过说让Swift知道这一点

401
00:18:55,529 --> 00:18:58,170
这是一个变异函数。 

402
00:18:58,170 --> 00:19:01,630
所以所有修改自我的功能

403
00:19:01,630 --> 00:19:04,379
必须在结构中标记为变异。 

404
00:19:04,579 --> 00:19:06,369
这在课堂上是不正确的。 

405
00:19:06,369 --> 00:19:08,229
类在堆中。 

406
00:19:08,230 --> 00:19:09,400
我们有指向他们的指针。 

407
00:19:09,400 --> 00:19:11,849
我们总是可以更改堆中的内容， 

408
00:19:12,049 --> 00:19:14,869
总是通过指针修改事物， 

409
00:19:14,869 --> 00:19:16,589
正如我之前所说， 

410
00:19:16,589 --> 00:19:19,659
可以和一件好事一样是一件坏事。 

411
00:19:19,660 --> 00:19:21,589
但是对于结构，不，因为它们是值类型

412
00:19:21,789 --> 00:19:25,109
我们必须让Swift知道我们正在对此进行更改。 

413
00:19:25,109 --> 00:19:28,089
现在，索引，我们将在这里写一秒钟， 

414
00:19:28,089 --> 00:19:31,959
它只是获取此阵列中Card的索引。 

415
00:19:31,960 --> 00:19:33,579
它实际上并没有改变任何东西。 

416
00:19:33,579 --> 00:19:34,839
它只是获取索引。 

417
00:19:34,839 --> 00:19:38,240
因此，它不需要或不想在这里进行变异。 

418
00:19:38,240 --> 00:19:41,380
同样或相反， 

419
00:19:41,380 --> 00:19:45,380
我们的初始化器隐式地改变了我们的自我。 

420
00:19:45,380 --> 00:19:46,409
我们正在创造自我。 

421
00:19:46,609 --> 00:19:49,469
我们在这里设置所有变量。 

422
00:19:49,470 --> 00:19:51,319
所以这当然是变异的

423
00:19:51,319 --> 00:19:53,339
所以你不用说变异了。 

424
00:19:53,339 --> 00:19:55,490
所有的初始化都是变异的。 

425
00:19:55,490 --> 00:19:59,630
这都是值类型很酷的功能的一部分

426
00:19:59,630 --> 00:20:01,980
 Swift知道他们何时进行更改。 

427
00:20:01,980 --> 00:20:03,092
然后你会看到

428
00:20:03,292 --> 00:20:07,159
除此副本外，还有其他好处

429
00:20:07,160 --> 00:20:10,023
当我们复制事物时保持正确的行为。 

430
00:20:11,150 --> 00:20:13,960
卡的索引，我们如何找出

431
00:20:13,960 --> 00:20:17,139
我们在哪里获得这张卡的索引

432
00:20:17,339 --> 00:20:18,539
在这个数组中吗？ 

433
00:20:18,539 --> 00:20:22,159
我们想要具有该卡的数组的索引。 

434
00:20:22,160 --> 00:20:24,589
事实证明，这对我们来说超级容易

435
00:20:24,789 --> 00:20:28,730
因为卡是可识别的。 

436
00:20:28,730 --> 00:20:31,920
由于它是可识别的，因此我们只需查看其ID 

437
00:20:31,920 --> 00:20:34,619
并唯一地查看它是哪张卡。 

438
00:20:34,819 --> 00:20:37,240
所以我们只需要在这里做一些for循环

439
00:20:37,240 --> 00:20:42,240
如果零点索引小于我们的卡数， 

440
00:20:42,250 --> 00:20:44,309
还是再一次，如果我们正在做自我点， 

441
00:20:44,309 --> 00:20:47,072
 self.cards.count，无论哪种方式。 

442
00:20:48,592 --> 00:20:49,710
我只是要经历每一个

443
00:20:49,710 --> 00:20:52,250
我要说如果自我点卡

444
00:20:52,250 --> 00:20:56,720
在那个索引id等于

445
00:20:56,720 --> 00:20:59,083
这东西在这里， 

446
00:20:59,920 --> 00:21:04,920
顺便说一句，我猜是两个等号， 

447
00:21:04,930 --> 00:21:07,880
那么我可以返回该索引，因为我找到了它。 

448
00:21:07,880 --> 00:21:09,730
在这里，我正在看我的数组

449
00:21:09,730 --> 00:21:12,690
查看索引是否为该索引的Card， 

450
00:21:12,690 --> 00:21:16,029
它的ID与您传递的ID相同。 

451
00:21:16,029 --> 00:21:20,822
现在，您已经可以在这里真正看到一个问题了。 

452
00:21:21,680 --> 00:21:24,029
我们将这个变量称为，不。 

453
00:21:24,029 --> 00:21:25,910
我们不想这样称呼。 

454
00:21:25,910 --> 00:21:27,769
 Of只是让它变得不错的东西

455
00:21:27,769 --> 00:21:31,589
给打电话给我们说卡片自我索引的人。 

456
00:21:31,589 --> 00:21:36,589
这就是为什么我们要使用双重标签

457
00:21:36,789 --> 00:21:39,366
外部名称，内部名称。 

458
00:21:39,366 --> 00:21:43,319
这样我们就可以将此卡号称为ID 

459
00:21:43,319 --> 00:21:47,339
但是呼叫者仍然可以说出卡片索引。 

460
00:21:47,339 --> 00:21:48,869
希望这是一个很好的例子， 

461
00:21:48,869 --> 00:21:51,476
完全明白为什么我们有外部名称

462
00:21:51,477 --> 00:21:53,909
和参数的内部名称。 

463
00:21:54,109 --> 00:21:55,689
我们没有在这里做。 

464
00:21:55,690 --> 00:21:58,399
外部名称和内部名称相同。 

465
00:21:58,599 --> 00:22:00,009
这里有点争论

466
00:22:00,009 --> 00:22:03,170
您可能实际上选择了下栏

467
00:22:03,170 --> 00:22:05,649
因为很明显，我们正在选择一张卡

468
00:22:05,849 --> 00:22:07,629
这就是这种说法的类型

469
00:22:07,630 --> 00:22:09,599
无论如何我们还会选择什么？ 

470
00:22:09,799 --> 00:22:11,730
但是我要这样离开，只是我们没有

471
00:22:11,730 --> 00:22:12,819
更改我们的其他代码。 

472
00:22:12,819 --> 00:22:15,079
但是如果您阅读指南

473
00:22:15,079 --> 00:22:16,399
作为上周家庭作业的一部分， 

474
00:22:16,400 --> 00:22:17,619
您会看到这是一个

475
00:22:17,819 --> 00:22:20,200
那里可能有一个酒吧

476
00:22:20,200 --> 00:22:22,700
然后人们会选择

477
00:22:22,700 --> 00:22:24,390
并提供Card作为参数， 

478
00:22:24,390 --> 00:22:26,930
呼叫者将没有标签。 

479
00:22:26,930 --> 00:22:29,869
我们已经完成了for循环，我们找到了这个。 

480
00:22:30,069 --> 00:22:31,516
这里还在抱怨什么？ 

481
00:22:31,517 --> 00:22:35,149
 “函数中的期望返回Int缺少返回。” 

482
00:22:35,349 --> 00:22:38,779
哦，是的，如果这个for循环一直进行下去

483
00:22:38,779 --> 00:22:41,329
却找不到那个卡？ 

484
00:22:41,329 --> 00:22:44,143
然后我们必须在这里退货。 

485
00:22:45,039 --> 00:22:48,579
所以Swift实际上有一件很棒的事情

486
00:22:48,579 --> 00:22:51,220
发生这种情况时返回这里

487
00:22:51,220 --> 00:22:54,200
就像您去寻找东西一样，您找不到它。 

488
00:22:54,200 --> 00:22:57,880
在其他语言中，您可能会返回减一

489
00:22:57,880 --> 00:23:01,119
或一些伪造的东西。 

490
00:23:01,319 --> 00:23:04,349
我想我会回来，也许你会归零

491
00:23:04,349 --> 00:23:07,006
这是完全错误的第一个要素。 

492
00:23:07,007 --> 00:23:09,289
如果您去找卡，却找不到它， 

493
00:23:09,289 --> 00:23:11,149
你会说，好吧，归还第一张卡

494
00:23:11,150 --> 00:23:13,379
即使您知道那不是卡。 

495
00:23:13,579 --> 00:23:16,599
所以我们现在回到这里并不重要

496
00:23:16,599 --> 00:23:18,329
因为这都是错误的。 

497
00:23:18,329 --> 00:23:19,769
但是我要放一点东西

498
00:23:19,769 --> 00:23:23,859
在这里叫一个TODO，然后说假的。 

499
00:23:23,859 --> 00:23:26,699
 TODO是您以后可以回头的东西， 

500
00:23:26,700 --> 00:23:30,190
斜杠斜杠TODO，发现提醒自己

501
00:23:30,190 --> 00:23:31,690
您需要解决此问题。 

502
00:23:31,690 --> 00:23:34,149
这些出现在顶部

503
00:23:34,349 --> 00:23:35,349
它说索引。 

504
00:23:35,349 --> 00:23:38,659
如果您单击，这是我所有的变量和函数的列表， 

505
00:23:38,660 --> 00:23:40,440
看起来假货就在那里。 

506
00:23:40,440 --> 00:23:42,720
如果我单击它，则需要我进行虚假验证。 

507
00:23:42,720 --> 00:23:46,160
当我向您展示这种很酷的方式时，我们会回来的

508
00:23:46,160 --> 00:23:47,630
你可以退还东西

509
00:23:47,630 --> 00:23:50,150
就像我在Swift中找不到它一样。 

510
00:23:50,150 --> 00:23:52,359
我们将在下一次讲座中介绍

511
00:23:52,559 --> 00:23:54,226
我们将修复此问题，我们将修复此问题。 

512
00:23:54,227 --> 00:23:57,460
但是现在，我们要在这里做这个假的事情。 

513
00:23:57,460 --> 00:23:59,250
所以我们有卡索引。 

514
00:23:59,250 --> 00:24:02,009
我们绝对是在这里翻转卡。 

515
00:24:02,009 --> 00:24:05,250
因此，让我们运行，看看它是否有效。 

516
00:24:05,250 --> 00:24:07,369
因为我们知道我们已经对此进行了连接

517
00:24:07,369 --> 00:24:08,719
在那儿选择卡。 

518
00:24:08,720 --> 00:24:10,880
所以现在应该选择，例如选择卡片

519
00:24:10,880 --> 00:24:12,869
然后将它翻转过来，就可以开始了

520
00:24:13,069 --> 00:24:14,829
准备好了，鬼。 

521
00:24:14,829 --> 00:24:17,052
哦，南瓜。 

522
00:24:18,410 --> 00:24:21,609
好吧，这肯定是在这里访问模型

523
00:24:21,809 --> 00:24:24,240
因为我们正在选择这张卡。 

524
00:24:24,240 --> 00:24:26,849
但是，这些卡为何面朝上呢？ 

525
00:24:26,849 --> 00:24:29,079
这里发生了什么？ 

526
00:24:29,079 --> 00:24:30,869
好吧，这是怎么回事

527
00:24:30,869 --> 00:24:33,629
我们还没有实施反应式的东西。 

528
00:24:33,630 --> 00:24:35,400
我一开始就告诉你

529
00:24:35,400 --> 00:24:38,649
这就是为什么我们今天在这里要做这种反应性的事情。 

530
00:24:38,849 --> 00:24:41,279
您会看到为什么我们需要反应堆。 

531
00:24:41,279 --> 00:24:45,289
我们选择了一张卡片，它去了这里并更改了型号， 

532
00:24:45,289 --> 00:24:47,220
它翻转了一张卡片

533
00:24:47,220 --> 00:24:49,759
但是我们在用户界面中什么都没有看到。 

534
00:24:49,759 --> 00:24:53,369
而且在SwiftUI中永远不会是这种情况。 

535
00:24:53,369 --> 00:24:57,259
更改模型时，UI应更新。 

536
00:24:57,259 --> 00:24:59,660
我们如何做到这一点？ 

537
00:24:59,660 --> 00:25:02,509
如果您记得我的MVVM幻灯片， 

538
00:25:02,509 --> 00:25:06,089
我在屏幕上放了一些关键字，然后说： 

539
00:25:06,089 --> 00:25:08,899
这些Swift关键字，我们将使用这些关键字

540
00:25:08,900 --> 00:25:10,609
做这个反应，这就是

541
00:25:10,809 --> 00:25:12,450
我们现在要做什么。 

542
00:25:12,450 --> 00:25:14,759
我们将从ViewModel开始。 

543
00:25:14,759 --> 00:25:17,200
这是我们的ViewModel。 

544
00:25:17,200 --> 00:25:20,409
以及我们使ViewModel参与的方式

545
00:25:20,609 --> 00:25:24,309
在这种反应性的东西中使用约束

546
00:25:24,309 --> 00:25:27,539
并获得称为ObservableObject的东西。 

547
00:25:28,619 --> 00:25:31,469
现在记住限制和收获， 

548
00:25:31,470 --> 00:25:33,960
也被称为协议。 

549
00:25:33,960 --> 00:25:37,329
这些限制和收获，我们在这里使用了一个， 

550
00:25:37,329 --> 00:25:40,059
冒号的观点，那是一种制约和收获。 

551
00:25:40,059 --> 00:25:42,059
我们有点受制于

552
00:25:42,059 --> 00:25:43,519
实施这个机构

553
00:25:43,519 --> 00:25:46,389
但是我们获得了所有其他功能

554
00:25:46,390 --> 00:25:47,409
我们可以发送给View。 

555
00:25:47,609 --> 00:25:49,919
所以这是一个巨大的收获

556
00:25:49,920 --> 00:25:53,409
因为我们的限制很小，请点击此处查看。 

557
00:25:53,609 --> 00:25:56,299
我们也在模型，卡片中做到了。 

558
00:25:56,299 --> 00:25:59,309
我们进行了约束并取得了可识别的收益， 

559
00:25:59,309 --> 00:26:02,679
这要求我们执行此var id Int， 

560
00:26:02,680 --> 00:26:06,919
但是现在我们可以分辨哪张卡了。 

561
00:26:07,119 --> 00:26:10,639
用户界面将在此ForEach中使用

562
00:26:10,640 --> 00:26:13,339
确保我们的卡四处走动

563
00:26:13,539 --> 00:26:15,980
我们可以跟踪它们的位置并为其设置动画。 

564
00:26:15,980 --> 00:26:19,599
您将看到SwiftUI中的动画非常简单

565
00:26:19,599 --> 00:26:22,432
很大程度上是因为这种机制。 

566
00:26:23,509 --> 00:26:26,170
所以这就是制约和收获， 

567
00:26:26,170 --> 00:26:28,380
约束几乎没有。 

568
00:26:28,380 --> 00:26:31,169
您无需实现任何var或funcs， 

569
00:26:31,369 --> 00:26:34,289
没有身体或身份证或类似的东西。 

570
00:26:34,289 --> 00:26:37,609
微小的限制是它只能工作

571
00:26:37,609 --> 00:26:40,329
对于类，使用ObservableObject。 

572
00:26:40,329 --> 00:26:44,750
如果您是班级，则只能在此处成为ObservableObject， 

573
00:26:44,750 --> 00:26:47,309
所以那是次要的约束。 

574
00:26:47,309 --> 00:26:50,700
现在，通过这样做您获得的收益

575
00:26:50,700 --> 00:26:53,990
您是否获得了一个名为objectWillChange的变量。 

576
00:26:54,900 --> 00:26:56,390
这个变种在这里，你没有

577
00:26:56,390 --> 00:26:58,640
像我们对身体一样放在这里

578
00:26:58,640 --> 00:27:00,380
您可以在后台免费获得它。 

579
00:27:00,380 --> 00:27:01,809
所以这里不会。 

580
00:27:02,009 --> 00:27:04,349
我只是向您展示您所得到的。 

581
00:27:04,349 --> 00:27:07,949
而且这个var不是真正的这种类型， 

582
00:27:07,950 --> 00:27:10,700
 ObservableObjectPublisher， 

583
00:27:10,700 --> 00:27:12,269
比这复杂一点。 

584
00:27:12,269 --> 00:27:16,379
我们甚至不知道或不在乎它是什么

585
00:27:16,380 --> 00:27:19,859
但是我们需要了解有关此var的两件事。 

586
00:27:20,059 --> 00:27:22,809
一个是它是发布者， 

587
00:27:22,809 --> 00:27:25,329
意味着它可以发布给全世界， 

588
00:27:25,329 --> 00:27:26,689
对任何有兴趣的人， 

589
00:27:26,690 --> 00:27:29,019
我们的观点将会引起人们的兴趣， 

590
00:27:29,019 --> 00:27:30,829
当某些变化。 

591
00:27:30,829 --> 00:27:35,579
而且这个变数只能传送一个函数

592
00:27:35,579 --> 00:27:37,633
这是发送功能。 

593
00:27:38,539 --> 00:27:42,552
如果您调用该函数在objectWillChange上发送， 

594
00:27:43,410 --> 00:27:47,009
即将发布给世界

595
00:27:47,009 --> 00:27:51,690
关于这个对象，或者真的会很快改变

596
00:27:51,690 --> 00:27:53,869
所以准备好然后对它做出反应。 

597
00:27:54,069 --> 00:27:56,730
就是这样，这就是我们要做的，真的， 

598
00:27:56,730 --> 00:27:59,549
让我们的ViewModel参与其中。 

599
00:27:59,549 --> 00:28:02,049
所以每次我们的模型改变时

600
00:28:02,049 --> 00:28:05,690
我们想要做objectWillChange.send。 

601
00:28:05,690 --> 00:28:07,950
例如，这是一个意图。 

602
00:28:07,950 --> 00:28:10,029
显然，我们正在此处更改模型。 

603
00:28:10,029 --> 00:28:11,759
我们知道选择卡

604
00:28:11,759 --> 00:28:15,319
是一个可变的变异函数。 

605
00:28:15,319 --> 00:28:17,950
因此，这当然会改变我们的模型。 

606
00:28:17,950 --> 00:28:22,950
所以在这里我们只说objectWillChange.send。 

607
00:28:24,009 --> 00:28:27,220
这是唯一的功能，真的，我们要调用

608
00:28:27,220 --> 00:28:30,180
关于此对象将在此处更改。 

609
00:28:30,180 --> 00:28:33,023
这将要发布到全世界， 

610
00:28:34,017 --> 00:28:37,669
 objectWillChange表示此MemoryGame将更改。 

611
00:28:37,869 --> 00:28:38,702
就这样。 

612
00:28:38,702 --> 00:28:41,750
这并不是说它是如何改变的，它已经改变了。 

613
00:28:41,750 --> 00:28:43,920
这一点很重要

614
00:28:43,920 --> 00:28:46,400
因为如果此ViewModel更改， 

615
00:28:46,400 --> 00:28:48,129
模型上的此门户已更改， 

616
00:28:48,329 --> 00:28:50,679
希望该门户需要的视图

617
00:28:50,680 --> 00:28:52,220
重画自己。 

618
00:28:52,220 --> 00:28:53,839
我们将在短短一秒钟内告诉您

619
00:28:53,839 --> 00:28:56,829
他们如何注册才能做到这一点。 

620
00:28:56,829 --> 00:28:59,129
再说一次，我们不需要把它放在这里， 

621
00:28:59,130 --> 00:29:00,500
我们免费获得它。 

622
00:29:00,500 --> 00:29:02,859
而当我摆脱它时，您将看不到任何错误。 

623
00:29:02,859 --> 00:29:04,549
这完全是合法的。 

624
00:29:04,549 --> 00:29:06,819
您可以随时拨打此电话， 

625
00:29:06,819 --> 00:29:08,599
任何时候改变。 

626
00:29:08,599 --> 00:29:10,775
甚至不必改变您的模型。 

627
00:29:10,776 --> 00:29:14,220
例如，如果您要更改这些表情符号， 

628
00:29:14,220 --> 00:29:18,150
您可以完全由您来调用objectWillChange。 

629
00:29:18,150 --> 00:29:21,519
但是，在重要的应用中

630
00:29:21,519 --> 00:29:25,109
您可能会有很多意图， 

631
00:29:25,109 --> 00:29:27,599
许多可能会改变您的模型的不同事物。 

632
00:29:27,599 --> 00:29:29,329
这有点烦人

633
00:29:29,329 --> 00:29:31,279
不得不说objectWillChange.send， 

634
00:29:31,279 --> 00:29:32,379
 objectWillChange.send。 

635
00:29:32,380 --> 00:29:33,880
甚至容易出错。 

636
00:29:33,880 --> 00:29:37,480
如果我哎呀雏菊忘了把它放在那里

637
00:29:38,349 --> 00:29:39,939
然后您选择一张卡片，就像

638
00:29:39,940 --> 00:29:42,140
卡仍然不翻转，为什么？ 

639
00:29:42,140 --> 00:29:44,339
因为我忘了把它放在那里。 

640
00:29:44,539 --> 00:29:49,329
因此，尽管我们可以随时调用objectWillChange.send， 

641
00:29:49,329 --> 00:29:51,419
通常是我们处理这个问题的方式

642
00:29:51,420 --> 00:29:55,987
是我们采用此var并使其发布。 

643
00:29:57,730 --> 00:30:01,059
所以这不是Swift关键字， 

644
00:30:01,059 --> 00:30:02,769
你会看到它不是洋红色的

645
00:30:02,769 --> 00:30:05,269
这就是所谓的属性包装器

646
00:30:05,269 --> 00:30:07,420
这是一个财产。 

647
00:30:07,420 --> 00:30:11,169
属性包装器添加了一些功能

648
00:30:11,369 --> 00:30:13,139
周围的财产。 

649
00:30:13,140 --> 00:30:15,980
在这种情况下，这个包装器要做的是

650
00:30:15,980 --> 00:30:19,430
每当此属性，模型发生变化时， 

651
00:30:19,430 --> 00:30:22,150
它调用objectWillChange.send。 

652
00:30:22,150 --> 00:30:23,960
这就是它的作用。 

653
00:30:23,960 --> 00:30:27,977
确实如此，要使我们的ObservableObject在此处， 

654
00:30:27,977 --> 00:30:31,480
我们的ViewModel会在每次发生变化时广播， 

655
00:30:31,480 --> 00:30:35,659
我们只需要@Published我们所有的变量

656
00:30:35,859 --> 00:30:37,500
我们关心他们是否改变

657
00:30:37,500 --> 00:30:39,880
在这种情况下只是我们的一个Model var。 

658
00:30:39,880 --> 00:30:42,130
也可能是其他事情。 

659
00:30:42,130 --> 00:30:42,879
你可以有很多

660
00:30:43,079 --> 00:30:44,639
 @发布的vars，如果想要的话。 

661
00:30:44,640 --> 00:30:46,589
任何时候只要他们改变

662
00:30:46,789 --> 00:30:49,200
这将是objectWillChange.send， 

663
00:30:49,200 --> 00:30:50,363
这就是它的作用。 

664
00:30:51,490 --> 00:30:54,099
这看起来比记住要好得多

665
00:30:54,099 --> 00:30:58,309
将objectWillChange.send放入所有这些函数中。 

666
00:30:58,309 --> 00:30:59,440
您仍然可以选择

667
00:30:59,440 --> 00:31:02,680
即使使用这些，也可以执行objectWillChange.send 

668
00:31:02,680 --> 00:31:04,480
但是大多数时候你不会

669
00:31:04,480 --> 00:31:06,906
做objectWillChange.send。 

670
00:31:08,059 --> 00:31:09,440
所以我们快到了。 

671
00:31:09,440 --> 00:31:11,039
现在我们有了ViewModel 

672
00:31:11,039 --> 00:31:15,529
因此每次模型更改时都会发布。 

673
00:31:15,529 --> 00:31:18,470
现在我们只需要在这里修复我们的视图

674
00:31:18,470 --> 00:31:23,470
这样，当看到此ViewModel发布时，它将重新绘制。 

675
00:31:25,509 --> 00:31:28,660
每当看到这个东西时都会重画， 

676
00:31:28,660 --> 00:31:30,990
说出objectWillChange.send。 

677
00:31:30,990 --> 00:31:33,410
这样做的方法是使用另一个属性包装器

678
00:31:33,410 --> 00:31:36,692
在这个称为@ObservedObject的对象上。 

679
00:31:38,000 --> 00:31:42,589
就是说这个var中有一个ObservableObject， 

680
00:31:42,589 --> 00:31:46,099
这样做，EmojiMemoryGame是一个ObservableObject。 

681
00:31:46,099 --> 00:31:50,689
并且每当它说objectWillChange.send时，都要重画。 

682
00:31:50,690 --> 00:31:52,690
当然要重画这一个

683
00:31:52,690 --> 00:31:57,210
也会导致该笔重绘。 

684
00:31:57,210 --> 00:31:58,730
现在，您可能会觉得， 

685
00:31:58,730 --> 00:32:00,630
哇，这可能效率很低， 

686
00:32:00,630 --> 00:32:02,640
如果模型一直在变化，该怎么办？ 

687
00:32:02,640 --> 00:32:05,630
我们是否会每次都重新绘制视图？ 

688
00:32:05,630 --> 00:32:07,569
好，是的，不是。 

689
00:32:07,769 --> 00:32:11,349
是的，我们将对objectWillChange做出反应

690
00:32:11,349 --> 00:32:15,769
和重绘，但是SwiftUI很聪明地看到了

691
00:32:15,769 --> 00:32:17,900
是否确实发生了变化。 

692
00:32:17,900 --> 00:32:19,640
因此，如果我们翻转一张卡， 

693
00:32:19,640 --> 00:32:22,319
不会重提每张卡， 

694
00:32:22,519 --> 00:32:25,160
只是改变了，它知道

695
00:32:25,160 --> 00:32:27,430
因为卡是可识别的。 

696
00:32:27,430 --> 00:32:30,670
您开始明白为什么这ForEach 

697
00:32:30,670 --> 00:32:34,970
在这一系列卡片上，我们不得不对此进行识别吗？ 

698
00:32:34,970 --> 00:32:37,490
它有助于它了解这一变化

699
00:32:37,490 --> 00:32:39,910
所以我实际上需要重画。 

700
00:32:39,910 --> 00:32:42,680
因为实际上是在调用此代码

701
00:32:42,680 --> 00:32:44,670
可能不是很贵。 

702
00:32:44,670 --> 00:32:47,869
实际上是在屏幕上绘图，这非常昂贵。 

703
00:32:48,069 --> 00:32:51,192
因此，SwiftUI会尽一切可能避免这样做。 

704
00:32:52,349 --> 00:32:55,029
但是从概念上讲，这很简单。 

705
00:32:55,029 --> 00:32:57,129
每当我们的模型改变时， 

706
00:32:57,130 --> 00:33:00,849
这个@Published包装器注意到

707
00:33:01,049 --> 00:33:04,039
我们是一个ObservableObject，因此我们的View可以标记

708
00:33:04,039 --> 00:33:05,990
对那个出版感兴趣

709
00:33:05,990 --> 00:33:08,279
瞧，这会重绘。 

710
00:33:08,279 --> 00:33:12,000
这就是我们进行反应式编程的方式。 

711
00:33:12,000 --> 00:33:13,359
真的，这就是全部。 

712
00:33:13,359 --> 00:33:15,659
我们将看到一些小的改进

713
00:33:15,660 --> 00:33:19,919
做到这一点，但这实际上是它的工作方式。 

714
00:33:20,119 --> 00:33:21,379
因此，让我们看看它是否有效。 

715
00:33:21,380 --> 00:33:22,849
让我们运行我们的应用程序。 

716
00:33:23,049 --> 00:33:25,669
希望当我们点击卡片时， 

717
00:33:25,670 --> 00:33:27,019
我们会说选择了卡

718
00:33:27,019 --> 00:33:28,470
但它们也将翻转过来。 

719
00:33:28,470 --> 00:33:30,053
因此，让我们尝试一下。 

720
00:33:31,210 --> 00:33:34,640
幽灵，我点击它，它正在双向翻转。 

721
00:33:34,640 --> 00:33:37,200
我让这个家伙，这个家伙，这个家伙。 

722
00:33:37,200 --> 00:33:38,389
好吧。 

723
00:33:38,589 --> 00:33:42,529
所以这里发生的是我们点击这些， 

724
00:33:42,529 --> 00:33:44,369
它是在onTapGesture上完成的。 

725
00:33:44,369 --> 00:33:47,750
它在ViewModel中表达了这个Intent。 

726
00:33:47,750 --> 00:33:50,309
然后，ViewModel询问模型

727
00:33:50,309 --> 00:33:51,559
去做吧。 

728
00:33:51,559 --> 00:33:54,429
模型正在做这种变异的事情。 

729
00:33:54,430 --> 00:33:56,500
一旦完成了这种变异的事情， 

730
00:33:56,500 --> 00:33:59,859
很容易注意到这已经改变了

731
00:33:59,859 --> 00:34:02,779
它被发布，objectWillChange.send， 

732
00:34:02,779 --> 00:34:05,670
这个家伙观察到那些objectWillChange.send 

733
00:34:05,670 --> 00:34:07,019
并正在重画。 

734
00:34:07,019 --> 00:34:11,190
那是我给你看的幻灯片， 

735
00:34:11,190 --> 00:34:14,972
来回，这就是代码中的样子。 

736
00:34:17,000 --> 00:34:21,099
所以我们现在需要跳回幻灯片

737
00:34:21,099 --> 00:34:23,232
再谈一些协议。 

738
00:34:24,269 --> 00:34:26,409
一个协议会期待你

739
00:34:26,409 --> 00:34:29,940
就像是精简的类或结构， 

740
00:34:29,940 --> 00:34:33,500
剥离下来，因为它具有函数和变量

741
00:34:33,500 --> 00:34:35,460
但没有实施。 

742
00:34:35,460 --> 00:34:38,460
这是我制定的可移动协议。 

743
00:34:38,460 --> 00:34:40,769
它具有一个功能和两个变量。 

744
00:34:40,769 --> 00:34:43,239
 var之一仅在hasMoved处读取。 

745
00:34:43,239 --> 00:34:46,129
您可以看到它带有大括号。 

746
00:34:46,130 --> 00:34:47,530
然后distanceFromStart 

747
00:34:47,530 --> 00:34:49,864
实际上是可读写的

748
00:34:49,864 --> 00:34:51,889
这就是为什么它已经得到设置。 

749
00:34:51,889 --> 00:34:53,659
但是这里没有实现。 

750
00:34:53,659 --> 00:34:54,879
甚至那里的那些花括号， 

751
00:34:54,880 --> 00:34:57,090
那只是说这些变量是否是只读的， 

752
00:34:57,090 --> 00:34:58,452
这就是全部。 

753
00:34:59,539 --> 00:35:01,969
声明协议后， 

754
00:35:01,969 --> 00:35:05,378
现在任何类型，结构或类都可以出现， 

755
00:35:05,378 --> 00:35:09,619
是的，我要实现这一目标。 

756
00:35:09,619 --> 00:35:12,819
声称要实现该协议。 

757
00:35:12,820 --> 00:35:15,150
所以这里有一个结构轻便的东西

758
00:35:15,349 --> 00:35:18,739
它在此声明中表示冒号Moveable。 

759
00:35:18,739 --> 00:35:21,229
当它这么说时，立即意味着

760
00:35:21,230 --> 00:35:22,880
我注册实施

761
00:35:22,880 --> 00:35:25,230
因此，它必须实现每个var 

762
00:35:25,429 --> 00:35:28,099
以及Moveable中的每个功能。 

763
00:35:28,099 --> 00:35:30,769
现在我们已经在View之前看到了

764
00:35:30,769 --> 00:35:33,679
我们有ContentView，冒号视图。 

765
00:35:33,679 --> 00:35:35,809
它签约成为View，这就是为什么它拥有

766
00:35:35,809 --> 00:35:40,039
做var body，同一件事是Card，可识别。 

767
00:35:40,039 --> 00:35:41,929
它签署了实施Identifiable的协议。 

768
00:35:41,929 --> 00:35:44,623
它必须实现该var id。 

769
00:35:46,369 --> 00:35:50,969
现在也可以说一个协议

770
00:35:50,969 --> 00:35:52,609
它需要另一个协议。 

771
00:35:52,610 --> 00:35:54,769
这称为协议继承， 

772
00:35:54,769 --> 00:35:56,969
不要与类继承混淆

773
00:35:56,969 --> 00:35:59,079
因为我们在这里只是在谈论协议。 

774
00:35:59,079 --> 00:36:01,219
所以我这里有一个协议载具

775
00:36:01,219 --> 00:36:04,459
它是从Moveable继承的。 

776
00:36:04,460 --> 00:36:07,550
它在那里添加了自己的var，passengerCount。 

777
00:36:07,550 --> 00:36:11,150
因此，如果像汽车这样的课程出现在底部

778
00:36:11,349 --> 00:36:13,849
它说，我签署了您的车辆， 

779
00:36:13,849 --> 00:36:15,889
现在它必须执行所有三件事

780
00:36:15,889 --> 00:36:17,849
来自Moveable，它具有

781
00:36:17,849 --> 00:36:19,650
来实现Vehicle的东西。 

782
00:36:20,500 --> 00:36:23,309
如果您是结构或类，也可以

783
00:36:23,309 --> 00:36:25,719
声称实现多种协议。 

784
00:36:25,719 --> 00:36:27,559
所以这里有上课车。 

785
00:36:27,559 --> 00:36:29,710
不只是说这是一辆车

786
00:36:29,710 --> 00:36:32,429
而且它是可移植的

787
00:36:32,429 --> 00:36:35,529
现在汽车可能必须实现vars中的所有功能

788
00:36:35,530 --> 00:36:37,773
在所有这三个协议中。 

789
00:36:38,739 --> 00:36:41,250
现在，协议就是一种类型。 

790
00:36:41,250 --> 00:36:44,320
这意味着可以使用大多数协议

791
00:36:44,320 --> 00:36:46,650
在大多数情况下，您有类型。 

792
00:36:46,650 --> 00:36:51,369
例如，我可以有一个类型为Moveable的变量m。 

793
00:36:51,369 --> 00:36:54,295
那是m的类型，这是Moveable的类型。 

794
00:36:54,295 --> 00:36:55,289
那是什么意思呢？ 

795
00:36:55,289 --> 00:36:57,389
好吧，如果我还有另外两个变量， 

796
00:36:57,389 --> 00:37:00,170
例如汽车和便携式汽车，它们都是汽车类型

797
00:37:00,170 --> 00:37:03,480
然后输入PortableThing，然后我可以说， 

798
00:37:03,480 --> 00:37:06,110
 m等于汽车或m等于便携式。 

799
00:37:06,110 --> 00:37:07,039
我怎么这么说

800
00:37:07,239 --> 00:37:10,449
因为汽车是动车， 

801
00:37:10,449 --> 00:37:12,779
它实现了可移动协议。 

802
00:37:12,780 --> 00:37:16,820
实际上，汽车实现了Vehicle，Vehicle继承了Moveable， 

803
00:37:16,820 --> 00:37:19,130
因此汽车是可移动的。 

804
00:37:19,130 --> 00:37:22,210
这很棒，因为现在我有了这个变量m， 

805
00:37:22,210 --> 00:37:25,936
我可以开始发送它的功能，例如移动， 

806
00:37:25,936 --> 00:37:29,269
已经移动，因为我知道m是可移动的。 

807
00:37:29,269 --> 00:37:32,009
不管是那里的汽车还是PortableThing， 

808
00:37:32,010 --> 00:37:33,820
我们知道那些变量和函数

809
00:37:33,820 --> 00:37:35,809
将被实施，因为您需要

810
00:37:35,809 --> 00:37:39,340
如果您说自己是其中之一，就实施它们。 

811
00:37:39,340 --> 00:37:41,420
但是要注意一点， 

812
00:37:41,420 --> 00:37:45,559
你不能说便携式等于汽车。 

813
00:37:45,559 --> 00:37:49,269
那里的var便携式设备不是Moveable类型， 

814
00:37:49,269 --> 00:37:52,900
它是PortableThing类型，不同。 

815
00:37:52,900 --> 00:37:56,460
因此，汽车不是PortablePorting。 

816
00:37:56,659 --> 00:37:59,949
它们都是可移动的，但是汽车是不同的类型

817
00:37:59,949 --> 00:38:00,879
而不是PortableThing。 

818
00:38:00,880 --> 00:38:03,829
我认为汽车是一门课程，PortableThing是一种结构。 

819
00:38:03,829 --> 00:38:06,159
因此，甚至没有同样的事情。 

820
00:38:06,159 --> 00:38:07,969
所以你不能这么说。 

821
00:38:07,969 --> 00:38:09,980
我可以说m等于所有这些东西， 

822
00:38:09,980 --> 00:38:11,539
我不能说他们彼此平等

823
00:38:11,539 --> 00:38:14,719
因为Swift正在执行var的类型， 

824
00:38:14,719 --> 00:38:16,299
然后当我说便携式等于

825
00:38:16,300 --> 00:38:18,420
变量的类型是PortableThing， 

826
00:38:18,619 --> 00:38:20,762
不要在此处输入“可移动”。 

827
00:38:22,110 --> 00:38:24,320
一种考虑协议的方式， 

828
00:38:24,320 --> 00:38:26,900
我已经在演示中提到了这一点， 

829
00:38:27,099 --> 00:38:30,529
是制约和收获。 

830
00:38:30,530 --> 00:38:34,630
我用它是因为它押韵，所以希望容易记住， 

831
00:38:34,829 --> 00:38:37,130
它是这样的。 

832
00:38:37,130 --> 00:38:41,269
所以我在这里有这个结构，特斯拉，这是一辆车， 

833
00:38:41,469 --> 00:38:43,139
因此它实现了所有这些东西。 

834
00:38:43,139 --> 00:38:44,799
实际上，它受到限制

835
00:38:44,800 --> 00:38:47,320
实施车辆中的所有事物

836
00:38:47,320 --> 00:38:49,610
其中包括“可移动”中的所有内容， 

837
00:38:49,610 --> 00:38:53,820
但是受到限制会再次发生

838
00:38:53,820 --> 00:38:58,360
世界为车辆提供的所有东西。 

839
00:38:58,360 --> 00:39:01,673
现在，您可能会说，嗯，在这里稍等片刻， 

840
00:39:01,673 --> 00:39:05,269
车辆是协议，没有实现。 

841
00:39:05,269 --> 00:39:08,092
我们怎么可能在这里获得任何收益？ 

842
00:39:09,139 --> 00:39:12,839
似乎我在这里遇到了所有限制，但没有收获。 

843
00:39:12,840 --> 00:39:17,460
好吧，关键在于关键字扩展。 

844
00:39:17,659 --> 00:39:22,659
在Swift中，我们可以扩展协议以实现。 

845
00:39:23,869 --> 00:39:26,900
我们只说扩展名，协议名称， 

846
00:39:26,900 --> 00:39:28,300
然后我们可以放函数

847
00:39:28,300 --> 00:39:31,750
带有实现函数的vars中的实现函数。 

848
00:39:31,750 --> 00:39:34,920
现在我们不能在这里存储任何变量了。 

849
00:39:34,920 --> 00:39:38,170
因此有一个限制，它必须是计算的vars， 

850
00:39:38,170 --> 00:39:39,927
就像var body是经过计算的，请记住， 

851
00:39:39,927 --> 00:39:43,000
它在同一件事之后有花括号， 

852
00:39:43,000 --> 00:39:46,440
但是我们可以添加任意数量的东西。 

853
00:39:46,440 --> 00:39:49,170
随着车辆登记簿的扩展，DMV 

854
00:39:49,170 --> 00:39:51,639
现在是特斯拉和所有其他车辆

855
00:39:51,639 --> 00:39:53,269
可以在DMV中注册。 

856
00:39:53,269 --> 00:39:55,619
换句话说，他们获得了这种能力

857
00:39:55,619 --> 00:39:57,969
忍受他们所受的束缚

858
00:39:57,969 --> 00:40:00,039
实现那些方法和变量

859
00:40:00,039 --> 00:40:01,623
在那些协议中。 

860
00:40:02,730 --> 00:40:05,179
是的，这真的是中心

861
00:40:05,179 --> 00:40:07,889
 Swift中的函数式编程。 

862
00:40:07,889 --> 00:40:10,949
协议视图可能是

863
00:40:10,949 --> 00:40:13,379
这样做的发帖者。 

864
00:40:13,380 --> 00:40:14,960
我们将看到更多关于View的信息

865
00:40:15,159 --> 00:40:16,509
在这里有几张幻灯片。 

866
00:40:17,690 --> 00:40:20,210
除了添加功能之外， 

867
00:40:20,210 --> 00:40:23,481
像registerWithDMV一样，您也可以使用扩展名

868
00:40:23,681 --> 00:40:28,681
如果要添加默认实现，请选择协议。 

869
00:40:28,710 --> 00:40:30,389
所以我在这里扩展Moveable 

870
00:40:30,389 --> 00:40:33,059
我实际上是提供默认的实现

871
00:40:33,059 --> 00:40:36,369
 for hasMoved as hasMoved是变量之一

872
00:40:36,369 --> 00:40:37,719
在协议中

873
00:40:37,719 --> 00:40:39,809
但是我在这里提供了默认的实现。 

874
00:40:39,809 --> 00:40:42,380
我只是在看我的距离

875
00:40:42,380 --> 00:40:43,800
如果大于零， 

876
00:40:43,800 --> 00:40:45,697
我假设我已经搬家了。 

877
00:40:45,697 --> 00:40:49,550
而我正在通过对Moveable进行扩展。 

878
00:40:49,550 --> 00:40:52,550
因此，这使我有可能拥有一个结构， 

879
00:40:52,550 --> 00:40:55,260
我这里有一个叫ChessPiece的棋子，它是可移动的， 

880
00:40:55,260 --> 00:40:57,070
您可以移动棋子。 

881
00:40:57,070 --> 00:41:00,440
 ChessPiece不需要实现hasMoved。 

882
00:41:00,639 --> 00:41:03,210
如果ChessPiece只是实现moveBy 

883
00:41:03,210 --> 00:41:04,750
和distanceFromStart， 

884
00:41:04,750 --> 00:41:07,349
那么它将成功实现Moveable 

885
00:41:07,349 --> 00:41:10,610
因为它将采用默认实现

886
00:41:10,610 --> 00:41:12,500
从那扩展名那里。 

887
00:41:12,699 --> 00:41:15,909
现在，如果ChessPiece想要自己实现hasMoved， 

888
00:41:15,909 --> 00:41:18,129
可以，但是不必

889
00:41:18,130 --> 00:41:20,250
因为有一个默认的实现

890
00:41:20,250 --> 00:41:22,512
对于该扩展中的hasMoved。 

891
00:41:23,639 --> 00:41:25,690
现在，您当然可以使用扩展程序了， 

892
00:41:25,690 --> 00:41:28,019
还要向结构和类中添加代码， 

893
00:41:28,219 --> 00:41:30,619
不只是协议。 

894
00:41:30,619 --> 00:41:34,299
例如，在这里，我有一个名为Boat的结构

895
00:41:34,300 --> 00:41:37,400
它有自己的方法，无论它们是什么。 

896
00:41:37,400 --> 00:41:40,329
在这里，我将扩展添加到Boat中， 

897
00:41:40,329 --> 00:41:42,650
一个功能sailAroundTheWorld。 

898
00:41:42,650 --> 00:41:46,099
您可以看到，该扩展名带有花括号， 

899
00:41:46,099 --> 00:41:47,329
它有一个实现。 

900
00:41:47,329 --> 00:41:50,559
这是sailAroundTheWorld的实际实现

901
00:41:50,559 --> 00:41:52,232
我们已经添加到Boat中

902
00:41:53,409 --> 00:41:58,129
您甚至可以制作类似Boat的产品

903
00:41:58,130 --> 00:42:01,019
完全通过使用您的扩展协议。 

904
00:42:01,219 --> 00:42:04,609
所以Boat现在不执行任何协议

905
00:42:04,610 --> 00:42:07,130
但我可以使Boat工具可移动

906
00:42:07,130 --> 00:42:09,269
通过扩展到Boat 

907
00:42:09,469 --> 00:42:13,059
表示冒号Moveable，然后在该扩展名中， 

908
00:42:13,059 --> 00:42:16,070
实现moveBy和distanceFromStart。 

909
00:42:16,070 --> 00:42:18,400
现在船是可移动的。 

910
00:42:18,599 --> 00:42:20,732
我将其全部添加为扩展名。 

911
00:42:22,043 --> 00:42:23,750
这不是一件罕见的事

912
00:42:23,750 --> 00:42:27,309
采取结构或类别并使其符合标准

913
00:42:27,309 --> 00:42:30,029
纯粹使用扩展的协议

914
00:42:30,030 --> 00:42:31,830
或者您将代码添加到扩展程序中。 

915
00:42:33,880 --> 00:42:37,099
为什么我们要做所有这些协议呢？ 

916
00:42:37,099 --> 00:42:38,769
现在，对于那些即将到来的人

917
00:42:38,769 --> 00:42:40,420
来自面向对象的编程

918
00:42:40,420 --> 00:42:42,230
看起来就像是，这是怎么回事？ 

919
00:42:42,230 --> 00:42:43,440
我们为什么要做这个？ 

920
00:42:43,440 --> 00:42:45,940
嗯，有一个非常好的概念上的原因

921
00:42:45,940 --> 00:42:47,780
为什么我们要这样做。 

922
00:42:47,780 --> 00:42:51,000
协议不包含类型，结构和类， 

923
00:42:51,199 --> 00:42:55,449
其他我们没有讨论过的协议，甚至枚举， 

924
00:42:55,449 --> 00:42:58,139
说出他们的能力， 

925
00:42:58,139 --> 00:43:02,480
他们可以做什么功能，他们有什么变量， 

926
00:43:02,480 --> 00:43:04,440
这也是其他代码的一种方式

927
00:43:04,440 --> 00:43:07,800
要求其他物体的某些行为

928
00:43:07,800 --> 00:43:10,530
通过要求他们遵守协议， 

929
00:43:10,530 --> 00:43:12,860
通过具有该类型的变量

930
00:43:12,860 --> 00:43:16,190
他们正在尝试为函数分配或参数化。 

931
00:43:16,190 --> 00:43:18,869
您甚至还会看到其他机制

932
00:43:18,869 --> 00:43:21,329
当我们谈论泛型和协议时

933
00:43:21,329 --> 00:43:24,340
要求您希望该东西是可移动的。 

934
00:43:24,340 --> 00:43:25,940
无论如何，它必须是一辆载具。 

935
00:43:26,139 --> 00:43:29,839
现在，有了此协议，就可以要求它了。 

936
00:43:29,840 --> 00:43:33,320
但在所有这些方面，双方都不必透露

937
00:43:33,320 --> 00:43:35,820
您是哪种结构类。 

938
00:43:35,820 --> 00:43:38,340
您完全可以随心所欲。 

939
00:43:38,340 --> 00:43:40,539
你只是说你实现了Moveable 

940
00:43:40,539 --> 00:43:43,360
现在您可以将其作为可移动设备进行操作， 

941
00:43:43,360 --> 00:43:44,250
但你可以是任何人。 

942
00:43:44,449 --> 00:43:46,369
您可能是汽车，也可能是PortableThing。 

943
00:43:46,369 --> 00:43:47,813
你可能是一条船。 

944
00:43:48,949 --> 00:43:51,349
我们知道什么时候双方都不在乎。 

945
00:43:51,349 --> 00:43:54,019
一方面，您可以做可移动的事情

946
00:43:54,019 --> 00:43:55,449
而所有其他副作用是

947
00:43:55,449 --> 00:43:58,282
它实现了所有那些可移动的东西。 

948
00:43:59,590 --> 00:44:01,690
这就是函数式编程

949
00:44:01,690 --> 00:44:05,349
或实际上我们可以称之为面向协议的编程， 

950
00:44:05,349 --> 00:44:06,500
关于一切。 

951
00:44:06,500 --> 00:44:09,219
这是关于规范数据结构的方式

952
00:44:09,219 --> 00:44:12,969
在我们的应用程序功能中，它们的行为方式。 

953
00:44:12,969 --> 00:44:16,179
即使我们在协议的上下文中谈论var， 

954
00:44:16,179 --> 00:44:19,250
我们没有定义它们的存储或计算方式， 

955
00:44:19,250 --> 00:44:21,539
我们甚至不说它们的存储或计算位置， 

956
00:44:21,539 --> 00:44:24,179
我们只是在谈论它们是只读还是读，写。 

957
00:44:24,179 --> 00:44:27,980
通过所有这些，我们专注于功能。 

958
00:44:27,980 --> 00:44:30,409
我们隐藏了实现细节。 

959
00:44:30,409 --> 00:44:32,539
这是最终的承诺

960
00:44:32,539 --> 00:44:35,269
面向对象程序设计的封装

961
00:44:35,269 --> 00:44:37,170
但这确实是一个更高的层次

962
00:44:37,170 --> 00:44:39,849
因为它不会无情地混合它

963
00:44:39,849 --> 00:44:41,132
有了数据和所有这些， 

964
00:44:41,132 --> 00:44:44,532
只是在谈论功能。 

965
00:44:45,820 --> 00:44:49,059
所有这些都变得更加强大

966
00:44:49,059 --> 00:44:51,802
当我们将其与泛型结合使用时。 

967
00:44:52,730 --> 00:44:55,929
协议加上泛型等于

968
00:44:55,929 --> 00:44:58,690
正如我在这里所说的，超级大国。 

969
00:44:58,690 --> 00:45:01,309
让我们来看看泛型

970
00:45:01,309 --> 00:45:03,500
记住那是无关紧要的东西

971
00:45:03,500 --> 00:45:05,090
我们上次谈到的

972
00:45:05,090 --> 00:45:08,760
它如何与协议结合以产生超能力。 

973
00:45:08,760 --> 00:45:09,690
开始了。 

974
00:45:09,889 --> 00:45:11,400
让我们以示例方式进行操作。 

975
00:45:11,400 --> 00:45:14,519
假设我有一个名为Greatness的协议， 

976
00:45:14,719 --> 00:45:16,809
这个协议里面只有一个功能

977
00:45:16,809 --> 00:45:19,362
就是比其他大。 

978
00:45:20,369 --> 00:45:23,099
此函数的另一个参数是GreaterThan。 

979
00:45:23,099 --> 00:45:25,190
顺便说一句，这是一个有趣的功能

980
00:45:25,190 --> 00:45:29,980
因为其他类型是大写S Self。 

981
00:45:30,840 --> 00:45:34,320
这是协议中一种特殊的类型名称

982
00:45:34,320 --> 00:45:35,980
表示实际类型

983
00:45:36,179 --> 00:45:38,129
正在实施该协议， 

984
00:45:38,130 --> 00:45:40,039
因为请记住，协议本身

985
00:45:40,239 --> 00:45:42,259
没有实现，他们就实现了

986
00:45:42,260 --> 00:45:43,730
通过结构和类。 

987
00:45:43,929 --> 00:45:46,429
因此，Self表示实际的结构类

988
00:45:46,429 --> 00:45:50,909
实现了这一点，当时正在执行它。 

989
00:45:50,909 --> 00:45:51,742
所以这很酷。 

990
00:45:51,742 --> 00:45:52,576
我要告诉你它是如何工作的

991
00:45:52,576 --> 00:45:54,762
只需点击几下。 

992
00:45:55,769 --> 00:45:59,349
因此，如果我们有此协议，请看我们能做什么。 

993
00:45:59,349 --> 00:46:03,679
扩展数组，所以我要在数组中添加一些内容， 

994
00:46:03,679 --> 00:46:08,679
元素不在乎Array， 

995
00:46:08,750 --> 00:46:12,860
符合伟大，冒号伟大。 

996
00:46:12,860 --> 00:46:14,750
这样我放在红色的地方

997
00:46:14,949 --> 00:46:17,239
因为这真的是关键

998
00:46:17,239 --> 00:46:19,639
泛型和协议的连接。 

999
00:46:19,639 --> 00:46:22,460
在这里，我实际上要添加一个变量， 

1000
00:46:22,460 --> 00:46:23,760
或者我可以通过功能来做到这一点

1001
00:46:23,760 --> 00:46:25,510
但是我要在这里添加一个变量

1002
00:46:25,510 --> 00:46:29,630
数组，以便每个数组元素所在的位置， 

1003
00:46:29,630 --> 00:46:33,133
不在乎，符合Greatness会得到此var。 

1004
00:46:34,460 --> 00:46:36,090
让它沉入。 

1005
00:46:36,090 --> 00:46:39,039
现在，此变量将不存在于数组中

1006
00:46:39,239 --> 00:46:42,479
不在乎的地方

1007
00:46:42,480 --> 00:46:43,539
协议伟大。 

1008
00:46:43,539 --> 00:46:45,340
该变量只是不会存在。 

1009
00:46:45,340 --> 00:46:46,900
如果您尝试在代码中键入它， 

1010
00:46:47,099 --> 00:46:48,079
编译器会说， 

1011
00:46:48,079 --> 00:46:51,239
这个数组没有实现最大

1012
00:46:51,239 --> 00:46:52,809
它只会说它实现了最大

1013
00:46:52,809 --> 00:46:56,130
只允许您正确输入

1014
00:46:56,130 --> 00:46:57,630
如果它是某物的数组

1015
00:46:57,630 --> 00:46:59,510
实现了协议Greatness 

1016
00:46:59,510 --> 00:47:03,833
现在我喜欢这样称呼，我们有点关心。 

1017
00:47:05,000 --> 00:47:07,969
通常我们称泛型不在乎， 

1018
00:47:07,969 --> 00:47:09,699
元素是不在乎， 

1019
00:47:09,699 --> 00:47:12,319
数组不在乎其中的内容。 

1020
00:47:12,320 --> 00:47:14,039
好吧，这有点

1021
00:47:14,039 --> 00:47:17,800
这个对Array的扩展有点关心元素。 

1022
00:47:17,800 --> 00:47:19,420
真的不在乎什么元素

1023
00:47:19,420 --> 00:47:22,840
可以是任何结构或类，但我们会注意

1024
00:47:22,840 --> 00:47:24,309
它实现了伟大。 

1025
00:47:24,309 --> 00:47:26,210
所以这有点关怀， 

1026
00:47:26,210 --> 00:47:28,070
你想那样想。 

1027
00:47:28,070 --> 00:47:33,070
然后，这个无穷大，看看它的类型是什么，元素。 

1028
00:47:33,119 --> 00:47:35,210
不在乎，因为我要看

1029
00:47:35,210 --> 00:47:37,869
通过数组找到最伟大的那个

1030
00:47:37,869 --> 00:47:40,509
通过调用isGreatThan 

1031
00:47:40,510 --> 00:47:41,670
在数组中的所有事物上

1032
00:47:41,869 --> 00:47:45,069
我知道我可以做，因为这个对Array的扩展

1033
00:47:45,070 --> 00:47:48,750
只是元素实现伟大的地方。 

1034
00:47:48,750 --> 00:47:50,750
在这里看到一切如何？ 

1035
00:47:50,750 --> 00:47:52,940
您可以轻松想象，我不会在这里显示代码， 

1036
00:47:52,940 --> 00:47:55,112
但您可以轻松想象构建一个for循环

1037
00:47:55,112 --> 00:47:57,049
只是涉及所有要素， 

1038
00:47:57,050 --> 00:47:58,710
通话比所有通话都好， 

1039
00:47:58,710 --> 00:48:00,820
找出哪一个是最大的

1040
00:48:00,820 --> 00:48:02,170
那只是返回它。 

1041
00:48:03,469 --> 00:48:07,439
因此，让我们看看如何使用这样的数组。 

1042
00:48:07,440 --> 00:48:10,280
假设我使用另一个扩展

1043
00:48:10,280 --> 00:48:12,039
使Int类型为Int 

1044
00:48:12,239 --> 00:48:14,719
这是一个结构，实现伟大。 

1045
00:48:14,719 --> 00:48:16,589
没问题，这很容易

1046
00:48:16,590 --> 00:48:19,420
实现一个比其他更好的Int， 

1047
00:48:19,420 --> 00:48:22,050
只是我自己比其他Int伟大， 

1048
00:48:22,050 --> 00:48:23,300
您可以使用大于

1049
00:48:23,300 --> 00:48:26,030
看看某物是否大于某物。 

1050
00:48:26,030 --> 00:48:28,150
但是想象一下我有完全不同的类型。 

1051
00:48:28,150 --> 00:48:31,039
这是总统的延伸。 

1052
00:48:31,039 --> 00:48:33,059
那是美国总统。 

1053
00:48:33,059 --> 00:48:34,710
我要让它实现伟大， 

1054
00:48:34,710 --> 00:48:36,992
 func比其他总统大。 

1055
00:48:38,090 --> 00:48:39,059
我要实施... 

1056
00:48:39,059 --> 00:48:40,650
其实我有唐纳德·特朗普， 

1057
00:48:40,650 --> 00:48:44,210
来宾iOS程序员来实现这一点。 

1058
00:48:44,409 --> 00:48:46,644
他说那比

1059
00:48:46,644 --> 00:48:48,650
只是self.name等于Trump。 

1060
00:48:48,650 --> 00:48:51,800
如果是这样，那当然是大于， 

1061
00:48:51,800 --> 00:48:54,269
他是一位出色的iOS程序员，每个人都告诉我， 

1062
00:48:54,469 --> 00:48:56,039
我到处都听到。 

1063
00:48:56,039 --> 00:48:57,889
所以我们开始，我们得到了。 

1064
00:48:57,889 --> 00:48:59,779
现在，我想指出的一件事

1065
00:48:59,780 --> 00:49:03,010
关于您看到的这张幻灯片

1066
00:49:03,010 --> 00:49:04,800
这里是紫色的东西。 

1067
00:49:04,800 --> 00:49:08,190
还记得顶部的“其他自我”吗？ 

1068
00:49:08,190 --> 00:49:09,860
还记得资本S Self吗？ 

1069
00:49:09,860 --> 00:49:12,500
看一下，当我创建这些扩展后， 

1070
00:49:12,699 --> 00:49:16,039
自我变成了我要延伸的类型

1071
00:49:16,039 --> 00:49:19,820
我正在实现该协议的类型。 

1072
00:49:19,820 --> 00:49:21,809
希望可以帮助您了解自我。 

1073
00:49:21,809 --> 00:49:24,079
我提出这一点是因为有很多协议

1074
00:49:24,079 --> 00:49:27,639
在Swift UI中执行此操作的地方

1075
00:49:27,639 --> 00:49:30,429
或其中一种类型的功能

1076
00:49:30,429 --> 00:49:32,879
论据的关键是实现这一点。 

1077
00:49:32,880 --> 00:49:35,123
因此，这并不少见。 

1078
00:49:36,010 --> 00:49:38,110
所以现在我有诚信和总裁。 

1079
00:49:38,309 --> 00:49:41,750
他们都实现了这个协议，伟大。 

1080
00:49:41,750 --> 00:49:44,730
因此，我应该能够在它们上调用该Array var。 

1081
00:49:44,730 --> 00:49:46,900
我应该可以使用Array var 

1082
00:49:46,900 --> 00:49:50,059
我在那定义的最大，最大的东西。 

1083
00:49:50,059 --> 00:49:52,329
因此，让我们看一下Int的外观。 

1084
00:49:52,329 --> 00:49:54,409
所以对于Int，假设我有一个numbersArray 

1085
00:49:54,409 --> 00:49:56,889
它是类型的Int数组。 

1086
00:49:56,889 --> 00:50:00,629
我将在这里将其设置为等于常数Array， 

1087
00:50:00,630 --> 00:50:02,070
我们在演示中看到了。 

1088
00:50:02,070 --> 00:50:03,190
我们是用表情符号来做的。 

1089
00:50:03,190 --> 00:50:05,659
在这里，我正在处理数字3、7和42 

1090
00:50:05,659 --> 00:50:07,739
所以这只是一个数组，现在我可以说， 

1091
00:50:07,739 --> 00:50:10,639
让foo等于numbersArray.greatest。 

1092
00:50:10,639 --> 00:50:15,019
编译和工作是因为Int是

1093
00:50:15,019 --> 00:50:17,289
该Array和Int实现的内容

1094
00:50:17,289 --> 00:50:21,059
伟大的协议，所以最大的变种

1095
00:50:21,059 --> 00:50:22,086
因此被定义。 

1096
00:50:22,086 --> 00:50:25,880
因此foo将是42，因为我们确实实现了它

1097
00:50:25,880 --> 00:50:26,750
只说更大一点。 

1098
00:50:26,949 --> 00:50:28,750
我可以做完全一样的事情

1099
00:50:28,750 --> 00:50:30,050
如果我在这个数组中有一个总裁。 

1100
00:50:30,050 --> 00:50:32,440
假设可以创建struct President 

1101
00:50:32,440 --> 00:50:33,539
以总统的名字。 

1102
00:50:33,539 --> 00:50:35,742
因此，我在这里创建了一系列总裁。 

1103
00:50:35,742 --> 00:50:37,449
现在，我要说让foo等于

1104
00:50:37,449 --> 00:50:40,219
 PresidentsArray.greatest。 

1105
00:50:40,219 --> 00:50:42,047
那会把我还给我

1106
00:50:42,047 --> 00:50:43,909
或名字叫Trump的foo， 

1107
00:50:43,909 --> 00:50:47,779
当然，基于他在此处编写的代码。 

1108
00:50:47,780 --> 00:50:50,000
所以希望这能使您清楚

1109
00:50:50,199 --> 00:50:53,329
我们如何一起使用泛型和协议。 

1110
00:50:53,329 --> 00:50:56,190
我们将在SwiftUI的所有位置进行此操作。 

1111
00:50:58,170 --> 00:50:59,590
你们当中有些人正在看这一切， 

1112
00:50:59,590 --> 00:51:02,913
就像我在这里所说的，我确定您正在发抖。 

1113
00:51:03,969 --> 00:51:06,039
你必须要思考，圣牛， 

1114
00:51:06,039 --> 00:51:08,409
我应该怎么知道

1115
00:51:08,409 --> 00:51:11,929
如何使用这项技术设计代码？ 

1116
00:51:11,929 --> 00:51:14,219
我的意思是，这对我来说是全新的。 

1117
00:51:14,219 --> 00:51:18,079
这确实是一个非常强大的基础

1118
00:51:18,079 --> 00:51:20,659
对于设计事物，功能非常强大。 

1119
00:51:20,659 --> 00:51:23,759
但是函数式编程确实需要一定的掌握

1120
00:51:23,760 --> 00:51:27,289
那只有经验。 

1121
00:51:27,489 --> 00:51:30,259
好消息是您可以做很多事情

1122
00:51:30,260 --> 00:51:31,980
在SwiftUI中，大多数事情

1123
00:51:32,179 --> 00:51:35,549
无需真正掌握功能编程。 

1124
00:51:35,550 --> 00:51:38,289
但是在这里，您正在斯坦福大学努力接受良好的教育。 

1125
00:51:38,489 --> 00:51:41,559
所以我现在向你解释的原因

1126
00:51:41,559 --> 00:51:44,320
以便您在SwiftUI中使用它的次数增加， 

1127
00:51:44,320 --> 00:51:46,289
您在文档中看到的越多

1128
00:51:46,289 --> 00:51:49,019
您看到这些商品在发生， 

1129
00:51:49,019 --> 00:51:50,759
我们看到像View这样的协议

1130
00:51:50,760 --> 00:51:53,000
并且可以确定的是， 

1131
00:51:53,199 --> 00:51:56,159
你不只是在说，我必须在这里放冒号， 

1132
00:51:56,159 --> 00:51:57,539
你实际上是在理解

1133
00:51:57,539 --> 00:51:59,599
它是如何设计的。 

1134
00:51:59,599 --> 00:52:01,896
而且您看到的越多，它就会越陷进去

1135
00:52:01,896 --> 00:52:04,929
最终您可能会开始变得更有能力

1136
00:52:04,929 --> 00:52:07,772
同时进行功能编程设计。 

1137
00:52:08,780 --> 00:52:10,733
但是现在没有人期望你

1138
00:52:10,733 --> 00:52:13,190
能够设计东西

1139
00:52:13,190 --> 00:52:15,179
在其中添加协议扩展的地方

1140
00:52:15,179 --> 00:52:16,859
与泛型和所有。 

1141
00:52:16,860 --> 00:52:18,670
但是最终您将能够。 

1142
00:52:18,869 --> 00:52:20,829
同时，您会知道

1143
00:52:20,829 --> 00:52:22,319
 SwiftUI中发生了什么。 

1144
00:52:25,289 --> 00:52:28,230
所以我只是把这张幻灯片放在这里，关于枚举， 

1145
00:52:28,230 --> 00:52:33,230
但是再一次，在本讲座中，我们将不再讨论枚举。 

1146
00:52:33,880 --> 00:52:36,492
我们会尽快谈论，不用担心。 

1147
00:52:37,440 --> 00:52:40,320
所以这几乎涵盖了我们要做的事情

1148
00:52:40,320 --> 00:52:42,269
今天谈论建筑

1149
00:52:42,469 --> 00:52:46,209
我们几乎涵盖了整个主题。 

1150
00:52:46,210 --> 00:52:48,119
现在我要完全换档

1151
00:52:48,119 --> 00:52:52,409
然后转到一个完全不同的主题，即布局， 

1152
00:52:52,409 --> 00:52:54,369
换句话说，我们如何决定

1153
00:52:54,369 --> 00:52:57,259
屏幕上所有视图的位置？ 

1154
00:52:57,260 --> 00:53:00,840
 SwiftUI做到这一点的方法非常简单。 

1155
00:53:01,039 --> 00:53:04,400
这是所有SwiftUI中最精美的东西之一。 

1156
00:53:04,400 --> 00:53:07,230
确实只有三个步骤。 

1157
00:53:07,230 --> 00:53:10,360
第一个是容器Views， 

1158
00:53:10,360 --> 00:53:13,420
例如HStacks和VStacks之类的东西。 

1159
00:53:13,420 --> 00:53:17,480
它们为内部的视图提供了空间。 

1160
00:53:17,480 --> 00:53:21,130
然后，这些视图自行选择尺寸， 

1161
00:53:21,130 --> 00:53:22,480
他们想要成为什么。 

1162
00:53:22,679 --> 00:53:23,929
根据该报价， 

1163
00:53:23,929 --> 00:53:26,119
他们可以选择与报价相同的尺寸， 

1164
00:53:26,119 --> 00:53:27,339
这是最常见的

1165
00:53:27,340 --> 00:53:29,480
他们可以选择比报价要小的尺寸， 

1166
00:53:29,480 --> 00:53:32,742
他们可以选择比报价更大的尺寸。 

1167
00:53:32,742 --> 00:53:35,739
因此，它们以一种很好的封装方式使用

1168
00:53:35,739 --> 00:53:38,609
视图决定了它们的大小。 

1169
00:53:38,610 --> 00:53:40,210
没有人告诉他们要多大。 

1170
00:53:40,210 --> 00:53:42,829
他们决定，我们只是为他们提供空间。 

1171
00:53:42,829 --> 00:53:46,909
但是之后，容器Views就像堆栈一样， 

1172
00:53:46,909 --> 00:53:50,559
将视图放置在自己的内部是他们的工作。 

1173
00:53:50,559 --> 00:53:52,969
就是这样，这是三个步骤

1174
00:53:52,969 --> 00:53:56,669
以便将所有内容布置在SwiftUI中。 

1175
00:53:56,670 --> 00:53:58,030
因此，让我们深入了解一下。 

1176
00:53:58,030 --> 00:54:00,690
让我们谈谈容器视图。 

1177
00:54:00,690 --> 00:54:02,480
所以最常见的容器视图

1178
00:54:02,480 --> 00:54:06,070
您已经熟悉的是HStack和VStack。 

1179
00:54:06,070 --> 00:54:08,103
当然，还有Zstack 

1180
00:54:08,302 --> 00:54:10,619
这种堆叠在一起

1181
00:54:10,619 --> 00:54:13,079
但是HStack和VStack很有趣

1182
00:54:13,079 --> 00:54:16,429
因为他们将提供给他们的空间分开了

1183
00:54:16,429 --> 00:54:18,219
在所有子视图中

1184
00:54:18,219 --> 00:54:20,809
稍后我们将讨论其工作原理。 

1185
00:54:20,809 --> 00:54:25,009
 ForEach是一种不寻常的容器视图。 

1186
00:54:25,010 --> 00:54:28,840
它实际上推迟了定位

1187
00:54:28,840 --> 00:54:31,289
并调整其所在容器的尺寸， 

1188
00:54:31,489 --> 00:54:33,349
这就是为什么我们把CardViews 

1189
00:54:33,349 --> 00:54:35,719
将ForEach放入HStack中。 

1190
00:54:35,719 --> 00:54:39,719
因此，他们的ForEach正在推迟让HStack做出决定。 

1191
00:54:39,719 --> 00:54:44,349
布局中隐藏着的一件事是修饰符， 

1192
00:54:44,349 --> 00:54:46,739
例如点填充和其他。 

1193
00:54:46,739 --> 00:54:50,549
它们本质上包含它们修改的视图， 

1194
00:54:50,550 --> 00:54:51,880
如果你想这样想， 

1195
00:54:51,880 --> 00:54:55,090
其中一些元素（例如填充）进行布局。 

1196
00:54:55,090 --> 00:54:56,730
所以让我们再详细一点

1197
00:54:56,929 --> 00:55:00,339
关于HStack和VStack，最重要的一个

1198
00:55:00,340 --> 00:55:02,940
或至少是布局最多的一个。 

1199
00:55:03,139 --> 00:55:05,440
堆栈划分空间的方式

1200
00:55:05,440 --> 00:55:08,789
提供给他们的情况是平均分配的

1201
00:55:08,789 --> 00:55:13,400
然后他们首先将其提供给最不灵活的视图。 

1202
00:55:13,400 --> 00:55:15,119
那是什么意思呢？ 

1203
00:55:15,119 --> 00:55:20,119
因此，非常灵活的视图就是图像。 

1204
00:55:20,769 --> 00:55:22,969
所以我们还没有谈论图像

1205
00:55:22,969 --> 00:55:24,639
但这只是一个显示图像的视图， 

1206
00:55:24,639 --> 00:55:25,769
如您所想。 

1207
00:55:25,769 --> 00:55:28,639
当然，它希望是图像的大小， 

1208
00:55:28,639 --> 00:55:30,779
那种方式很不灵活。 

1209
00:55:30,780 --> 00:55:32,710
所以通常图像会得到

1210
00:55:32,710 --> 00:55:34,710
他们首先要的空间。 

1211
00:55:34,710 --> 00:55:37,559
另一个非常僵化的视图示例

1212
00:55:37,559 --> 00:55:40,750
文字不像图像那么僵化。 

1213
00:55:40,750 --> 00:55:42,849
文字总是想自行调整大小

1214
00:55:42,849 --> 00:55:46,289
使其内部的文本可以理解

1215
00:55:46,289 --> 00:55:48,829
但是它确实可以缩小一点

1216
00:55:48,829 --> 00:55:50,840
并在文本末尾加点号

1217
00:55:50,840 --> 00:55:52,880
正如我们稍后将在这里讨论的那样。 

1218
00:55:52,880 --> 00:55:56,539
因此，它不像图像那么灵活。 

1219
00:55:56,539 --> 00:55:59,059
而且大多数视图都非常灵活。 

1220
00:55:59,059 --> 00:56:00,570
例如，所有形状

1221
00:56:00,570 --> 00:56:02,980
就像我们看到的RoundedRectangle 

1222
00:56:02,980 --> 00:56:05,670
无论您提供什么尺寸，它都差不多

1223
00:56:05,670 --> 00:56:09,190
并且它将以该大小适当地绘制自身。 

1224
00:56:09,190 --> 00:56:13,349
因此，在其中一种视图选择了自己的尺寸之后

1225
00:56:13,349 --> 00:56:14,960
并采用所需的尺寸， 

1226
00:56:14,960 --> 00:56:18,260
从空间中删除了那个大小

1227
00:56:18,260 --> 00:56:20,090
堆栈正在尝试分配

1228
00:56:20,289 --> 00:56:24,360
然后进入下一个最不灵活的视图

1229
00:56:24,360 --> 00:56:26,432
冲洗并重复直到所有空间用完。 

1230
00:56:26,632 --> 00:56:28,089
就是这么简单。 

1231
00:56:28,090 --> 00:56:32,840
这就是HStack和VStack分配空间的方式。 

1232
00:56:32,840 --> 00:56:35,230
现在，在所有视图选择了它们的大小之后

1233
00:56:35,429 --> 00:56:40,069
然后HStack和VStack调整自身大小以适合这些视图

1234
00:56:40,070 --> 00:56:42,920
两者之间的间距很小。 

1235
00:56:44,000 --> 00:56:47,329
 HStack和VStack可以与任何View一起使用， 

1236
00:56:47,329 --> 00:56:48,269
但是有几个

1237
00:56:48,269 --> 00:56:50,219
我要在这里介绍给你

1238
00:56:50,219 --> 00:56:52,199
确实有助于布局。 

1239
00:56:52,199 --> 00:56:54,539
其中之一称为垫片。 

1240
00:56:54,539 --> 00:56:58,389
因此，Spacer只是一个占据所有空间的视图

1241
00:56:58,389 --> 00:56:59,639
提供给它。 

1242
00:56:59,639 --> 00:57:02,389
因此，如果您给它空间，它将使用该空间。 

1243
00:57:02,389 --> 00:57:04,609
因此，它用于填充空间。 

1244
00:57:04,610 --> 00:57:06,360
现在它实际上并没有画任何东西， 

1245
00:57:06,360 --> 00:57:09,820
只是浪费了HStack或VStack中的空间， 

1246
00:57:09,820 --> 00:57:11,539
这就是为什么它被称为垫片。 

1247
00:57:11,739 --> 00:57:14,029
它具有minLength参数

1248
00:57:14,030 --> 00:57:16,789
这是应该的最小尺寸

1249
00:57:16,989 --> 00:57:19,189
在我们水平布置的方向

1250
00:57:19,190 --> 00:57:22,329
还是垂直，具体取决于是HStack还是VStack， 

1251
00:57:22,329 --> 00:57:24,000
尽管我们通常不指定

1252
00:57:24,000 --> 00:57:26,820
因为默认值是正确的金额

1253
00:57:26,820 --> 00:57:28,750
在这个平台上的空间。 

1254
00:57:28,949 --> 00:57:30,389
你要开始的一件事

1255
00:57:30,389 --> 00:57:31,853
习惯了本季度的发展， 

1256
00:57:31,853 --> 00:57:35,039
即使我们专注于iOS， 

1257
00:57:35,039 --> 00:57:39,250
您可以在Apple Watch和Apple TV上使用SwiftUI 

1258
00:57:39,250 --> 00:57:42,449
间距和布局有些不同

1259
00:57:42,449 --> 00:57:43,759
在这些平台上。 

1260
00:57:43,760 --> 00:57:47,190
 SwiftUI真的很聪明地说： 

1261
00:57:47,389 --> 00:57:50,339
我在Apple Watch上，所以我要用这么多空间

1262
00:57:50,340 --> 00:57:52,300
默认情况下在我的垫片中。 

1263
00:57:52,300 --> 00:57:55,539
这就是为什么我们真正想要尝试使用这些默认值的原因

1264
00:57:55,539 --> 00:57:59,329
并且在使用Spacer时不指定minLength。 

1265
00:57:59,329 --> 00:58:01,605
 HStack本身也有间距

1266
00:58:01,605 --> 00:58:02,471
 HStack间距。 

1267
00:58:02,471 --> 00:58:03,469
而且我们不想那样做。 

1268
00:58:03,469 --> 00:58:06,789
即使是填充，通常也可以放填充

1269
00:58:06,789 --> 00:58:08,880
但是如果你开始把数字放在那里

1270
00:58:08,880 --> 00:58:12,349
并像我们看到的那样指定确切的填充， 

1271
00:58:12,349 --> 00:58:13,639
你在打败一点

1272
00:58:13,639 --> 00:58:15,670
此平台独立性的目的。 

1273
00:58:15,670 --> 00:58:18,000
现在，有时您需要它，您只需

1274
00:58:18,199 --> 00:58:21,739
但是我们尝试尽可能多地使用这些默认值。 

1275
00:58:21,739 --> 00:58:23,596
因此，另一个很酷的View可以放入HStack 

1276
00:58:23,597 --> 00:58:25,420
或VStack是Divider。 

1277
00:58:25,619 --> 00:58:28,269
所以分频器只是画一条分界线， 

1278
00:58:28,269 --> 00:58:29,679
同样，特定于平台

1279
00:58:29,679 --> 00:58:31,879
这取决于分隔线的外观

1280
00:58:31,880 --> 00:58:33,960
在它的上下文中。 

1281
00:58:33,960 --> 00:58:37,210
当然，分频器不像垫片

1282
00:58:37,210 --> 00:58:38,400
它不会占用所有的空间。 

1283
00:58:38,400 --> 00:58:41,519
它仅使用足够的空间来绘制该线。 

1284
00:58:41,519 --> 00:58:44,369
而且该线显然与方向相反

1285
00:58:44,369 --> 00:58:45,219
我们正在布局。 

1286
00:58:45,219 --> 00:58:47,980
因此，对于HStack来说，分频器显然是

1287
00:58:47,980 --> 00:58:49,440
垂直线，对于VStack， 

1288
00:58:49,440 --> 00:58:51,639
这将是一条水平线。 

1289
00:58:51,639 --> 00:58:54,989
所以您几乎肯定会想要使用一个

1290
00:58:54,989 --> 00:58:58,179
或在下一个作业中同时使用这两种方法。 

1291
00:58:58,179 --> 00:59:01,919
它们对于使用堆栈进行布局真的很有价值。 

1292
00:59:01,920 --> 00:59:03,250
这些HStack和VStack， 

1293
00:59:03,250 --> 00:59:05,809
我告诉过你他们是有选择的

1294
00:59:05,809 --> 00:59:10,809
它的哪些观点为下一个优先领域提供了空间

1295
00:59:11,349 --> 00:59:13,039
用这个最不灵活的东西， 

1296
00:59:13,039 --> 00:59:15,059
但实际上您可以覆盖

1297
00:59:15,059 --> 00:59:18,029
使用此视图修改器layoutPriority。 

1298
00:59:18,030 --> 00:59:20,480
这是一个HStack的例子

1299
00:59:20,480 --> 00:59:22,869
它的文本非常重要。 

1300
00:59:22,869 --> 00:59:26,349
它有一张我们知道非常不灵活的图片， 

1301
00:59:26,349 --> 00:59:29,849
因此通常会引起HStack的关注。 

1302
00:59:29,849 --> 00:59:33,549
然后有另一个不那么重要的文本。 

1303
00:59:33,550 --> 00:59:38,420
所以我添加了View修饰符点layoutPriority 100 

1304
00:59:38,420 --> 00:59:40,530
我可以选择任何我真正想要的号码， 

1305
00:59:40,530 --> 00:59:42,400
没关系，这是一个浮点数。 

1306
00:59:42,400 --> 00:59:45,329
这不仅仅是默认的layoutPriority 

1307
00:59:45,329 --> 00:59:46,289
这是零。 

1308
00:59:46,289 --> 00:59:48,820
因此，当该HStack提供其空间时， 

1309
00:59:48,820 --> 00:59:51,610
它将首先提供此文本空间。 

1310
00:59:51,610 --> 00:59:53,210
那文本会说， 

1311
00:59:53,210 --> 00:59:54,880
好吧，当然，我想变得这么大

1312
00:59:54,880 --> 00:59:58,110
所以我可以很重要地一直使用这个词

1313
00:59:58,110 --> 00:59:59,250
那会说，好吧， 

1314
00:59:59,449 --> 01:00:01,599
好吧，没有其他高优先级的产品了。 

1315
01:00:01,599 --> 01:00:03,769
可能还有其他数字不同的数字。 

1316
01:00:03,769 --> 01:00:05,949
它以最高优先级开始，然后下降。 

1317
01:00:05,949 --> 01:00:07,649
所以现在去做图像

1318
01:00:07,650 --> 01:00:09,730
因为它不如文本灵活， 

1319
01:00:09,929 --> 01:00:13,009
图像获得空​​间，然后不重要的文本出现

1320
01:00:13,010 --> 01:00:15,960
以适应剩余的空间。 

1321
01:00:15,960 --> 01:00:17,250
正如我们之前提到的

1322
01:00:17,250 --> 01:00:19,530
当文本没有足够的空间时， 

1323
01:00:19,530 --> 01:00:23,269
它会在其中放点

1324
01:00:23,269 --> 01:00:26,630
或缩短文本以适合其实际空间。 

1325
01:00:26,630 --> 01:00:28,039
它一直想成为它的空间。 

1326
01:00:28,039 --> 01:00:31,679
它从不希望超出其文本的大小。 

1327
01:00:31,679 --> 01:00:33,239
它总是想要确切的尺寸

1328
01:00:33,239 --> 01:00:34,969
但是如果被迫变小， 

1329
01:00:34,969 --> 01:00:36,682
它知道如何做点点。 

1330
01:00:37,650 --> 01:00:40,987
 HStack的另一个重要部分

1331
01:00:40,987 --> 01:00:44,579
 VStack的布局就是它们的一致性。 

1332
01:00:44,579 --> 01:00:48,349
因此，假设您有一个VStack，即垂直的View堆栈。 

1333
01:00:48,349 --> 01:00:50,960
如果这些视图自行选择大小

1334
01:00:50,960 --> 01:00:53,059
它们的宽度不一样。 

1335
01:00:53,059 --> 01:00:56,029
所以它们不能全部填满整个宽度

1336
01:00:56,030 --> 01:00:57,289
这个垂直堆栈。 

1337
01:00:57,489 --> 01:00:59,799
 VStack也会左对齐吗

1338
01:00:59,800 --> 01:01:02,070
或将它们居中或使其对齐？ 

1339
01:01:02,070 --> 01:01:04,809
它怎么知道将它们放在哪里？ 

1340
01:01:04,809 --> 01:01:07,610
好吧，实际上有一个关于VStack和HStack的争论。 

1341
01:01:07,610 --> 01:01:08,277
我们已经知道VStack 

1342
01:01:08,476 --> 01:01:11,029
和HStack具有参数间距

1343
01:01:11,030 --> 01:01:13,360
确定视图之间的间距。 

1344
01:01:13,559 --> 01:01:16,119
它还有另一个论点，对齐。 

1345
01:01:16,119 --> 01:01:19,579
对齐方式以对齐方式为准。 

1346
01:01:19,579 --> 01:01:23,259
例如，其中一个对齐向导处于领先地位。 

1347
01:01:23,260 --> 01:01:27,250
现在，为什么要领导这里而不是离开？ 

1348
01:01:27,250 --> 01:01:28,710
如果我只想要这个VStack 

1349
01:01:28,710 --> 01:01:30,289
使所有这些保持对齐， 

1350
01:01:30,289 --> 01:01:31,237
我为什么不说左点？ 

1351
01:01:31,237 --> 01:01:34,349
实际上，不存在像点这样的东西。 

1352
01:01:34,349 --> 01:01:38,130
点领导意味着拥有事物

1353
01:01:38,130 --> 01:01:41,460
在VStack中排列，以便其边缘开始

1354
01:01:41,460 --> 01:01:44,050
文字的来源

1355
01:01:44,050 --> 01:01:46,460
有时用不同的语言来文字

1356
01:01:46,460 --> 01:01:48,019
从右边移到左边， 

1357
01:01:48,219 --> 01:01:49,839
像希伯来语和阿拉伯语。 

1358
01:01:49,840 --> 01:01:54,269
因此，我们希望我们的VStack一般能够匹配

1359
01:01:54,469 --> 01:01:56,372
文字来自那一边。 

1360
01:01:57,750 --> 01:02:00,460
文本基线也可以排列。 

1361
01:02:00,460 --> 01:02:04,019
因此，HStacks，仅在HStack中才有意义。 

1362
01:02:04,019 --> 01:02:06,449
您可以将其对齐，以使文本的底部， 

1363
01:02:06,449 --> 01:02:09,379
即使它们是不同的字体，也会全部对齐。 

1364
01:02:09,380 --> 01:02:11,900
对于您所熟悉的字体，有两个基准。 

1365
01:02:11,900 --> 01:02:12,829
我不会谈论这个

1366
01:02:12,829 --> 01:02:15,150
但您可以与第一个文本基线对齐

1367
01:02:15,150 --> 01:02:18,570
或HStack中的第二个文本基线。 

1368
01:02:18,570 --> 01:02:20,800
您甚至可以定义自己的东西

1369
01:02:20,800 --> 01:02:23,480
对齐对齐指南。 

1370
01:02:23,679 --> 01:02:26,210
这超出了本课程的范围。 

1371
01:02:26,210 --> 01:02:29,250
所以我们将使用点中心等内置的

1372
01:02:29,250 --> 01:02:31,280
通常默认的对齐方式是

1373
01:02:31,280 --> 01:02:32,670
把东西居中

1374
01:02:32,869 --> 01:02:34,869
 VStack或HStack。 

1375
01:02:34,869 --> 01:02:35,809
但也有顶部

1376
01:02:35,809 --> 01:02:38,279
和底部尾随这些东西。 

1377
01:02:38,280 --> 01:02:40,090
可以想象，当您开始输入时

1378
01:02:40,289 --> 01:02:42,539
在Xcode，VStack对齐冒号中， 

1379
01:02:42,539 --> 01:02:44,329
当然，Xcode会帮助您并告诉您

1380
01:02:44,329 --> 01:02:46,523
这些内置的东西是什么。 

1381
01:02:48,619 --> 01:02:50,746
堆栈就是这样。 

1382
01:02:50,746 --> 01:02:52,130
堆栈非常重要。 

1383
01:02:52,130 --> 01:02:54,019
但是还有另外一件事，修饰符

1384
01:02:54,219 --> 01:02:57,429
像点填充一样，我说的是一种行为

1385
01:02:57,429 --> 01:03:00,179
就像是容器视图

1386
01:03:00,179 --> 01:03:03,460
请记住，点填充等这些东西， 

1387
01:03:03,460 --> 01:03:05,369
他们返回一个视图。 

1388
01:03:05,369 --> 01:03:07,319
您可能以为他们只是返回一个View 

1389
01:03:07,320 --> 01:03:09,420
这样我们就可以再寄给他们

1390
01:03:09,619 --> 01:03:12,049
在它们上调用另一个函数，点groundColor 

1391
01:03:12,050 --> 01:03:13,860
然后给我们一个View， 

1392
01:03:14,059 --> 01:03:15,029
我们称其为点填充。 

1393
01:03:15,030 --> 01:03:18,610
这给了我们一个View，并在其上调用了点字体。 

1394
01:03:18,809 --> 01:03:20,849
因此，不只是给我们一个“视图” 

1395
01:03:20,849 --> 01:03:23,150
因此我们可以在其上调用另一个函数。 

1396
01:03:23,150 --> 01:03:26,880
那些返回的视图实际上可能正在参与

1397
01:03:26,880 --> 01:03:28,590
在布局中。 

1398
01:03:28,590 --> 01:03:30,559
现在，大多数人不参加， 

1399
01:03:30,559 --> 01:03:32,320
像font和foregroundColor。 

1400
01:03:32,320 --> 01:03:36,380
它们不会影响布局，因此可以提供任何空间

1401
01:03:36,380 --> 01:03:38,010
通过HStack或其他容器， 

1402
01:03:38,010 --> 01:03:42,090
他们只是将其传递给包含的任何视图。 

1403
01:03:42,289 --> 01:03:44,009
为了这张幻灯片的目的，我们将认为

1404
01:03:44,010 --> 01:03:48,170
这些修饰符被修改为包含的视图的外观

1405
01:03:48,170 --> 01:03:52,440
根据该视图，修饰符返回的是它的种类。 

1406
01:03:52,440 --> 01:03:56,860
我们将在下周看到如何制作这些视图修饰符， 

1407
01:03:56,860 --> 01:04:00,019
大概还是下一周，取决于情况如何。 

1408
01:04:00,019 --> 01:04:01,670
你会看到那种真的

1409
01:04:01,670 --> 01:04:03,420
发生的是它包含

1410
01:04:03,420 --> 01:04:04,980
正在修改的视图。 

1411
01:04:04,980 --> 01:04:08,829
这些实际参与的修饰符呢？ 

1412
01:04:08,829 --> 01:04:10,960
在布局过程中像填充。 

1413
01:04:10,960 --> 01:04:12,840
让我们看一下填充。 

1414
01:04:12,840 --> 01:04:16,579
点填充，此修饰符返回的视图， 

1415
01:04:16,579 --> 01:04:20,559
它提供了它正在修改空间的视图

1416
01:04:20,559 --> 01:04:23,449
与提供的尺寸相同

1417
01:04:23,449 --> 01:04:25,909
但在这种情况下降低了10分， 

1418
01:04:25,909 --> 01:04:26,879
无论填充是什么。 

1419
01:04:26,880 --> 01:04:28,500
如果那10个不存在， 

1420
01:04:28,699 --> 01:04:31,869
那么它将是任何适合系统的填充。 

1421
01:04:31,869 --> 01:04:33,969
基本上是删除那10个

1422
01:04:33,969 --> 01:04:36,619
因为它知道应该提供10。 

1423
01:04:36,619 --> 01:04:38,819
然后返回该视图

1424
01:04:38,820 --> 01:04:40,960
通过填充选择自己的尺寸

1425
01:04:41,159 --> 01:04:43,599
东西大小

1426
01:04:43,599 --> 01:04:46,299
它正在修改最终是加10。 

1427
01:04:46,300 --> 01:04:47,670
这就是填充的作用

1428
01:04:47,670 --> 01:04:51,500
它在外面增加了10点

1429
01:04:51,500 --> 01:04:53,969
或您所说的任何优势。 

1430
01:04:53,969 --> 01:04:55,480
另一件事是修改。 

1431
01:04:55,480 --> 01:04:59,429
因此，您将看到点填充修饰符只是一个视图

1432
01:04:59,429 --> 01:05:01,899
参与布局。 

1433
01:05:01,900 --> 01:05:03,440
另一个例子是什么？ 

1434
01:05:03,440 --> 01:05:05,340
您已经在作业中使用了它， 

1435
01:05:05,340 --> 01:05:07,150
点宽高比。 

1436
01:05:07,349 --> 01:05:10,420
点AspectRatio修饰符返回的View， 

1437
01:05:10,420 --> 01:05:12,769
它占用了提供的空间

1438
01:05:12,769 --> 01:05:15,059
并自行选择大小

1439
01:05:15,059 --> 01:05:18,039
小于提供的尺寸

1440
01:05:18,039 --> 01:05:19,759
并具有长宽比， 

1441
01:05:19,760 --> 01:05:22,840
那就是如果我们选择AspectRatio的点拟合选项， 

1442
01:05:23,039 --> 01:05:26,269
或者它可能大于所提供的大小， 

1443
01:05:26,269 --> 01:05:30,610
这是使用所有提供的空间的点填充选项。 

1444
01:05:30,610 --> 01:05:33,090
因此，是的，当您使用View时， 

1445
01:05:33,090 --> 01:05:34,590
当您有一定的空间时， 

1446
01:05:34,590 --> 01:05:37,210
您可以选择更大的尺寸。 

1447
01:05:37,210 --> 01:05:39,059
现在很少见了。 

1448
01:05:39,059 --> 01:05:41,389
我们通常不希望Views溢出

1449
01:05:41,389 --> 01:05:44,359
互相贯穿，但这是有道理的， 

1450
01:05:44,360 --> 01:05:47,780
像在这方面比率填充，也许这是有道理的。 

1451
01:05:47,780 --> 01:05:51,090
因此，现在调整自身大小的AspectRatio视图

1452
01:05:51,090 --> 01:05:55,230
具有长宽比，提供它选择的空间

1453
01:05:55,230 --> 01:05:58,849
修改它的任何视图，例如CardView。 

1454
01:05:58,849 --> 01:06:00,920
这样我们的CardView就适合自己了

1455
01:06:00,920 --> 01:06:03,063
在那个不错的宽高比空间中。 

1456
01:06:04,550 --> 01:06:08,170
我们来看一个完整布局的例子

1457
01:06:08,369 --> 01:06:10,829
在传递的大小之类的东西上。 

1458
01:06:10,829 --> 01:06:14,809
所以这是一个类似于我们的HStack 

1459
01:06:14,809 --> 01:06:17,909
在我们的记忆游戏中，并不完全相同

1460
01:06:17,909 --> 01:06:19,429
但非常相似

1461
01:06:19,429 --> 01:06:23,309
这个东西的空间如何分配？ 

1462
01:06:23,309 --> 01:06:24,639
好，首先要了解的是

1463
01:06:24,639 --> 01:06:27,509
将提供空间的第一个视图

1464
01:06:27,510 --> 01:06:31,880
整个绿色元素就是填充视图。 

1465
01:06:31,880 --> 01:06:33,130
这是最外面的视图。 

1466
01:06:33,130 --> 01:06:37,630
最终，实际上就是视图

1467
01:06:37,630 --> 01:06:40,079
但无论有多少空间都会提供

1468
01:06:40,079 --> 01:06:42,639
对于这里的整个绿色建筑。 

1469
01:06:42,639 --> 01:06:45,940
现在要做的是减少

1470
01:06:45,940 --> 01:06:48,510
从它的边缘拿走10分

1471
01:06:48,510 --> 01:06:52,269
并将剩下的空间传递到下一个视图

1472
01:06:52,469 --> 01:06:56,649
这是前景色修改器返回的视图。 

1473
01:06:56,650 --> 01:06:59,630
现在，修饰符并没有真正参与布局， 

1474
01:06:59,630 --> 01:07:01,820
确实对尺寸没有任何影响

1475
01:07:01,820 --> 01:07:02,650
摆好东西

1476
01:07:02,849 --> 01:07:07,429
因此它只是将其原封不动地传递给HStack。 

1477
01:07:07,429 --> 01:07:11,309
现在，众所周知，HStack是大型布局视图。 

1478
01:07:11,309 --> 01:07:15,239
它将开始平均分配其空间

1479
01:07:15,239 --> 01:07:18,959
由于aspectRatio不是像Images这样的东西

1480
01:07:18,960 --> 01:07:20,760
或固定大小的文字， 

1481
01:07:20,760 --> 01:07:23,250
最终将空间平均分配

1482
01:07:23,449 --> 01:07:27,879
在ForEach的所有AspectRatio视图中， 

1483
01:07:27,880 --> 01:07:30,610
因为我们知道ForEach本身就顺应了

1484
01:07:30,610 --> 01:07:31,980
到HStack。 

1485
01:07:31,980 --> 01:07:34,389
所以现在是aspectRatio Views 

1486
01:07:34,389 --> 01:07:36,960
正在HStack中进行布局。 

1487
01:07:36,960 --> 01:07:39,789
每个aspectRatio视图将设置其宽度

1488
01:07:39,989 --> 01:07:42,639
占HStack宽度的份额

1489
01:07:42,639 --> 01:07:45,269
然后选择与宽高比匹配的高度， 

1490
01:07:45,269 --> 01:07:49,659
 2/3的宽高比，或者如果此处的高度受限制， 

1491
01:07:49,659 --> 01:07:51,159
可能是相反的方式

1492
01:07:51,159 --> 01:07:53,649
其中aspectRatio视图占所有

1493
01:07:53,650 --> 01:07:56,809
所提供的高度，而是选择宽度

1494
01:07:56,809 --> 01:07:58,559
那不太适合。 

1495
01:07:58,559 --> 01:07:59,630
因此，它可能以任何方式进行。 

1496
01:07:59,630 --> 01:08:02,269
这取决于哪个最合适

1497
01:08:02,469 --> 01:08:04,829
在提供的空间中。 

1498
01:08:04,829 --> 01:08:07,679
然后AspectRatio选择了该大小。 

1499
01:08:07,679 --> 01:08:09,629
它将提供给CardView 

1500
01:08:09,630 --> 01:08:11,670
而CardView将使用所有空间

1501
01:08:11,670 --> 01:08:13,409
因为就像普通的视图一样

1502
01:08:13,409 --> 01:08:16,949
无论您提供多少空间，它几乎都会被使用。 

1503
01:08:16,949 --> 01:08:20,579
在所有这些提供和调整大小之后， 

1504
01:08:20,579 --> 01:08:23,619
整个绿色视图的大小将是多少？ 

1505
01:08:23,619 --> 01:08:24,729
好吧，这将是大小

1506
01:08:24,729 --> 01:08:27,009
任何View.padding 10返回

1507
01:08:27,010 --> 01:08:30,289
这是HStack调整自身大小的结果

1508
01:08:30,289 --> 01:08:32,449
适合所有这些方面

1509
01:08:32,449 --> 01:08:34,789
在各方面加10分。 

1510
01:08:34,789 --> 01:08:38,109
那将是整个绿色物体的大小。 

1511
01:08:38,109 --> 01:08:40,289
让我们来讨论一下占据所有空间的视图

1512
01:08:40,289 --> 01:08:41,609
提供给他们。 

1513
01:08:41,609 --> 01:08:43,420
显然，诸如RoundedRectangle， 

1514
01:08:43,420 --> 01:08:44,819
对他们来说真的很容易。 

1515
01:08:44,819 --> 01:08:47,920
他们只是一直沿矩形爬行到边缘

1516
01:08:47,920 --> 01:08:50,109
他们所提供的。 

1517
01:08:50,109 --> 01:08:52,889
但是，像CardView这样的自定义视图呢？ 

1518
01:08:52,890 --> 01:08:55,220
我们使用ZStack构建的CardView 

1519
01:08:55,220 --> 01:08:58,029
使用RoundedRectangle，Texts，我们正在构建此东西。 

1520
01:08:58,229 --> 01:09:00,899
它占用了所有提供的空间， 

1521
01:09:00,899 --> 01:09:02,449
而且没有理由不应该

1522
01:09:02,449 --> 01:09:05,079
但它确实应该适应自己

1523
01:09:05,079 --> 01:09:06,949
到提供的任何空间。 

1524
01:09:06,949 --> 01:09:09,170
我们真的拼命地看到了这一点

1525
01:09:09,170 --> 01:09:11,489
带有表情符号的字体大小。 

1526
01:09:11,689 --> 01:09:13,109
在你的作业中我问你

1527
01:09:13,109 --> 01:09:16,439
用于将很小的卡片切换为较小的字体。 

1528
01:09:16,439 --> 01:09:17,879
而且我相信您可能会意识到， 

1529
01:09:17,880 --> 01:09:21,289
哇，这真是解决这个问题的好方法。 

1530
01:09:21,289 --> 01:09:22,539
当然是。 

1531
01:09:22,539 --> 01:09:25,939
确实，在演示中我们需要做的是，我们要做的， 

1532
01:09:25,939 --> 01:09:29,359
选择相关的字体大小

1533
01:09:29,359 --> 01:09:31,219
到提供的尺寸。 

1534
01:09:31,220 --> 01:09:33,539
由于我们要接受提供给我们的尺寸， 

1535
01:09:33,539 --> 01:09:36,720
我们应该选择适合的字体大小。 

1536
01:09:36,720 --> 01:09:40,600
那么，视图如何知道为其提供了什么空间

1537
01:09:40,600 --> 01:09:44,333
并可以做出例如字体选择的决定？ 

1538
01:09:44,533 --> 01:09:46,389
好吧，我们使用特殊的视图来实现。 

1539
01:09:46,390 --> 01:09:48,500
它只是一个视图，但是有点特殊， 

1540
01:09:48,500 --> 01:09:51,130
称为GeometryReader。 

1541
01:09:51,130 --> 01:09:53,680
以及您使用GeometryReader视图做什么

1542
01:09:53,680 --> 01:09:56,369
它包裹着您想要的任何东西吗

1543
01:09:56,569 --> 01:09:58,969
适应大小。 

1544
01:09:58,970 --> 01:10:01,529
因此，这通常会吸收您体内的任何物质

1545
01:10:01,729 --> 01:10:05,809
您只需像这样将GeometryReader包裹起来即可。 

1546
01:10:05,810 --> 01:10:07,420
 GeometryReader只是一个视图。 

1547
01:10:07,420 --> 01:10:11,092
我没有在这里向您展示显而易见的东西。 

1548
01:10:11,092 --> 01:10:13,539
 GeometryReader，开括号，内容， 

1549
01:10:13,539 --> 01:10:16,090
冒号，所有这些，就像在HStack中一样

1550
01:10:16,090 --> 01:10:17,960
这仅仅是内容。 

1551
01:10:17,960 --> 01:10:20,840
但是您确实注意到那里有一点争论

1552
01:10:20,840 --> 01:10:23,949
几何形状，类似于ForEach具有参数的方式

1553
01:10:23,949 --> 01:10:25,739
这就是我们要迭代的事情。 

1554
01:10:25,739 --> 01:10:27,652
这也有一个论点。 

1555
01:10:28,659 --> 01:10:31,930
因此，此参数的类型为GeometryProxy。 

1556
01:10:32,984 --> 01:10:35,246
而这个GeometryProxy只是一个结构

1557
01:10:35,247 --> 01:10:37,067
它里面有一些很好的信息， 

1558
01:10:37,067 --> 01:10:39,640
最重要的是您看到的第一个

1559
01:10:39,640 --> 01:10:43,430
 var size，即您所提供的大小。 

1560
01:10:43,430 --> 01:10:46,119
宽度和高度CGSize是宽度和高度

1561
01:10:46,319 --> 01:10:47,197
被提供给你。 

1562
01:10:47,197 --> 01:10:49,556
您可以使用该尺寸，以磅为单位， 

1563
01:10:49,556 --> 01:10:51,420
当然，字体大小以磅为单位。 

1564
01:10:51,420 --> 01:10:52,760
所以对我们来说这很容易

1565
01:10:52,760 --> 01:10:56,680
选择适合该大小的字体大小。 

1566
01:10:56,680 --> 01:10:58,409
你在这里看到其他一些东西， 

1567
01:10:58,409 --> 01:11:00,760
像框架实际上不仅大小

1568
01:11:00,760 --> 01:11:03,159
但这是一个矩形

1569
01:11:03,359 --> 01:11:05,279
在某个坐标空间

1570
01:11:05,279 --> 01:11:08,639
我们的父母坐标空间或全局坐标空间

1571
01:11:08,640 --> 01:11:12,079
我们甚至可以看一下是否愿意。 

1572
01:11:12,079 --> 01:11:13,739
我要谈谈那里的最后一个， 

1573
01:11:13,739 --> 01:11:16,143
 safeAreaInsets，在下一张幻灯片上。 

1574
01:11:17,350 --> 01:11:19,850
关于GeometeryReader要记住的一件事， 

1575
01:11:19,850 --> 01:11:23,960
它只是一个视图，但它始终接受

1576
01:11:23,960 --> 01:11:25,542
提供给它的空间。 

1577
01:11:26,560 --> 01:11:29,842
我强调这是因为它需要一点点沉入

1578
01:11:30,042 --> 01:11:33,889
因为你不想在这里进入递归循环

1579
01:11:33,890 --> 01:11:37,090
 GeometryReader正在读取其大小的位置

1580
01:11:37,090 --> 01:11:39,239
然后您尝试实际更改大小

1581
01:11:39,239 --> 01:11:41,849
基于GeometryReader读取的大小。 

1582
01:11:41,850 --> 01:11:42,619
那样行不通。 

1583
01:11:42,819 --> 01:11:46,329
 GeometryReader始终接受大小，空间， 

1584
01:11:46,329 --> 01:11:47,162
提供给他们的， 

1585
01:11:47,162 --> 01:11:48,489
你必须这样想。 

1586
01:11:48,489 --> 01:11:51,670
因此，GeometryReaders实用程序受到限制

1587
01:11:51,670 --> 01:11:54,210
知道您要提供的尺寸

1588
01:11:54,210 --> 01:11:56,670
并调整您的内在外观， 

1589
01:11:56,670 --> 01:11:58,130
这就是GeometryReader的目的。 

1590
01:11:58,130 --> 01:12:01,869
不要试图将GeometryReader变成不是的东西。 

1591
01:12:01,869 --> 01:12:03,510
它只是在读取您的几何图形。 

1592
01:12:03,510 --> 01:12:04,800
它叫做GeometryReader，它读取几何

1593
01:12:06,720 --> 01:12:09,579
并适应它，以便可以更改字体

1594
01:12:09,579 --> 01:12:10,693
之类的。 

1595
01:12:12,539 --> 01:12:14,519
我们提到的安全区， 

1596
01:12:14,520 --> 01:12:15,353
该safeAreaInsets 

1597
01:12:15,353 --> 01:12:18,130
 GeometryReader告诉您的信息。 

1598
01:12:18,130 --> 01:12:21,739
通过思考可以最好地可视化安全区域

1599
01:12:21,739 --> 01:12:24,170
 iPhone 10上的缺口

1600
01:12:24,170 --> 01:12:27,149
大多数时候，你不想草拟

1601
01:12:27,149 --> 01:12:29,119
根据缺口所在的尺寸， 

1602
01:12:29,119 --> 01:12:30,399
并非总是如此。 

1603
01:12:30,399 --> 01:12:33,099
有时您可能实际上想在那里画画。 

1604
01:12:33,100 --> 01:12:34,890
还有其他安全区域的事情。 

1605
01:12:34,890 --> 01:12:37,289
有时，视图会添加装饰

1606
01:12:37,289 --> 01:12:40,090
或他们在屏幕上绘画的方式

1607
01:12:40,090 --> 01:12:42,680
他们不希望您在某些空间中绘画的地方

1608
01:12:42,680 --> 01:12:46,250
因此他们会创建一个安全区域供您使用。 

1609
01:12:46,250 --> 01:12:49,630
但是，如果您想离开自己的安全区域，则可以， 

1610
01:12:49,630 --> 01:12:50,989
而你这样做的方式是

1611
01:12:50,989 --> 01:12:54,386
通过此处的View修饰符edgeIgnoringSafeArea， 

1612
01:12:54,386 --> 01:12:57,159
然后指定所需的边缘

1613
01:12:57,159 --> 01:12:58,930
忽略那个安全区域。 

1614
01:12:58,930 --> 01:13:01,529
因此，如果我说edgesIgnoringSafeArea回到顶部， 

1615
01:13:01,729 --> 01:13:04,069
然后ZStack及其所有内容

1616
01:13:04,069 --> 01:13:06,799
忽略顶部有安全区域

1617
01:13:06,800 --> 01:13:10,789
然后就在那刻痕的下方画上去

1618
01:13:10,789 --> 01:13:13,529
因此，它可能是照片查看应用程序之类的东西， 

1619
01:13:13,529 --> 01:13:15,460
也许你想一直到边缘

1620
01:13:15,460 --> 01:13:16,672
所以你可以在这里做。 

1621
01:13:18,869 --> 01:13:20,149
让我们谈一点

1622
01:13:20,149 --> 01:13:22,509
容器如何工作

1623
01:13:22,510 --> 01:13:25,869
这是为其视图提供空间，然后定位它们的位置。 

1624
01:13:25,869 --> 01:13:29,319
它为此修改器框架提供了空间。 

1625
01:13:29,319 --> 01:13:32,289
现在，我在这里不再详细讨论框架。 

1626
01:13:32,289 --> 01:13:34,329
你可以去看看文件架

1627
01:13:34,329 --> 01:13:36,420
有很多争论，你知道， 

1628
01:13:36,420 --> 01:13:39,909
理想宽度，最小宽度，所有这些种类的东西

1629
01:13:39,909 --> 01:13:44,909
尝试与景观交流，这里是空间

1630
01:13:44,920 --> 01:13:46,103
我在给你。 

1631
01:13:47,069 --> 01:13:48,409
这就是空间。 

1632
01:13:48,409 --> 01:13:51,159
然后，视图选择了自己的尺寸后， 

1633
01:13:51,159 --> 01:13:53,899
那么我们将使用这个修饰符位置

1634
01:13:53,899 --> 01:13:56,389
把它放在我们坐标空间的某个地方

1635
01:13:56,390 --> 01:13:57,600
在容器之前。 

1636
01:13:57,600 --> 01:14:00,699
因此，他们就是这样做的。 

1637
01:14:00,899 --> 01:14:02,219
非常简单。 

1638
01:14:02,220 --> 01:14:05,810
例如，堆栈将使用其对齐信息

1639
01:14:05,810 --> 01:14:08,630
以及所有的间距

1640
01:14:08,630 --> 01:14:10,970
弄清楚他们的观点应该去哪里， 

1641
01:14:10,970 --> 01:14:13,329
它会设置这个CGPoint 

1642
01:14:13,329 --> 01:14:16,340
这是CGPoint视图的中心

1643
01:14:16,340 --> 01:14:17,819
对于每个视图。 

1644
01:14:17,819 --> 01:14:20,279
顺便说一句，这里有点酷

1645
01:14:20,279 --> 01:14:23,759
称为偏移量，它将偏移视图

1646
01:14:23,760 --> 01:14:25,279
从容器放到哪里。 

1647
01:14:25,479 --> 01:14:27,529
因此，您可以让容器完成其工作， 

1648
01:14:27,529 --> 01:14:28,569
把东西放在某处

1649
01:14:28,569 --> 01:14:31,340
然后您仍然可以通过一些方式抵消它。 

1650
01:14:31,340 --> 01:14:32,420
容器可以做到这一点

1651
01:14:32,420 --> 01:14:33,680
但其他人也可以做到。 

1652
01:14:33,680 --> 01:14:34,750
视图可以做到这一点。 

1653
01:14:34,949 --> 01:14:36,500
我想抵消一点。 

1654
01:14:36,500 --> 01:14:38,539
因此，抵消是一个有趣的小家伙。 

1655
01:14:38,539 --> 01:14:39,890
我们不用太多的偏移量

1656
01:14:39,890 --> 01:14:41,949
但我只想让你知道它的存在。 

1657
01:14:42,149 --> 01:14:44,889
现在，为了记住，我们将使用框架和位置

1658
01:14:44,890 --> 01:14:46,579
创建我们自己的容器视图

1659
01:14:46,779 --> 01:14:48,420
有点像堆栈。 

1660
01:14:48,420 --> 01:14:52,350
它被称为网格，它是2D，行和列， 

1661
01:14:52,350 --> 01:14:54,270
而不只是水平行

1662
01:14:54,270 --> 01:14:55,920
这是一个非常可悲的游戏， 

1663
01:14:56,119 --> 01:14:58,136
如果我现在就这样说的话。 

1664
01:14:58,136 --> 01:15:00,269
我们显然希望它是行和列。 

1665
01:15:00,270 --> 01:15:02,989
我们将通过使用框架和位置来做到这一点

1666
01:15:03,189 --> 01:15:04,589
创建我们自己的容器。 

1667
01:15:06,689 --> 01:15:09,039
所以我们今天要回到演示。 

1668
01:15:09,039 --> 01:15:11,710
我很想有时间去做那个容器， 

1669
01:15:11,710 --> 01:15:14,970
但是我们没有，第三节课结束。 

1670
01:15:14,970 --> 01:15:17,640
我会做一个简短的演示

1671
01:15:17,640 --> 01:15:19,890
只是向您展示GeometryReader的工作原理。 

1672
01:15:19,890 --> 01:15:22,250
而我们要做的就是我一直在谈论的东西， 

1673
01:15:22,449 --> 01:15:26,439
使我们的字体，表情符号字体变大

1674
01:15:26,439 --> 01:15:30,000
使用GeometryReader提供给我们的空间。 

1675
01:15:30,000 --> 01:15:31,710
当我在那里的时候，我可能会做一件小事

1676
01:15:31,710 --> 01:15:33,500
我要告诉你最好的方法

1677
01:15:33,500 --> 01:15:35,939
或我们大家都同意的那种方式

1678
01:15:35,939 --> 01:15:39,259
在我们的代码中收集魔术数字。 

1679
01:15:39,260 --> 01:15:41,600
如果您已经有一个如cornerRadius 10这样的设备， 

1680
01:15:41,600 --> 01:15:43,500
那10是个魔术数字， 

1681
01:15:43,500 --> 01:15:45,020
它确实不应该嵌入我们的代码中。 

1682
01:15:45,020 --> 01:15:46,930
 Swift中有一种规范的方式

1683
01:15:46,930 --> 01:15:50,460
把它拿出来放在自己的小空间

1684
01:15:50,460 --> 01:15:52,262
因此，它有充分的文档记录和类型。 

1685
01:15:54,130 --> 01:15:56,170
现在，我们开始下一个演讲， 

1686
01:15:56,170 --> 01:15:59,380
使用GeometryReader以及带有协议的泛型

1687
01:15:59,380 --> 01:16:01,449
和功能作为类型

1688
01:16:01,449 --> 01:16:05,289
使这个美丽的小简单的网格视图

1689
01:16:05,289 --> 01:16:06,439
那就像是一个HStack。 

1690
01:16:06,439 --> 01:16:10,029
我们将仅使用此Grid View来替换HStack 

1691
01:16:10,029 --> 01:16:12,300
并使我们的卡片排列在一个漂亮的网格中

1692
01:16:12,300 --> 01:16:13,829
因此，让我们跳入该演示

1693
01:16:13,829 --> 01:16:15,939
然后这将是本讲座的结尾。 

1694
01:16:15,939 --> 01:16:18,189
现在，您在作业中被问到

1695
01:16:18,189 --> 01:16:21,359
在这里调整字体选择

1696
01:16:21,359 --> 01:16:24,546
适合小卡片，因为小卡片， 

1697
01:16:24,546 --> 01:16:27,529
我们选择的字体，大标题太大。 

1698
01:16:27,529 --> 01:16:30,170
这可能已经解决了，仅适用于小卡片

1699
01:16:30,170 --> 01:16:32,720
但是我让你这样做几乎是为了意识到， 

1700
01:16:32,720 --> 01:16:34,579
好吧，那不是一个好的解决方案， 

1701
01:16:34,579 --> 01:16:36,569
特别是当我们在风景中

1702
01:16:36,569 --> 01:16:39,439
甚至大标题也太小了。 

1703
01:16:39,439 --> 01:16:42,989
所以我们真正想要的是我们的卡

1704
01:16:42,989 --> 01:16:45,050
选择使用所有空间的字体。 

1705
01:16:45,050 --> 01:16:47,279
那确实是我们想要做的。 

1706
01:16:47,279 --> 01:16:49,289
那么我们该怎么做呢？ 

1707
01:16:49,289 --> 01:16:51,859
好吧，我们将使用特殊的View来做到这一点。 

1708
01:16:51,859 --> 01:16:54,179
这是另一个视图，就像HStack是一个视图

1709
01:16:54,180 --> 01:16:57,880
 ForEach是一个视图，ZStack是几个，Text是一个视图。 

1710
01:16:57,880 --> 01:16:59,569
这些都是视图。 

1711
01:16:59,569 --> 01:17:02,729
有一个特殊的视图称为

1712
01:17:02,729 --> 01:17:07,519
 GeometryReader视图。 

1713
01:17:07,520 --> 01:17:09,920
所以GeometryReader有一个参数

1714
01:17:10,119 --> 01:17:12,340
这是要去的内容

1715
01:17:12,340 --> 01:17:14,090
显示在自己的内部

1716
01:17:14,090 --> 01:17:17,113
就像我们的名片一样， 

1717
01:17:18,247 --> 01:17:20,099
 ZStack可以制作我们的卡， 

1718
01:17:20,100 --> 01:17:24,329
但是这里有一个很好的论点，叫做几何

1719
01:17:24,329 --> 01:17:28,199
就像ForEach是在这里有论点的View 

1720
01:17:28,199 --> 01:17:30,720
但它也有这种内容论点

1721
01:17:30,720 --> 01:17:34,470
它提供了要遍历的Card。 

1722
01:17:34,470 --> 01:17:37,130
同样，GeometryReader，它具有内容， 

1723
01:17:37,130 --> 01:17:41,050
要求一个视图，但它提供了这种特殊的几何形状。 

1724
01:17:41,050 --> 01:17:43,210
我们将看看这个小变量

1725
01:17:43,210 --> 01:17:45,260
在这里给你的

1726
01:17:45,260 --> 01:17:46,590
因为我们可以看一下

1727
01:17:46,590 --> 01:17:48,600
我们视图的大小是多少。 

1728
01:17:48,600 --> 01:17:52,041
现在请注意，当我们放置代码时，我们的ZStack 

1729
01:17:52,041 --> 01:17:54,779
在GeometryReader内容中， 

1730
01:17:54,979 --> 01:17:58,119
我们得到了这些需要自我加点的东西。 

1731
01:17:58,119 --> 01:18:02,457
因此，请通过此处并对此进行修复， 

1732
01:18:02,457 --> 01:18:04,652
修理那个，捡起来。 

1733
01:18:06,029 --> 01:18:07,659
那是什么

1734
01:18:07,659 --> 01:18:10,771
让我们看一下GeometryReader的文档。 

1735
01:18:10,771 --> 01:18:14,140
因此，我将执行Option +单击以查看GeometryReader。 

1736
01:18:14,140 --> 01:18:16,079
您可以在这里看到struct GeometryReader结构。 

1737
01:18:16,279 --> 01:18:19,289
不用管它叫Content 

1738
01:18:19,289 --> 01:18:21,439
该内容是一个视图。 

1739
01:18:21,439 --> 01:18:24,299
所以现在，希望您开始了

1740
01:18:24,300 --> 01:18:25,770
了解这意味着什么， 

1741
01:18:25,770 --> 01:18:27,779
内容是视图在哪里，对不对？ 

1742
01:18:27,979 --> 01:18:30,779
内容不在乎，视图是协议。 

1743
01:18:30,779 --> 01:18:32,939
所以我们已经把无关紧要变成了

1744
01:18:32,939 --> 01:18:34,949
好吧，我们有点在意吧？ 

1745
01:18:34,949 --> 01:18:38,220
我们关心的是GeometryReader的内容是一个View， 

1746
01:18:38,220 --> 01:18:40,320
但是否则它可以是它想要的任何东西。 

1747
01:18:41,449 --> 01:18:44,489
所以我要在文档中打开它

1748
01:18:44,489 --> 01:18:46,079
看看它怎么说。 

1749
01:18:46,079 --> 01:18:47,609
这是初始化。 

1750
01:18:47,609 --> 01:18:50,529
您可以看到它需要这一参数内容

1751
01:18:50,529 --> 01:18:53,939
您实际上应该在这里识别此语法

1752
01:18:53,939 --> 01:18:56,829
因为真的，它需要一个功能

1753
01:18:56,829 --> 01:18:59,539
返回此内容的内容不在乎， 

1754
01:18:59,539 --> 01:19:02,720
我们知道实际上是我们关心的一点内容

1755
01:19:02,720 --> 01:19:06,430
 Content Content View所在的位置，因此我们知道它必须是View。 

1756
01:19:06,430 --> 01:19:09,561
这就是一个带有参数的函数

1757
01:19:09,761 --> 01:19:14,279
 GeometryProxy，并返回此无关内容。 

1758
01:19:14,279 --> 01:19:17,059
不用担心在那逃脱。 

1759
01:19:17,060 --> 01:19:19,699
我们将在接下来的几周内谈论这一点。 

1760
01:19:19,899 --> 01:19:22,960
因此，让我们单击此GeometryProxy 

1761
01:19:22,960 --> 01:19:25,029
并查看其装饰。 

1762
01:19:25,229 --> 01:19:26,659
在这里，您可以看到它具有

1763
01:19:26,659 --> 01:19:29,130
我们在幻灯片中讨论的事情。 

1764
01:19:29,130 --> 01:19:32,510
现在，我将重点显然放在此处的尺寸上。 

1765
01:19:32,510 --> 01:19:34,890
因此，让我们单击它。 

1766
01:19:34,890 --> 01:19:37,210
您会看到大小只是CGSize， 

1767
01:19:37,409 --> 01:19:38,806
它只有get，它是只读的。 

1768
01:19:38,806 --> 01:19:41,210
只是要告诉我们宽度和高度

1769
01:19:41,210 --> 01:19:44,302
我们已经提供了绘制此视图的方法。 

1770
01:19:45,789 --> 01:19:47,430
这正是我们想要的。 

1771
01:19:47,430 --> 01:19:49,810
我们希望此几何尺寸就在这里。 

1772
01:19:49,810 --> 01:19:51,630
我要去做的是

1773
01:19:51,630 --> 01:19:54,569
我的CardView拥有所有权

1774
01:19:54,569 --> 01:19:58,279
在这里设置自己的字体。 

1775
01:19:58,279 --> 01:19:59,639
因此，它将使用字体。 

1776
01:19:59,640 --> 01:20:02,550
因此，我不再在游戏本身中设置字体。 

1777
01:20:02,550 --> 01:20:04,670
我让卡设置自己的字体

1778
01:20:04,670 --> 01:20:07,210
无论如何，这可能是更好的封装。 

1779
01:20:07,210 --> 01:20:08,470
为什么我们在这里， 

1780
01:20:08,470 --> 01:20:12,317
我们不需要像HStack这样的冒号内容

1781
01:20:12,317 --> 01:20:13,390
以及所有其他这些东西。 

1782
01:20:13,390 --> 01:20:16,310
我们可以摆脱它，摆脱它

1783
01:20:16,310 --> 01:20:18,739
所以这看起来很干净。 

1784
01:20:18,939 --> 01:20:22,189
所以我们想在这里做一个字体，所以写一些字体， 

1785
01:20:22,189 --> 01:20:25,639
其尺寸基于该几何尺寸。 

1786
01:20:25,640 --> 01:20:27,353
所以我要创建系统字体， 

1787
01:20:27,353 --> 01:20:29,810
只是在这里制作系统字体的不同方法， 

1788
01:20:29,810 --> 01:20:30,930
样式和大小。 

1789
01:20:30,930 --> 01:20:33,717
所以我只是选择尺寸。 

1790
01:20:33,717 --> 01:20:37,139
我想要一个CGFloat，其大小为磅值。 

1791
01:20:37,140 --> 01:20:39,840
并记住字体的磅值是相关的

1792
01:20:39,840 --> 01:20:42,909
到点的宽度和点的高度。 

1793
01:20:42,909 --> 01:20:45,199
所以我实际上要选择最小的

1794
01:20:45,199 --> 01:20:46,229
宽度到高度的

1795
01:20:46,229 --> 01:20:47,919
因为我不一定要依靠

1796
01:20:47,920 --> 01:20:50,600
了解我的长宽比是多少。 

1797
01:20:50,600 --> 01:20:52,539
所以我只选择这两个中的最小值

1798
01:20:52,739 --> 01:20:55,289
确保我选择合适的字体。 

1799
01:20:55,289 --> 01:21:00,289
所以这是最小几何尺寸宽度

1800
01:21:00,329 --> 01:21:03,569
以及几何尺寸高度。 

1801
01:21:03,569 --> 01:21:05,949
所以我使用的是我们看到的那个大小变量

1802
01:21:05,949 --> 01:21:08,840
就在这里的GeometryProxy中。 

1803
01:21:08,840 --> 01:21:10,850
也许我们可以尝试一下。 

1804
01:21:10,850 --> 01:21:12,869
让我们选择一个字体大小

1805
01:21:13,069 --> 01:21:15,439
这是这两个中的最小值

1806
01:21:15,439 --> 01:21:16,929
然后看看它是什么样子。 

1807
01:21:16,930 --> 01:21:17,972
因此，让我们运行它。 

1808
01:21:20,470 --> 01:21:21,640
看那个。 

1809
01:21:21,640 --> 01:21:25,619
这样的尺寸要小得多，甚至会更小。 

1810
01:21:25,619 --> 01:21:27,539
但这实际上太大了。 

1811
01:21:27,539 --> 01:21:30,029
那里太大了。 

1812
01:21:30,029 --> 01:21:33,920
也许只是因为绘图点大小

1813
01:21:33,920 --> 01:21:36,380
不完全是字体的宽度。 

1814
01:21:36,380 --> 01:21:39,329
它可能与高度有关， 

1815
01:21:39,329 --> 01:21:42,930
但是我们也确实在边缘上做了一些笔触

1816
01:21:42,930 --> 01:21:45,340
也会占用一点空间。 

1817
01:21:45,340 --> 01:21:49,289
所以可能我需要某种常数乘数

1818
01:21:49,289 --> 01:21:54,289
大概是75％，0.75等等。 

1819
01:21:56,850 --> 01:22:00,539
而75％的人看起来确实不错。 

1820
01:22:00,539 --> 01:22:03,493
大的时候看起来不错，小的时候看起来不错。 

1821
01:22:04,640 --> 01:22:07,090
在完成第三讲之前， 

1822
01:22:07,090 --> 01:22:09,159
我想在这里花点时间

1823
01:22:09,159 --> 01:22:12,239
谈论编码风格问题。 

1824
01:22:12,239 --> 01:22:15,779
我很少谈论编码风格， 

1825
01:22:15,779 --> 01:22:19,069
纯粹出于时间限制

1826
01:22:19,069 --> 01:22:20,829
但是这次我要提一下。 

1827
01:22:20,829 --> 01:22:23,399
因为这有点塞古

1828
01:22:23,399 --> 01:22:27,009
我们将如何构建我们的View代码

1829
01:22:27,010 --> 01:22:29,500
使其更具可读性。 

1830
01:22:29,500 --> 01:22:33,390
我担心的问题是这些幻数。 

1831
01:22:33,390 --> 01:22:35,710
我们已经创建了这些蓝色魔术数字

1832
01:22:35,710 --> 01:22:38,590
并开始在整个代码中散布它们。 

1833
01:22:38,590 --> 01:22:41,405
那不是很好的编码风格。 

1834
01:22:41,405 --> 01:22:43,609
 SwiftUI是声明性的。 

1835
01:22:43,609 --> 01:22:46,599
我们实质上是在这里直接声明UI。 

1836
01:22:46,600 --> 01:22:49,470
我们不是在调用函数来告诉它自己构建， 

1837
01:22:49,470 --> 01:22:51,310
我们在这里宣布。 

1838
01:22:51,310 --> 01:22:53,960
当我们这样做时，这些蓝色数字最终

1839
01:22:53,960 --> 01:22:57,010
是我们可以转动的旋钮

1840
01:22:57,010 --> 01:23:01,220
调整View的外观并使其正确。 

1841
01:23:01,220 --> 01:23:02,390
好吧，现在我们的旋钮

1842
01:23:02,390 --> 01:23:04,869
散布在这里

1843
01:23:04,869 --> 01:23:08,559
如果我们能有一个控制面板，那真是太好了。 

1844
01:23:08,560 --> 01:23:11,670
因此，我将创建一个小的控制面板。 

1845
01:23:11,869 --> 01:23:15,649
我要在这里评论以标记它的绘制常数， 

1846
01:23:15,649 --> 01:23:16,929
我要称呼它

1847
01:23:16,930 --> 01:23:19,800
并把我所有的绘画常数放在这里

1848
01:23:19,800 --> 01:23:24,130
就像vars一样，让和在我的结构上起作用。 

1849
01:23:24,130 --> 01:23:26,699
而把vars和let 

1850
01:23:26,899 --> 01:23:28,819
和功能在您的结构

1851
01:23:28,819 --> 01:23:32,069
清理或修复魔术数字

1852
01:23:32,069 --> 01:23:34,539
在您看来，非常重要。 

1853
01:23:34,539 --> 01:23:38,529
您会看到大多数视图都有一些变量

1854
01:23:38,529 --> 01:23:40,359
并让我们在这里玩

1855
01:23:40,359 --> 01:23:44,929
使外观看起来尽可能整洁易懂。 

1856
01:23:44,930 --> 01:23:48,779
因此，让我们使用这个想法来获得这些神奇的数字。 

1857
01:23:48,979 --> 01:23:50,389
这些碰巧是常数。 

1858
01:23:50,390 --> 01:23:52,430
所以我要用let。 

1859
01:23:52,430 --> 01:23:55,079
记住，让我们就像var一样

1860
01:23:55,279 --> 01:23:57,449
因为let表示它是一个常数。 

1861
01:23:57,449 --> 01:24:01,269
因此，让我们在此处进行转角半径cornerRadius的设置。 

1862
01:24:01,270 --> 01:24:04,710
您可能会认为您可以说cornerRadius等于10 

1863
01:24:04,710 --> 01:24:07,869
但这是行不通的，我将向您展示为什么。 

1864
01:24:07,869 --> 01:24:10,579
如果按住Option键，请记住， 

1865
01:24:10,579 --> 01:24:13,880
然后点击，它将告诉您声明

1866
01:24:13,880 --> 01:24:16,340
您点击的东西

1867
01:24:16,340 --> 01:24:17,920
就我们而言，这是我们的角落

1868
01:24:17,920 --> 01:24:20,819
并且已将其键入为Int。 

1869
01:24:20,819 --> 01:24:23,929
请记住，如果我们说让var等于某物

1870
01:24:23,930 --> 01:24:26,907
而且我们没有指定它的类型，Swift会推断出来。 

1871
01:24:26,907 --> 01:24:28,529
这里是看这十个

1872
01:24:28,729 --> 01:24:31,369
和引用，看起来像一个Int。 

1873
01:24:31,369 --> 01:24:33,099
那不是我们想要的。 

1874
01:24:33,100 --> 01:24:37,340
这些蓝色的数字都是CGFloats， 

1875
01:24:37,340 --> 01:24:40,069
我们用来绘制的浮点数。 

1876
01:24:40,069 --> 01:24:42,670
现在，我什至不能说10.0。 

1877
01:24:42,670 --> 01:24:46,340
如果我这样做，并且按住Option键并单击，则认为它是Double。 

1878
01:24:46,340 --> 01:24:48,760
这些不是双精度浮点数。 

1879
01:24:48,760 --> 01:24:52,810
此Double结构与CGFloat结构不同。 

1880
01:24:52,810 --> 01:24:56,003
因此，我必须明确键入CGFloat。 

1881
01:24:57,140 --> 01:25:01,289
那并不一定是那么繁重或繁重， 

1882
01:25:01,289 --> 01:25:03,640
提醒自己的方式很好

1883
01:25:03,640 --> 01:25:05,802
这些在这里画出常数。 

1884
01:25:06,890 --> 01:25:07,800
让我们做其他的吧。 

1885
01:25:07,800 --> 01:25:10,300
我们得到了edgeLineWidth。 

1886
01:25:10,300 --> 01:25:12,020
我们还有一个常数

1887
01:25:12,020 --> 01:25:15,930
这个数字三，我们当然有这个.75 

1888
01:25:15,930 --> 01:25:18,869
这真的像我们字体的缩放比例。 

1889
01:25:19,069 --> 01:25:21,136
我将其命名为fontScaleFactor 

1890
01:25:22,369 --> 01:25:24,722
这也是CGFloat，0.75。 

1891
01:25:26,470 --> 01:25:28,520
现在我将这些放在这里， 

1892
01:25:28,520 --> 01:25:31,550
我可以用这些替换所有的魔术数字

1893
01:25:31,550 --> 01:25:35,119
这将成为我控制面板上的旋钮。 

1894
01:25:35,119 --> 01:25:35,952
因此，让我们这样做。 

1895
01:25:35,953 --> 01:25:37,083
我们有这个。 

1896
01:25:38,238 --> 01:25:41,282
我要复制并粘贴，使此过程更快一点。 

1897
01:25:42,670 --> 01:25:47,149
在这里，这三个是这里的边缘线

1898
01:25:48,750 --> 01:25:53,693
这里的fontScaleFactor是这个.75。 

1899
01:25:55,100 --> 01:25:55,739
很好

1900
01:25:55,939 --> 01:26:00,460
实际上，这也使这段代码很好看， 

1901
01:26:00,460 --> 01:26:02,210
非常像英语

1902
01:26:02,210 --> 01:26:03,890
试图了解正在发生的事情。 

1903
01:26:03,890 --> 01:26:05,489
但是，您会注意到它的引入

1904
01:26:05,689 --> 01:26:08,019
这里有很多错误。 

1905
01:26:08,020 --> 01:26:09,960
它们实际上都是相同的错误。 

1906
01:26:09,960 --> 01:26:12,770
这是可怕的显式自我点

1907
01:26:12,770 --> 01:26:15,600
使捕获语义明确。 

1908
01:26:15,600 --> 01:26:18,140
我们可以，也许可以解决这个问题

1909
01:26:18,140 --> 01:26:19,909
然后单击此处，然后修复此问题

1910
01:26:20,109 --> 01:26:21,279
然后我单击并修复它， 

1911
01:26:21,279 --> 01:26:23,750
但我要告诉你避免的窍门

1912
01:26:23,750 --> 01:26:28,479
在GeometryReader的这种常见情况下，这个自圆点的东西。 

1913
01:26:28,479 --> 01:26:30,599
因此，每当您执行GeometryReader时， 

1914
01:26:30,600 --> 01:26:32,760
里面的东西总会抱怨

1915
01:26:32,760 --> 01:26:33,880
关于这个自我点。 

1916
01:26:33,880 --> 01:26:35,681
顺便说一句，ForEach也是如此。 

1917
01:26:35,881 --> 01:26:38,889
里面的每样东西都会抱怨自我点。 

1918
01:26:38,890 --> 01:26:40,617
并非每个视图都这样做

1919
01:26:40,617 --> 01:26:43,960
但是这两个确实很常用。 

1920
01:26:43,960 --> 01:26:45,369
我要创建一个功能

1921
01:26:45,369 --> 01:26:50,369
我要称呼它的尺寸CGSize 

1922
01:26:50,801 --> 01:26:52,470
它会归还我的身体， 

1923
01:26:52,470 --> 01:26:55,369
这样就可以像某些视图一样

1924
01:26:55,569 --> 01:26:59,019
我可以使用一些View作为此变量的类型， 

1925
01:26:59,020 --> 01:27:02,680
我可以让一些View作为此函子的返回类型。 

1926
01:27:02,680 --> 01:27:05,693
然后我要把我的身体剪下来， 

1927
01:27:05,693 --> 01:27:09,739
放在这里，然后调用此函数

1928
01:27:09,939 --> 01:27:13,569
在我的GeometryReader中，self.body 

1929
01:27:13,569 --> 01:27:16,382
几何尺寸。 

1930
01:27:18,600 --> 01:27:20,670
这段代码实际上清理得很好。 

1931
01:27:20,869 --> 01:27:22,500
这是很合理的。 

1932
01:27:22,500 --> 01:27:26,149
现在该代码不再嵌入

1933
01:27:26,149 --> 01:27:28,199
在这样的GeometryReader中

1934
01:27:28,199 --> 01:27:30,289
因此您不需要这些自我点。 

1935
01:27:30,289 --> 01:27:31,867
所以我可以摆脱那一个

1936
01:27:31,867 --> 01:27:33,579
还有那个和那个

1937
01:27:33,579 --> 01:27:35,529
所有那些自我点都消失了。 

1938
01:27:35,529 --> 01:27:38,659
更重要的是，我没有通过整个几何

1939
01:27:38,659 --> 01:27:42,630
到这个物体，只是尺寸，几何尺寸var。 

1940
01:27:42,630 --> 01:27:46,529
所以在这里，我不需要说geometry.size。 

1941
01:27:46,729 --> 01:27:50,189
现在这个geometry.size就是size， 

1942
01:27:50,189 --> 01:27:52,489
我传入的这个大小。 

1943
01:27:52,489 --> 01:27:54,889
这样使这段代码看起来更好

1944
01:27:54,890 --> 01:27:57,380
我几乎总是建议， 

1945
01:27:57,380 --> 01:27:59,079
至少接下来的几个月

1946
01:27:59,079 --> 01:28:03,579
直到他们把Swift的自圆点变化放在那里

1947
01:28:03,579 --> 01:28:06,559
因此自点不再引起此问题。 

1948
01:28:06,560 --> 01:28:09,890
这是没有此代码的真正干净的方法

1949
01:28:09,890 --> 01:28:11,300
担心自己的点。 

1950
01:28:11,300 --> 01:28:15,363
您可以在ForEach中为项目做相同的事情

1951
01:28:16,350 --> 01:28:17,869
因为每个人都会造成

1952
01:28:17,869 --> 01:28:20,329
那个自我点问题。 

1953
01:28:20,329 --> 01:28:21,880
我们可以在这里做另一件事。 

1954
01:28:21,880 --> 01:28:23,560
在这里，我可以有一个功能

1955
01:28:23,560 --> 01:28:26,403
对于称为fontSize的字体大小， 

1956
01:28:27,470 --> 01:28:30,829
它返回的字体大小也是CGFloat， 

1957
01:28:30,829 --> 01:28:35,350
并将这段代码放在这里

1958
01:28:35,350 --> 01:28:39,113
这样就可以读取fontSize的大小。 

1959
01:28:40,060 --> 01:28:42,949
您可能会认为这是一个非常简单的表达， 

1960
01:28:43,149 --> 01:28:46,420
我真的不需要在这里将其变成自己的功能， 

1961
01:28:46,420 --> 01:28:50,420
但是同样，您不能使它变得太简单。 

1962
01:28:50,420 --> 01:28:52,699
您真的想让它尽可能简单。 

1963
01:28:52,699 --> 01:28:54,539
有时您不得不使其变得简单。 

1964
01:28:54,539 --> 01:28:56,229
正如我所解释的， 

1965
01:28:56,229 --> 01:28:59,099
不能是任意复杂的表达式。 

1966
01:28:59,100 --> 01:29:00,789
所以有时候这需要一个函数

1967
01:29:00,789 --> 01:29:02,659
返回布尔，在这种情况下， 

1968
01:29:02,659 --> 01:29:04,769
因为这是简单的布尔。 

1969
01:29:04,770 --> 01:29:08,300
但是让这些小班轮发挥作用

1970
01:29:08,300 --> 01:29:13,029
使这个身体看起来更干净，非常普遍。 

1971
01:29:13,029 --> 01:29:14,939
在这里，我们甚至可能没有

1972
01:29:14,939 --> 01:29:19,729
使这个fontScaleFactor成为其自己的单独

1973
01:29:19,729 --> 01:29:21,799
因为您可以考虑字体大小

1974
01:29:21,800 --> 01:29:23,869
作为绘图常量的一部分。 

1975
01:29:23,869 --> 01:29:28,313
这是给定大小的恒定字体大小。 

1976
01:29:29,539 --> 01:29:31,449
这就是第三讲。 

1977
01:29:31,449 --> 01:29:34,260
我们要马上潜回去

1978
01:29:34,260 --> 01:29:36,619
从第四讲开始，并继续进行此演示

1979
01:29:36,819 --> 01:29:40,979
并使我们的HStack成为2D网格。 

1980
01:29:40,979 --> 01:29:44,069
我们将学到很多东西。 

1981
01:29:44,069 --> 01:29:49,069
 -[旁白]有关更多信息，请访问stanford.edu。 

1
00:00:02,330 --> 00:00:04,920
(illuminated music)

2
00:00:04,920 --> 00:00:06,570
- [Narrator] Stanford University.

3
00:00:08,120 --> 00:00:09,800
- [Instructor] Hello
everybody and welcome,

4
00:00:09,800 --> 00:00:13,313
Stanford CS193p Spring of 2020.

5
00:00:13,313 --> 00:00:15,320
This is lecture three.

6
00:00:15,320 --> 00:00:18,315
I'm gonna start today with a demo,

7
00:00:18,315 --> 00:00:22,620
a demo of that reactive SwiftUI
stuff we were talking about.

8
00:00:22,620 --> 00:00:24,970
Then I am gonna jump into some slides,

9
00:00:24,970 --> 00:00:28,270
talk a little bit more
about the Swift type system,

10
00:00:28,270 --> 00:00:31,770
specifically protocols, and then kind of

11
00:00:31,770 --> 00:00:33,620
a totally different topic after that,

12
00:00:33,620 --> 00:00:36,480
which is the layout system for Views,

13
00:00:36,480 --> 00:00:39,840
how they get laid out on screen.

14
00:00:39,840 --> 00:00:42,300
If time permits, I'll
actually do a little demo

15
00:00:42,300 --> 00:00:44,690
of that layout stuff at the end of today,

16
00:00:44,690 --> 00:00:47,120
if not, that'll be pushed to next time.

17
00:00:47,120 --> 00:00:50,890
And next time we're definitely
going to lay out our cards

18
00:00:50,890 --> 00:00:53,320
in rows and columns instead of all

19
00:00:53,320 --> 00:00:55,890
in a horizontal line like they are now.

20
00:00:55,890 --> 00:00:59,090
And we'll also get
started on actually having

21
00:00:59,090 --> 00:01:03,670
our Model play the game and
implementing some of our logic.

22
00:01:03,670 --> 00:01:06,373
But for now, let's do
this reactive Swift demo.

23
00:01:07,290 --> 00:01:11,970
You're all really familiar
now, hopefully, with MVVM,

24
00:01:11,970 --> 00:01:13,410
but before I start with this demo,

25
00:01:13,410 --> 00:01:15,340
I'm gonna take just a quick second

26
00:01:15,340 --> 00:01:18,280
to review it just in case
maybe it's been a few days

27
00:01:18,280 --> 00:01:19,890
since you did your homework.

28
00:01:19,890 --> 00:01:23,360
Here is our Model, it's called MemoryGame.

29
00:01:23,360 --> 00:01:25,430
It has this don't care CardContent

30
00:01:25,430 --> 00:01:26,960
which is what's on the card,

31
00:01:26,960 --> 00:01:29,120
which as a Model we don't care.

32
00:01:29,120 --> 00:01:31,080
That's up to the UI to
decide what it wants

33
00:01:31,080 --> 00:01:34,180
to show on the cards.

34
00:01:34,180 --> 00:01:35,400
Here are our cards.

35
00:01:35,400 --> 00:01:39,350
This is an Array of this
Card struct right down here.

36
00:01:39,350 --> 00:01:43,450
And this choose lets us
essentially play the game.

37
00:01:43,450 --> 00:01:45,310
We haven't implemented any of that yet

38
00:01:45,310 --> 00:01:46,520
but when you choose a card,

39
00:01:46,520 --> 00:01:50,120
that's when the matching
happens and things like that.

40
00:01:50,120 --> 00:01:54,570
And here's how we initialize
or create our MemoryGame.

41
00:01:54,570 --> 00:01:56,110
We obviously wanna specify

42
00:01:56,110 --> 00:01:58,360
how many pairs of cards in our game,

43
00:01:58,360 --> 00:02:01,370
and we need a
cardContentFactory function here

44
00:02:01,370 --> 00:02:03,500
to make the content that's on the card

45
00:02:03,500 --> 00:02:05,570
because for us, it's a don't care.

46
00:02:05,570 --> 00:02:08,853
So somebody who does care
has to make that for us.

47
00:02:09,830 --> 00:02:12,130
And here's our ViewModel.

48
00:02:12,130 --> 00:02:15,670
Our ViewModel has a
var which is the Model.

49
00:02:15,670 --> 00:02:18,830
Our ViewModel can talk
to the Model all at once.

50
00:02:18,830 --> 00:02:22,670
It's a portal or doorway
onto the Model for the View

51
00:02:22,670 --> 00:02:25,020
so it has to be able to do that.

52
00:02:25,020 --> 00:02:29,370
Notice that there are no vars
in here to point to the View.

53
00:02:29,370 --> 00:02:32,690
The ViewModel never talks to its View.

54
00:02:32,690 --> 00:02:35,600
It's the View that talks to the ViewModel.

55
00:02:35,600 --> 00:02:37,827
And we're gonna see how the View

56
00:02:37,827 --> 00:02:41,820
and the ViewModel kind of
Interact in just a moment here,

57
00:02:41,820 --> 00:02:44,270
but there's never gonna
be any connectivity

58
00:02:44,270 --> 00:02:45,970
from the ViewModel to the Views

59
00:02:45,970 --> 00:02:47,890
because many, many different Views

60
00:02:47,890 --> 00:02:50,180
will be using this ViewModel, this portal,

61
00:02:50,180 --> 00:02:52,280
this doorway, onto the Model.

62
00:02:52,280 --> 00:02:54,240
They'll be using it, sharing it.

63
00:02:54,240 --> 00:02:56,710
Again, that's why our
ViewModel is a class.

64
00:02:56,710 --> 00:02:58,710
It's a pointer into something in the heap.

65
00:02:58,710 --> 00:03:01,890
It's easy to share
something that's pointed to.

66
00:03:01,890 --> 00:03:06,400
So our ViewModel also provides
public access to the Model

67
00:03:06,400 --> 00:03:08,710
which is otherwise private.

68
00:03:08,710 --> 00:03:11,250
And that access is both
getting information,

69
00:03:11,250 --> 00:03:12,450
like getting the cards

70
00:03:12,450 --> 00:03:16,410
and also letting the View
express its Intent, in this case,

71
00:03:16,410 --> 00:03:18,480
to choose a card.

72
00:03:18,480 --> 00:03:21,660
Both very easily implemented
by us with our Model

73
00:03:21,660 --> 00:03:24,630
but this is what our ViewModels job is.

74
00:03:24,630 --> 00:03:26,690
And finally we have our View.

75
00:03:26,690 --> 00:03:31,690
We have two Views in our
View in the MVVM View sense.

76
00:03:32,350 --> 00:03:35,080
One is a View that
represents a single card

77
00:03:35,080 --> 00:03:39,210
and then this View, which is
all of our cards combined here.

78
00:03:39,210 --> 00:03:42,380
And based on the feedback that I got

79
00:03:42,380 --> 00:03:43,430
from some of you working

80
00:03:43,430 --> 00:03:44,890
on your homework assignments this week,

81
00:03:44,890 --> 00:03:48,880
I wanna clarify a little bit, our thinking

82
00:03:48,880 --> 00:03:53,020
by clarifying the words
we use to describe things.

83
00:03:53,020 --> 00:03:56,157
A number of you were saying things like,

84
00:03:56,157 --> 00:03:58,027
"Oh, I'm using this function

85
00:03:58,027 --> 00:04:03,027
"to set the font of my card."

86
00:04:03,070 --> 00:04:07,617
And while I guess that's
not exactly not right,

87
00:04:09,480 --> 00:04:11,830
really a better way of saying it is that

88
00:04:11,830 --> 00:04:16,830
this function right here
modifies the View we send it to

89
00:04:17,150 --> 00:04:21,230
so that it uses this font to draw.

90
00:04:21,230 --> 00:04:22,900
And what's the difference there?

91
00:04:22,900 --> 00:04:26,100
Well, it's the difference
between declarative programming

92
00:04:26,100 --> 00:04:28,130
and imperative programming.

93
00:04:28,130 --> 00:04:31,980
In declarative we're just
declaring that this is the font

94
00:04:31,980 --> 00:04:34,910
that is used to draw this View,

95
00:04:34,910 --> 00:04:38,270
whereas in imperative,
you're thinking things like,

96
00:04:38,270 --> 00:04:41,740
I'm calling this function to set the font

97
00:04:41,740 --> 00:04:44,387
at a certain moment in
time, I'm setting it.

98
00:04:44,387 --> 00:04:47,770
And there's no moment in
time with this declarative.

99
00:04:47,770 --> 00:04:51,660
At any moment in time,
this should draw the View

100
00:04:51,660 --> 00:04:53,980
that reflects the Model
and it should be able

101
00:04:53,980 --> 00:04:58,190
to do that any time
this body is requested.

102
00:04:58,190 --> 00:05:00,720
Boom, it should be a View

103
00:05:00,720 --> 00:05:03,000
that reflects the state of the Model,

104
00:05:03,000 --> 00:05:04,603
essentially time insensitive.

105
00:05:05,580 --> 00:05:08,720
One other thing about this
body is that this var,

106
00:05:08,720 --> 00:05:11,850
you never access this var.

107
00:05:11,850 --> 00:05:15,480
This lower body is never
gonna appear in your code.

108
00:05:15,480 --> 00:05:18,830
This body is called by the system.

109
00:05:18,830 --> 00:05:20,640
Every time the system wants

110
00:05:20,640 --> 00:05:24,640
to draw a View of the
Model that this represents,

111
00:05:24,640 --> 00:05:28,130
it will call this var to get that View.

112
00:05:28,130 --> 00:05:29,660
So this is called by the system.

113
00:05:29,660 --> 00:05:33,650
Your job is to implement it by declaring

114
00:05:33,650 --> 00:05:36,703
what the View is given the
current state of the Model

115
00:05:36,703 --> 00:05:40,530
that you see through this
portal, the ViewModel.

116
00:05:40,530 --> 00:05:42,800
And the last thing I wanna talk about is

117
00:05:42,800 --> 00:05:46,920
some people were inside
these ViewBuilders,

118
00:05:46,920 --> 00:05:51,560
like in ForEach or even
inside ZStack or HStack.

119
00:05:51,560 --> 00:05:54,860
Remember these are ViewBuilders
and ViewBuilders are cool

120
00:05:54,860 --> 00:05:57,810
because they're functions
that return a View

121
00:05:57,810 --> 00:06:00,340
and they do allow this limited if then

122
00:06:00,340 --> 00:06:03,410
and they allow you to just
list Views instead of having

123
00:06:03,410 --> 00:06:06,177
to put them in an Array or
something, you can list them.

124
00:06:06,177 --> 00:06:08,800
People were wanting to put a var here,

125
00:06:08,800 --> 00:06:11,320
var x equals something down here.

126
00:06:11,320 --> 00:06:13,210
And of course you cannot create vars

127
00:06:13,210 --> 00:06:14,593
inside the ViewBuilder.

128
00:06:15,440 --> 00:06:19,270
Vars can not be created
inside these ViewBuilders,

129
00:06:19,270 --> 00:06:21,570
just not allowed to create vars.

130
00:06:21,570 --> 00:06:22,740
So how do you do it?

131
00:06:22,740 --> 00:06:23,970
There's two ways to do it.

132
00:06:23,970 --> 00:06:27,060
One, you can put vars
outside the ViewBuilders,

133
00:06:27,060 --> 00:06:29,330
just in your normal function,

134
00:06:29,330 --> 00:06:33,000
and then I could use x inside here.

135
00:06:33,000 --> 00:06:34,270
But of course if I do that now,

136
00:06:34,270 --> 00:06:35,520
I've created this two line,

137
00:06:35,520 --> 00:06:38,340
I'll have to say return ZStack,

138
00:06:38,340 --> 00:06:40,660
but that's okay, I could do that.

139
00:06:40,660 --> 00:06:42,930
Another way, and probably
a more common way,

140
00:06:42,930 --> 00:06:46,980
is to create another, let's
say this wants to be an Int,

141
00:06:46,980 --> 00:06:49,780
computed property, and
just return whatever

142
00:06:49,780 --> 00:06:51,220
the value you want x to be

143
00:06:51,220 --> 00:06:52,740
and now you can use x in here.

144
00:06:52,740 --> 00:06:55,520
And it's just going to
use this computed property

145
00:06:55,520 --> 00:06:58,290
to calculate the value of x that it wants.

146
00:06:58,290 --> 00:07:00,160
So that's the way we deal

147
00:07:00,160 --> 00:07:03,710
with essentially creating local variables

148
00:07:03,710 --> 00:07:08,710
or variables that we need
to do our drawing in here.

149
00:07:09,030 --> 00:07:12,450
And this is currently called
ContentView, by the way,

150
00:07:12,450 --> 00:07:15,110
because that's the where we started

151
00:07:15,110 --> 00:07:17,286
with that template from Xcode.

152
00:07:17,286 --> 00:07:20,610
Xcode didn't know we were
doing a memory game at the time

153
00:07:20,610 --> 00:07:22,510
so it called it ContentView.

154
00:07:22,510 --> 00:07:23,780
Thought before we started,

155
00:07:23,780 --> 00:07:25,940
I would show you how we could rename that

156
00:07:25,940 --> 00:07:29,110
to be a much better name.

157
00:07:29,110 --> 00:07:31,790
Now you might be tempted
to do this in the navigator

158
00:07:31,790 --> 00:07:35,830
with the search and replace feature here.

159
00:07:35,830 --> 00:07:38,200
And you can do that by
going here to replace,

160
00:07:38,200 --> 00:07:40,980
and then you could search,
for example, for ContentView

161
00:07:42,758 --> 00:07:44,970
and it would find all the
places it's referenced,

162
00:07:44,970 --> 00:07:46,000
then you could replace it

163
00:07:46,000 --> 00:07:48,927
with something like EmojiMemoryGameView

164
00:07:49,830 --> 00:07:51,340
or something like that.

165
00:07:51,340 --> 00:07:54,670
But actually, this is
not how we would do this.

166
00:07:54,670 --> 00:07:58,500
If we're gonna change the
name of a var or of a type,

167
00:07:58,500 --> 00:08:01,030
we are gonna use refactoring.

168
00:08:01,030 --> 00:08:03,330
So the way we do that
is we're gonna hold down

169
00:08:03,330 --> 00:08:07,092
the Command key, Command + click.

170
00:08:07,092 --> 00:08:09,330
And when we Command + click,
we get this nice menu here

171
00:08:09,330 --> 00:08:11,200
where we can jump to the definition

172
00:08:11,200 --> 00:08:14,340
of a type or a var or something.

173
00:08:14,340 --> 00:08:15,613
We can also rename.

174
00:08:16,454 --> 00:08:19,930
So we do that Command + click,
and we're gonna go rename.

175
00:08:19,930 --> 00:08:22,290
And it's showing us here all the places

176
00:08:22,290 --> 00:08:24,200
that it found ContentView,

177
00:08:24,200 --> 00:08:27,010
essentially the same thing as
we did the search over here.

178
00:08:27,010 --> 00:08:28,550
Some of them is gonna change,

179
00:08:28,550 --> 00:08:31,320
and you can tell with
this little check mark,

180
00:08:31,320 --> 00:08:32,780
thing's just gonna change.

181
00:08:32,780 --> 00:08:35,850
So it's going to change this file name,

182
00:08:35,850 --> 00:08:38,010
so it's gonna change the
name of that, that's good.

183
00:08:38,010 --> 00:08:41,540
Here it's showing the comment ContentView

184
00:08:41,540 --> 00:08:42,860
but it's not gonna change that.

185
00:08:42,860 --> 00:08:44,730
You see it's not blue, it's gray.

186
00:08:44,730 --> 00:08:46,020
It's just saying, I found this,

187
00:08:46,020 --> 00:08:48,530
but I'm not gonna change
that 'cause I'm not sure

188
00:08:48,530 --> 00:08:50,710
that that's really referring to this type

189
00:08:50,710 --> 00:08:51,750
since it's in a comment.

190
00:08:51,750 --> 00:08:54,220
So we'll have to change that ourselves.

191
00:08:54,220 --> 00:08:57,100
It's gonna change down
here this var preViews.

192
00:08:57,100 --> 00:08:59,890
That was actually that code
we scrolled out of the way

193
00:08:59,890 --> 00:09:03,260
at the very beginning
that shows our ContentView

194
00:09:03,260 --> 00:09:05,590
in the gray preView window over here,

195
00:09:05,590 --> 00:09:07,570
so that obviously would
need to be changed.

196
00:09:07,570 --> 00:09:10,140
And then here's the code
in the scene delegate

197
00:09:10,140 --> 00:09:12,730
where we're actually
creating our memory game

198
00:09:12,730 --> 00:09:16,850
and then passing it into
this top level ContentView.

199
00:09:16,850 --> 00:09:20,120
So when you do this
Command + click and rename,

200
00:09:20,120 --> 00:09:23,220
it actually selects what
you Command + clicked on

201
00:09:23,220 --> 00:09:24,740
and you can just type something new.

202
00:09:24,740 --> 00:09:29,740
So EmojiMemoryGameView,
and see, it's changing it

203
00:09:30,340 --> 00:09:32,840
in all the other places, not here though.

204
00:09:32,840 --> 00:09:33,673
And that's it.

205
00:09:33,673 --> 00:09:35,800
So you just hit this rename right here

206
00:09:35,800 --> 00:09:37,400
and it has renamed it, even the name

207
00:09:37,400 --> 00:09:40,400
of the file over here is nicely renamed.

208
00:09:40,400 --> 00:09:43,070
And we can go back and fix the things

209
00:09:43,070 --> 00:09:46,210
that it wasn't sure about,
things like comments right here,

210
00:09:46,210 --> 00:09:50,980
say, this is our EmojiMemoryGameView.swift

211
00:09:50,980 --> 00:09:53,670
which in fact is the name of this file.

212
00:09:53,670 --> 00:09:56,510
So that was just a
little aside for renaming

213
00:09:56,510 --> 00:09:59,290
'cause sometimes you'll pick
a name for a type or a var

214
00:09:59,290 --> 00:10:00,640
and then you'll decide,

215
00:09:59,290 --> 00:10:00,640
and then you'll decide,

216
00:10:00,640 --> 00:10:02,360
I don't really like that name, it's not,

217
00:10:02,360 --> 00:10:05,190
because naming is really,
really, really important.

218
00:10:05,190 --> 00:10:06,930
Can't overemphasize how important it is

219
00:10:06,930 --> 00:10:08,880
to pick good names for things.

220
00:10:08,880 --> 00:10:11,880
So being able to rename
after you change your mind,

221
00:10:11,880 --> 00:10:13,410
really, really important.

222
00:10:13,410 --> 00:10:17,450
Our topic today though is
going to be this reactive.

223
00:10:17,450 --> 00:10:19,690
I told you that SwiftUI is reactive.

224
00:10:19,690 --> 00:10:21,930
What do I mean by reactive?

225
00:10:21,930 --> 00:10:24,130
I mean that when changes
happen in the Model,

226
00:10:24,130 --> 00:10:28,430
they automatically are going
to show up in the View.

227
00:10:28,430 --> 00:10:32,270
And currently our UI is not reactive.

228
00:10:32,270 --> 00:10:33,780
So that's a problem.

229
00:10:33,780 --> 00:10:37,150
And let's take a look and see
how we can fix that problem

230
00:10:37,150 --> 00:10:38,820
and make it so it is reactive.

231
00:10:38,820 --> 00:10:42,810
We're not gonna implement
our entire memory game here

232
00:10:42,810 --> 00:10:44,060
with all the Card matching.

233
00:10:44,060 --> 00:10:45,880
We're just gonna take a baby step forward

234
00:10:45,880 --> 00:10:48,620
which is we're gonna
make the cards flip over.

235
00:10:48,620 --> 00:10:50,960
That's part of our Model.

236
00:10:50,960 --> 00:10:54,820
Essentially the first
step of our game logic is

237
00:10:54,820 --> 00:10:57,220
to have a card, when we
choose it, flip over.

238
00:10:57,220 --> 00:10:59,780
So I've moved over here to my Model code

239
00:10:59,780 --> 00:11:03,320
where currently we just say card chosen

240
00:11:03,320 --> 00:11:04,880
remember that from last time.

241
00:11:04,880 --> 00:11:07,890
Now I wanna start actually
implementing my game logic

242
00:11:07,890 --> 00:11:09,773
starting with flipping the card over.

243
00:11:11,030 --> 00:11:14,570
Now you'll look at this and
you'll think, oh, this is easy.

244
00:11:14,570 --> 00:11:19,570
Card.isFaceUp equals
!card.isFaceUp, right?

245
00:11:20,790 --> 00:11:22,930
Somebody is passing us the card

246
00:11:22,930 --> 00:11:25,010
they wanna choose as an argument

247
00:11:25,010 --> 00:11:28,620
and I'm just going to have
this face upness of it

248
00:11:28,620 --> 00:11:32,720
be toggled or flipped
to its opposite here.

249
00:11:32,720 --> 00:11:36,067
And this has an error which is that

250
00:11:36,067 --> 00:11:39,260
"Cannot assign to property.
'Card' is a 'let' constant."

251
00:11:39,260 --> 00:11:42,310
Which it is all arguments

252
00:11:42,310 --> 00:11:44,810
to functions are essentially let.

253
00:11:44,810 --> 00:11:47,070
You don't type that
let, but they are a let.

254
00:11:47,070 --> 00:11:49,220
So that's one problem.

255
00:11:49,220 --> 00:11:51,760
But it's actually much,
much worse than that.

256
00:11:51,760 --> 00:11:54,850
It's not just that this is a let.

257
00:11:54,850 --> 00:11:56,850
This is a Card.

258
00:11:56,850 --> 00:11:58,770
A Card is a struct.

259
00:11:58,770 --> 00:12:03,770
Structs are value types as
we talked about last time.

260
00:12:04,480 --> 00:12:07,860
And a value type, remember, is copied

261
00:12:07,860 --> 00:12:10,380
every time it's passed as
a parameter to a function

262
00:12:10,380 --> 00:12:13,410
or even assigned to another
variable copy, copy, copy.

263
00:12:13,410 --> 00:12:14,950
It's always being copied.

264
00:12:14,950 --> 00:12:19,790
So this Card here is a copy
of one of the Cards here.

265
00:12:19,790 --> 00:12:24,170
The new ViewModel got it
or hand it out to a View

266
00:12:24,170 --> 00:12:26,630
and when the View, got it, it was a copy,

267
00:12:26,630 --> 00:12:28,430
maybe even a copy of a copy.

268
00:12:28,430 --> 00:12:31,820
So this is not actually a
Card that's in the Array,

269
00:12:31,820 --> 00:12:33,800
it's a copy of that.

270
00:12:33,800 --> 00:12:37,820
Every time we pass a value
type, it gets copied.

271
00:12:37,820 --> 00:12:39,570
So even if we could do this,

272
00:12:39,570 --> 00:12:41,310
which we can't because of that problem

273
00:12:41,310 --> 00:12:43,740
where this is all essentially a let,

274
00:12:43,740 --> 00:12:45,500
it wouldn't be doing
the right thing anyway.

275
00:12:45,500 --> 00:12:48,020
This would just be changing this guy

276
00:12:48,020 --> 00:12:51,550
to its space up to be
swapped is having no effect

277
00:12:51,550 --> 00:12:53,310
on this one right here.

278
00:12:53,310 --> 00:12:55,820
So let's try something
totally different here.

279
00:12:55,820 --> 00:12:59,530
Let's try and find out the index of

280
00:12:59,530 --> 00:13:03,377
which Card in this
Array that this card is.

281
00:13:03,377 --> 00:13:06,720
I'm gonna do that by
saying let chosenIndex,

282
00:13:06,720 --> 00:13:08,800
which is gonna be a type Int,

283
00:13:08,800 --> 00:13:12,430
I'm gonna equal to, I'm gonna
call a function on myself,

284
00:13:12,430 --> 00:13:15,330
index of that card.

285
00:13:15,330 --> 00:13:18,109
So index of I'm gonna write a function,

286
00:13:18,109 --> 00:13:21,090
it's gonna be a function
in myself of this card.

287
00:13:21,090 --> 00:13:22,990
So I'm gonna find this card,

288
00:13:22,990 --> 00:13:25,612
find out what index it is in this Array.

289
00:13:25,612 --> 00:13:29,680
So you have func index of
which is gonna be a type Card,

290
00:13:29,680 --> 00:13:33,260
it's gonna return an Int,
and this Int is going

291
00:13:33,260 --> 00:13:35,910
to be the index into this Array.

292
00:13:35,910 --> 00:13:39,320
Now maybe I would say let chosenCard,

293
00:13:39,320 --> 00:13:41,230
which is gonna be a type Card,

294
00:13:41,230 --> 00:13:46,173
equal my cards at that chosenIndex.

295
00:13:47,150 --> 00:13:47,990
It sounds good.

296
00:13:47,990 --> 00:13:51,129
Now I can say now let's
flip the card over,

297
00:13:51,129 --> 00:13:55,063
isFaceUp equals !chosenCard.isFaceUp.

298
00:13:59,070 --> 00:14:01,320
So this seems like this is a good idea,

299
00:14:01,320 --> 00:14:02,930
we'll have to implement this in a minute,

300
00:14:02,930 --> 00:14:04,870
but this seems like this will be great.

301
00:14:04,870 --> 00:14:08,480
Now, we are getting a
Card out of the Array

302
00:14:08,480 --> 00:14:10,740
and we're flipping it over.

303
00:14:10,740 --> 00:14:15,480
But this too is not gonna work
for exactly the same reason.

304
00:14:15,480 --> 00:14:20,330
When we make an assignment
to a var, this chosen Card,

305
00:14:20,330 --> 00:14:24,970
this equals copies this out of here.

306
00:14:24,970 --> 00:14:27,640
It copies the Card out of the Array.

307
00:14:27,640 --> 00:14:29,990
So even just making an assignment

308
00:14:29,990 --> 00:14:34,520
to another variable copies a value type.

309
00:14:34,520 --> 00:14:35,920
So now you're probably like, well,

310
00:14:35,920 --> 00:14:38,580
how are we gonna change this thing?

311
00:14:38,580 --> 00:14:41,090
Well, we have to change it in place.

312
00:14:41,090 --> 00:14:44,610
Instead of changing a
copy of this thing here,

313
00:14:44,610 --> 00:14:46,900
we're going to change this Array itself,

314
00:14:46,900 --> 00:14:49,780
this Array of Cards, we're
going to reach in there

315
00:14:49,780 --> 00:14:52,340
and change whichever is the right Card

316
00:14:52,340 --> 00:14:53,947
to be the different FaceUp.

317
00:14:55,010 --> 00:14:56,210
So we're gonna do that.

318
00:14:56,210 --> 00:15:00,680
Still going do self.cards chosenIndex,

319
00:15:00,680 --> 00:15:02,190
but instead of this indirection

320
00:15:02,190 --> 00:15:04,000
through a var that would copy it,

321
00:15:04,000 --> 00:15:06,800
I'm just going to have that thing directly

322
00:15:06,800 --> 00:15:11,513
is FaceUp equal not that
thing directly isFaceUp.

323
00:15:13,182 --> 00:15:14,780
So I'm just gonna flip the Card over

324
00:15:14,780 --> 00:15:16,870
directly inside the Array.

325
00:15:16,870 --> 00:15:18,940
A couple of things going on here.

326
00:15:18,940 --> 00:15:21,680
One, notice I'm putting self dot

327
00:15:21,680 --> 00:15:25,720
in front of every access to my variables

328
00:15:25,720 --> 00:15:28,840
and to functions I'm calling on myself.

329
00:15:28,840 --> 00:15:33,390
This self dot is optional in
the vast majority of cases.

330
00:15:33,390 --> 00:15:36,403
And normally I would even
say, don't put it there.

331
00:15:36,403 --> 00:15:39,420
It's just extra prompt.

332
00:15:39,420 --> 00:15:42,960
However, because of this
thing I talked about last time

333
00:15:42,960 --> 00:15:44,570
where they're going to make it,

334
00:15:44,570 --> 00:15:47,590
so even in the few cases
where you do need a self dot,

335
00:15:47,590 --> 00:15:51,150
like here, self dot is
actually required in our View

336
00:15:51,150 --> 00:15:53,440
when we did our tap
gesture, this self dot,

337
00:15:53,440 --> 00:15:55,800
if you take this away,
it's gonna have an error,

338
00:15:55,800 --> 00:15:58,960
you have to fix it, remember that?

339
00:15:58,960 --> 00:16:00,650
So they're gonna take this away.

340
00:16:00,650 --> 00:16:02,200
And when they take that away,

341
00:16:02,200 --> 00:16:04,980
then you're gonna need
self dot almost nowhere.

342
00:16:04,980 --> 00:16:06,410
So at that point,

343
00:16:06,410 --> 00:16:10,870
I don't know if that's two
months from now, it's not clear,

344
00:16:10,870 --> 00:16:13,100
WWDC is at the beginning of June.

345
00:16:13,100 --> 00:16:15,670
A lot of times they'll
come out with new software,

346
00:16:15,670 --> 00:16:17,860
beta software, at least at that point,

347
00:16:17,860 --> 00:16:19,420
maybe they'll fix it then, I don't know.

348
00:16:19,420 --> 00:16:20,490
I don't work at Apple,

349
00:16:20,490 --> 00:16:23,000
I don't know anything
what their plans are,

350
00:16:23,000 --> 00:16:26,040
but we do know that it's
been publicly approved

351
00:16:26,040 --> 00:16:28,000
to get rid of this self dot.

352
00:16:28,000 --> 00:16:29,360
So in this course,

353
00:16:29,360 --> 00:16:34,150
just for the next seven or
eight weeks left in this course,

354
00:16:34,150 --> 00:16:36,550
I kind of recommend maybe
just putting self dot

355
00:16:36,550 --> 00:16:39,510
in front of everything because
it doesn't hurt anything

356
00:16:39,510 --> 00:16:42,090
and it'll keep you from
running into this problem

357
00:16:42,090 --> 00:16:43,953
where you have to do the fix it.

358
00:16:44,930 --> 00:16:47,270
You're just learning this stuff

359
00:16:47,270 --> 00:16:50,530
and that's going to kind of
give you the muscle memory

360
00:16:50,530 --> 00:16:52,210
of always typing self dot

361
00:16:52,210 --> 00:16:54,600
which you'll have to train yourself out of

362
00:16:54,600 --> 00:16:59,350
in a couple of months when
this public fix comes out.

363
00:16:59,350 --> 00:17:01,660
But it'll keep you out of
trouble in this quarter.

364
00:17:01,660 --> 00:17:03,530
So that's my recommendation

365
00:17:03,530 --> 00:17:06,450
but in your homework, we're not going say,

366
00:17:06,450 --> 00:17:08,140
oh, that's wrong, you put self dot,

367
00:17:08,140 --> 00:17:09,887
or oh, that's wrong,
you didn't put self dot.

368
00:17:09,887 --> 00:17:11,940
That's totally up to you.

369
00:17:11,940 --> 00:17:15,340
I'm just trying to head off
possible problems for you.

370
00:17:15,340 --> 00:17:19,303
So go for self dot is
probably my recommendation.

371
00:17:21,834 --> 00:17:24,090
But what is in here?

372
00:17:24,090 --> 00:17:26,940
And we were sure this was gonna work.

373
00:17:26,940 --> 00:17:30,630
We're for sure changing
isFaceUp and that Array,

374
00:17:30,630 --> 00:17:33,820
there is no doubt
self.cards of chosenIndex.

375
00:17:33,820 --> 00:17:38,810
We are changing this Array to
have it isFaceUp be toggled,

376
00:17:38,810 --> 00:17:40,837
and yet we still have an error here,

377
00:17:40,837 --> 00:17:45,270
"Cannot assign to property:
'self' is immutable."

378
00:17:45,270 --> 00:17:48,310
It's not saying that
this cards is immutable

379
00:17:48,310 --> 00:17:50,910
because the cards is not, it's a var.

380
00:17:50,910 --> 00:17:53,040
If it were a let, it would be immutable,

381
00:17:53,040 --> 00:17:55,100
but it's a var so it's mutable,

382
00:17:55,100 --> 00:17:59,770
but its self itself that is immutable.

383
00:17:59,770 --> 00:18:02,670
In other words, our own
function doesn't seem

384
00:18:02,670 --> 00:18:06,473
to be able to modify our self.

385
00:18:07,680 --> 00:18:10,730
How do we do anything
then if we can't do that?

386
00:18:10,730 --> 00:18:13,830
Well, what's going on here is that

387
00:18:13,830 --> 00:18:16,470
I told you these value types,

388
00:18:16,470 --> 00:18:19,070
Swift is not doing a bitwise copy,

389
00:18:19,070 --> 00:18:21,020
it's not actually copying them

390
00:18:21,020 --> 00:18:23,980
from one place in memory to another

391
00:18:23,980 --> 00:18:25,930
when you pass them around.

392
00:18:25,930 --> 00:18:27,170
That's the semantic,

393
00:18:27,170 --> 00:18:29,610
that's how you have to
imagine it's happening,

394
00:18:29,610 --> 00:18:33,120
but it's really only actually
making those copies in memory

395
00:18:33,120 --> 00:18:36,880
when you start changing something
which we are doing here.

396
00:18:36,880 --> 00:18:41,880
We are changing this Array and
this is our actual property,

397
00:18:42,380 --> 00:18:43,660
so we're not making a copy,

398
00:18:43,660 --> 00:18:45,220
it's actually changing the Array,

399
00:18:45,220 --> 00:18:49,740
but this method changes our self.

400
00:18:49,740 --> 00:18:52,920
It modifies our self because
it changes our cards.

401
00:18:52,920 --> 00:18:55,530
So we have to let Swift
know that by saying

402
00:18:55,530 --> 00:18:58,170
that this is a mutating function.

403
00:18:58,170 --> 00:19:01,630
So all functions that modify self

404
00:19:01,630 --> 00:19:04,580
have to be marked mutating in a struct.

405
00:19:04,580 --> 00:19:06,370
This is not true in a class.

406
00:19:06,370 --> 00:19:08,230
Classes are in the heap.

407
00:19:08,230 --> 00:19:09,400
We have pointers to them.

408
00:19:09,400 --> 00:19:12,050
We can always change things
that are in the heap,

409
00:19:12,050 --> 00:19:14,870
always modify things through a pointer,

410
00:19:14,870 --> 00:19:16,590
which, as I talked about before,

411
00:19:16,590 --> 00:19:19,660
can be a bad thing just
as much as a good thing.

412
00:19:19,660 --> 00:19:21,790
But for structs, no,
because they're value types

413
00:19:21,790 --> 00:19:25,110
we have to let Swift
know we're changing this.

414
00:19:25,110 --> 00:19:28,090
Now, index of, which we're
gonna write in a second here,

415
00:19:28,090 --> 00:19:31,960
it's just getting the index
of a Card in this Array.

416
00:19:31,960 --> 00:19:33,580
It's not actually changing anything.

417
00:19:33,580 --> 00:19:34,840
It's just getting the index.

418
00:19:34,840 --> 00:19:38,240
So it does not need or want mutating here.

419
00:19:38,240 --> 00:19:41,380
And similarly or inversely,

420
00:19:41,380 --> 00:19:45,380
our initializer is
implicitly changing our self.

421
00:19:45,380 --> 00:19:46,610
We're creating our self.

422
00:19:46,610 --> 00:19:49,470
We're setting all of our variables here.

423
00:19:49,470 --> 00:19:51,320
So of course this is mutating,

424
00:19:51,320 --> 00:19:53,340
so you don't say mutating in it.

425
00:19:53,340 --> 00:19:55,490
All inits are mutating.

426
00:19:55,490 --> 00:19:59,630
It's all part of the cool
feature of value types

427
00:19:59,630 --> 00:20:01,980
that Swift knows when they're changing.

428
00:19:59,630 --> 00:20:01,980
that Swift knows when they're changing.

429
00:20:01,980 --> 00:20:03,293
And you're gonna see that

430
00:20:03,293 --> 00:20:07,160
that has other benefits
other than just this copy

431
00:20:07,160 --> 00:20:10,023
on right behavior as
we copy things around.

432
00:20:11,150 --> 00:20:13,960
Index of Card, how are
we going to find out

433
00:20:13,960 --> 00:20:17,340
where this Card that
we're getting the index of

434
00:20:17,340 --> 00:20:18,540
is in this Array?

435
00:20:18,540 --> 00:20:22,160
We want the index into this
Array that has this Card.

436
00:20:22,160 --> 00:20:24,790
This turns out to be super easy for us

437
00:20:24,790 --> 00:20:28,730
because Card is Identifiable.

438
00:20:28,730 --> 00:20:31,920
And since it's Identifiable,
we can just look at its ID

439
00:20:31,920 --> 00:20:34,820
and uniquely see which Card it is.

440
00:20:34,820 --> 00:20:37,240
So we just need to do
a little for loop here

441
00:20:37,240 --> 00:20:42,240
for index in zero dot dot
less than our cards count,

442
00:20:42,250 --> 00:20:44,310
or again, if we're doing self dot,

443
00:20:44,310 --> 00:20:47,073
self.cards.count, either way.

444
00:20:48,592 --> 00:20:49,710
I'm just gonna go through every one

445
00:20:49,710 --> 00:20:52,250
and I'm gonna say if self dot cards

446
00:20:52,250 --> 00:20:56,720
at that index id equals

447
00:20:56,720 --> 00:20:59,083
this thing right here,

448
00:20:59,920 --> 00:21:04,920
two equals, by the way,
of I guess, dot id,

449
00:21:04,930 --> 00:21:07,880
then I can return this
index 'cause I found it.

450
00:21:07,880 --> 00:21:09,730
Here I'm looking at my Array

451
00:21:09,730 --> 00:21:12,690
to see if the index if
the Card at that index,

452
00:21:12,690 --> 00:21:16,030
it's id is the same as
this one you passed.

453
00:21:16,030 --> 00:21:20,823
Now, you can already see a
problem here of really of.

454
00:21:21,680 --> 00:21:24,030
we're gonna call this variable of, no.

455
00:21:24,030 --> 00:21:25,910
We don't wanna call this of.

456
00:21:25,910 --> 00:21:27,770
Of is just something that makes it nice

457
00:21:27,770 --> 00:21:31,590
for people who call us to
say self index of card.

458
00:21:31,590 --> 00:21:36,590
That's why we have this dual labeling

459
00:21:36,790 --> 00:21:39,367
of external name, internal name.

460
00:21:39,367 --> 00:21:43,320
And that allows us to
call this card dot id

461
00:21:43,320 --> 00:21:47,340
but callers still get
to say index of card.

462
00:21:47,340 --> 00:21:48,870
This is a great example hopefully,

463
00:21:48,870 --> 00:21:51,477
totally see why we have external names

464
00:21:51,477 --> 00:21:54,110
and internal names of arguments.

465
00:21:54,110 --> 00:21:55,690
We didn't do it here.

466
00:21:55,690 --> 00:21:58,600
The external name and the
internal name are the same.

467
00:21:58,600 --> 00:22:00,010
There's kind of an argument here

468
00:22:00,010 --> 00:22:03,170
you might actually put the
under bar here on choose

469
00:22:03,170 --> 00:22:05,850
because it's clear that
we're choosing a Card

470
00:22:05,850 --> 00:22:07,630
that's the type of this argument,

471
00:22:07,630 --> 00:22:09,800
what else would we choose anyway?

472
00:22:09,800 --> 00:22:11,730
But I'm gonna leave it this
way just so we don't have

473
00:22:11,730 --> 00:22:12,820
to change our other code.

474
00:22:12,820 --> 00:22:15,080
But if you read the guidelines

475
00:22:15,080 --> 00:22:16,400
as part of your homework last week,

476
00:22:16,400 --> 00:22:17,820
you'll see that this is one

477
00:22:17,820 --> 00:22:20,200
where maybe an under bar would be there

478
00:22:20,200 --> 00:22:22,700
and then people would just take choose

479
00:22:22,700 --> 00:22:24,390
and provide the Card is the argument,

480
00:22:24,390 --> 00:22:26,930
there would be no label for the callers.

481
00:22:26,930 --> 00:22:30,070
We've done our for loop, we've found this.

482
00:22:30,070 --> 00:22:31,517
What's still complaining here?

483
00:22:31,517 --> 00:22:35,350
"Missing return in a function
expected return Int."

484
00:22:35,350 --> 00:22:38,780
Oh yeah, what if this for
loop goes all the way through

485
00:22:38,780 --> 00:22:41,330
and never finds that Card?

486
00:22:41,330 --> 00:22:44,143
Then we've gotta return something here.

487
00:22:45,040 --> 00:22:48,580
So Swift actually has a fantastic thing

488
00:22:48,580 --> 00:22:51,220
to return here when this happens,

489
00:22:51,220 --> 00:22:54,200
like you go to find
something, you can't find it.

490
00:22:54,200 --> 00:22:57,880
In other languages, you'd
probably return minus one

491
00:22:57,880 --> 00:23:01,320
or some bogus thing here.

492
00:23:01,320 --> 00:23:04,350
I guess I'll return,
maybe you'd return zero

493
00:23:04,350 --> 00:23:07,007
which is the first element
which is totally wrong.

494
00:23:07,007 --> 00:23:09,290
If you go look for the
Card and you can't find it,

495
00:23:09,290 --> 00:23:11,150
you're gonna say, well,
return the first Card

496
00:23:11,150 --> 00:23:13,580
even though you know that's not the Card.

497
00:23:13,580 --> 00:23:16,600
So it doesn't really matter
what we'll return here for now

498
00:23:16,600 --> 00:23:18,330
because this is all just wrong.

499
00:23:18,330 --> 00:23:19,770
But I am gonna put a little thing

500
00:23:19,770 --> 00:23:23,860
called a TODO here, and say bogus.

501
00:23:23,860 --> 00:23:26,700
And a TODO is something
you can go back later,

502
00:23:26,700 --> 00:23:30,190
slash slash TODO, and
find to remind yourself

503
00:23:30,190 --> 00:23:31,690
you need to fix this.

504
00:23:31,690 --> 00:23:34,350
And these show up up here along the top

505
00:23:34,350 --> 00:23:35,350
where it says index up.

506
00:23:35,350 --> 00:23:38,660
If you click, this is a list
of all my vars and funcs,

507
00:23:38,660 --> 00:23:40,440
look bogus is right there.

508
00:23:40,440 --> 00:23:42,720
And if I click on it, it
takes me right to bogus.

509
00:23:42,720 --> 00:23:46,160
And we will come back when
I show you this cool way

510
00:23:46,160 --> 00:23:47,630
that you can return things

511
00:23:47,630 --> 00:23:50,150
like I couldn't find it from Swift.

512
00:23:50,150 --> 00:23:52,560
We're gonna cover that
probably next lecture

513
00:23:52,560 --> 00:23:54,227
and we'll fix this, we'll fix this.

514
00:23:54,227 --> 00:23:57,460
But for now, we're gonna do
this bogus thing right here.

515
00:23:57,460 --> 00:23:59,250
So we have index of card.

516
00:23:59,250 --> 00:24:02,010
We are definitely flipping
the Card over here.

517
00:24:02,010 --> 00:24:05,250
So let's run and see if this is working.

518
00:24:05,250 --> 00:24:07,370
'cause we know we already
have this hooked up

519
00:24:07,370 --> 00:24:08,720
to choose the Card there.

520
00:24:08,720 --> 00:24:10,880
So now it should choose, say card chosen,

521
00:24:10,880 --> 00:24:13,070
and also flip it over, there we go.

522
00:24:13,070 --> 00:24:14,830
Ready, ghost.

523
00:24:14,830 --> 00:24:17,053
Oh pumpkin.

524
00:24:18,410 --> 00:24:21,810
Well it's definitely
accessing the Model here

525
00:24:21,810 --> 00:24:24,240
because we're getting this Card chosen.

526
00:24:24,240 --> 00:24:26,850
But how come these cards
are staying face up?

527
00:24:26,850 --> 00:24:29,080
What is going on here?

528
00:24:29,080 --> 00:24:30,870
Well, what's going on here is

529
00:24:30,870 --> 00:24:33,630
we haven't implemented the reactive thing.

530
00:24:33,630 --> 00:24:35,400
I told you at the start of this

531
00:24:35,400 --> 00:24:38,850
that's why we're here today
is to do this reactive thing.

532
00:24:38,850 --> 00:24:41,280
And you can see why we need the reactive.

533
00:24:41,280 --> 00:24:45,290
We chose a card, it went
here and changed the Model,

534
00:24:45,290 --> 00:24:47,220
it flipped a Card over

535
00:24:47,220 --> 00:24:49,760
and yet we didn't see anything in the UI.

536
00:24:49,760 --> 00:24:53,370
And never should that be
the case in SwiftUI ever.

537
00:24:53,370 --> 00:24:57,260
When you change the Model,
the UI should update.

538
00:24:57,260 --> 00:24:59,660
How do we make that happen?

539
00:24:59,660 --> 00:25:02,510
If you remember from my MVVM slides,

540
00:25:02,510 --> 00:25:06,090
I put some keywords on the
screen there and I said,

541
00:25:06,090 --> 00:25:08,900
these Swift key words,
we're going to use those

542
00:25:08,900 --> 00:25:10,810
to do this reactive and that's exactly

543
00:25:10,810 --> 00:25:12,450
what we're gonna do right now.

544
00:25:12,450 --> 00:25:14,760
And we're gonna start in our ViewModel.

545
00:25:14,760 --> 00:25:17,200
So here's our ViewModel.

546
00:25:17,200 --> 00:25:20,610
And the way we make the
ViewModel participate

547
00:25:20,610 --> 00:25:24,310
in this reactive thing
is using a constrains

548
00:25:24,310 --> 00:25:27,540
and gains thing called ObservableObject.

549
00:25:28,620 --> 00:25:31,470
Now remember constrains and gains,

550
00:25:31,470 --> 00:25:33,960
also known as protocols by the way.

551
00:25:33,960 --> 00:25:37,330
These constrains and gains,
we used one over here,

552
00:25:37,330 --> 00:25:40,060
colon View, that was a
constrains and gains.

553
00:25:40,060 --> 00:25:42,060
We were kind of constrained that we had

554
00:25:42,060 --> 00:25:43,520
to implement this body

555
00:25:43,520 --> 00:25:46,390
but we gained all these other functions

556
00:25:46,390 --> 00:25:47,610
that we can send to View.

557
00:25:47,610 --> 00:25:49,920
So this one was a huge gains

558
00:25:49,920 --> 00:25:53,610
for our very small
constrains to do View here.

559
00:25:53,610 --> 00:25:56,300
We also did it in our Model, our card.

560
00:25:56,300 --> 00:25:59,310
We did constraInt and
gains to be Identifiable,

561
00:25:59,310 --> 00:26:02,680
which required us to do this var id Int,

562
00:26:02,680 --> 00:26:07,120
but now we gain the ability
to tell which Card is which.

563
00:26:07,120 --> 00:26:10,640
And the UI is going to use
that right here in this ForEach

564
00:26:10,640 --> 00:26:13,540
to make sure that if our
cards move around or whatever,

565
00:26:13,540 --> 00:26:15,980
we can track where they
are and animate them.

566
00:26:15,980 --> 00:26:19,600
You're gonna see animation in
SwiftUI is ridiculously easy

567
00:26:19,600 --> 00:26:22,433
and a lot of it is
because of this mechanism.

568
00:26:23,510 --> 00:26:26,170
So this constrains and gains right here,

569
00:26:26,170 --> 00:26:28,380
the constraints are almost none.

570
00:26:28,380 --> 00:26:31,370
You don't have to implement
any vars or funcs,

571
00:26:31,370 --> 00:26:34,290
no body or id or anything like that.

572
00:26:34,290 --> 00:26:37,610
The tiny little constraint
is that it only works

573
00:26:37,610 --> 00:26:40,330
for classes, ObservableObject.

574
00:26:40,330 --> 00:26:44,750
You can only be an ObservableObject
here if you're a class,

575
00:26:44,750 --> 00:26:47,310
so that's minor constrains there.

576
00:26:47,310 --> 00:26:50,700
Now, the gain you get by doing this

577
00:26:50,700 --> 00:26:53,990
is you get this var
called objectWillChange.

578
00:26:54,900 --> 00:26:56,390
This var right here, you don't have

579
00:26:56,390 --> 00:26:58,640
to put it here like we did with body,

580
00:26:58,640 --> 00:27:00,380
you get it for free behind the scenes.

581
00:27:00,380 --> 00:27:02,010
So this will not be here.

582
00:27:02,010 --> 00:27:04,350
I'm just showing it to
you, what you're getting.

583
00:27:04,350 --> 00:27:07,950
And this var is not really of this type,

584
00:27:07,950 --> 00:27:10,700
ObservableObjectPublisher,

585
00:27:10,700 --> 00:27:12,270
it's a little more complicated than that.

586
00:27:12,270 --> 00:27:16,380
We don't even know or
care what it is really

587
00:27:16,380 --> 00:27:20,060
but there's two things about
this var that we need to know.

588
00:27:20,060 --> 00:27:22,810
One is that it's a Publisher,

589
00:27:22,810 --> 00:27:25,330
meaning that it can publish to the world,

590
00:27:25,330 --> 00:27:26,690
to anyone who's interested,

591
00:27:26,690 --> 00:27:29,020
and our Views are going to be interested,

592
00:27:29,020 --> 00:27:30,830
when something changes.

593
00:27:30,830 --> 00:27:35,580
And this var can only be sent one function

594
00:27:35,580 --> 00:27:37,633
which is the function send.

595
00:27:38,540 --> 00:27:42,553
And if you call the function
send on objectWillChange,

596
00:27:43,410 --> 00:27:47,010
it's going publish to the
world something changed

597
00:27:47,010 --> 00:27:51,690
about this object or really
something will change very soon

598
00:27:51,690 --> 00:27:54,070
so get ready and then react to it.

599
00:27:54,070 --> 00:27:56,730
And that's it, that's all
we have to do, really,

600
00:27:56,730 --> 00:27:59,550
to have our ViewModel participate in this.

601
00:27:59,550 --> 00:28:02,050
So every time our Model changes,

602
00:28:02,050 --> 00:28:05,690
we want to do objectWillChange.send.

603
00:28:05,690 --> 00:28:07,950
For example, here's an Intent.

604
00:28:07,950 --> 00:28:10,030
Clearly we're changing
our Model right here.

605
00:28:10,030 --> 00:28:11,760
We know that choose card

606
00:28:11,760 --> 00:28:15,320
is a mutable mutating function right here.

607
00:28:15,320 --> 00:28:17,950
So of course that's going
to change our Model.

608
00:28:17,950 --> 00:28:22,950
So here we would just say
objectWillChange.send.

609
00:28:24,010 --> 00:28:27,220
This is the only function,
really, we're ever gonna call

610
00:28:27,220 --> 00:28:30,180
on this objectWillChange thing right here.

611
00:28:30,180 --> 00:28:33,023
And this is going to publish to the world,

612
00:28:34,017 --> 00:28:37,870
objectWillChange meaning
this MemoryGame will change.

613
00:28:37,870 --> 00:28:38,703
That's all.

614
00:28:38,703 --> 00:28:41,750
It's not saying how it
changed, it changed.

615
00:28:41,750 --> 00:28:43,920
And that's important to know

616
00:28:43,920 --> 00:28:46,400
because if this ViewModel changed,

617
00:28:46,400 --> 00:28:48,330
this portal on the Model has changed,

618
00:28:48,330 --> 00:28:50,680
Views that are looking to that portal need

619
00:28:50,680 --> 00:28:52,220
to redraw themselves.

620
00:28:52,220 --> 00:28:53,840
And we're gonna show you in just a second

621
00:28:53,840 --> 00:28:56,830
how they sign up to do that.

622
00:28:56,830 --> 00:28:59,130
So again, we don't need
to put this in here,

623
00:28:59,130 --> 00:29:00,500
we get it for free.

624
00:29:00,500 --> 00:29:02,860
And when I get rid of that,
you can see no errors.

625
00:29:02,860 --> 00:29:04,550
This is all perfectly legal.

626
00:29:04,550 --> 00:29:06,820
You can call this anytime you want,

627
00:29:06,820 --> 00:29:08,600
anytime something changes.

628
00:29:08,600 --> 00:29:10,776
Doesn't even have to
be your Model changing.

629
00:29:10,776 --> 00:29:14,220
If you were gonna change
these emojis, for example,

630
00:29:14,220 --> 00:29:18,150
you could call objectWillChange,
totally up to you.

631
00:29:18,150 --> 00:29:21,520
However, in a significant app,

632
00:29:21,520 --> 00:29:25,110
you're gonna have,
possibly, a lot of Intents,

633
00:29:25,110 --> 00:29:27,600
a lot of different things
that might change your Model.

634
00:29:27,600 --> 00:29:29,330
And it's a little bit annoying

635
00:29:29,330 --> 00:29:31,280
to have to say objectWillChange.send,

636
00:29:31,280 --> 00:29:32,380
objectWillChange.send.

637
00:29:32,380 --> 00:29:33,880
It's even error prone.

638
00:29:33,880 --> 00:29:37,480
What if I oopsy daisy
forgot to put this in there

639
00:29:38,350 --> 00:29:39,940
and then you choose a Card and it's like,

640
00:29:39,940 --> 00:29:42,140
the cards still don't flip over, why?

641
00:29:42,140 --> 00:29:44,540
Because I forgot to put that in there.

642
00:29:44,540 --> 00:29:49,330
So while we can call
objectWillChange.send anytime we want,

643
00:29:49,330 --> 00:29:51,420
usually the way we deal with this

644
00:29:51,420 --> 00:29:55,987
is we take this var and
we make it Published.

645
00:29:57,730 --> 00:30:01,060
So this is not a Swift keyword,

646
00:29:57,730 --> 00:30:01,060
So this is not a Swift keyword,

647
00:30:01,060 --> 00:30:02,770
you can see it's not magenta,

648
00:30:02,770 --> 00:30:05,270
it's something called a property wrapper,

649
00:30:05,270 --> 00:30:07,420
this is a property.

650
00:30:07,420 --> 00:30:11,370
And property wrappers add
a little functionality

651
00:30:11,370 --> 00:30:13,140
around a property.

652
00:30:13,140 --> 00:30:15,980
In this case what this wrapper does is

653
00:30:15,980 --> 00:30:19,430
every time this property,
this Model, changes,

654
00:30:19,430 --> 00:30:22,150
it calls objectWillChange.send.

655
00:30:22,150 --> 00:30:23,960
That's what it does.

656
00:30:23,960 --> 00:30:27,977
So really, to make it so that
our ObservableObject here,

657
00:30:27,977 --> 00:30:31,480
our ViewModel, broadcasts
every time something changes,

658
00:30:31,480 --> 00:30:35,860
we just need to @Published all of our vars

659
00:30:35,860 --> 00:30:37,500
that we care whether they change

660
00:30:37,500 --> 00:30:39,880
when in this case is
just our one Model var.

661
00:30:39,880 --> 00:30:42,130
It could be other things as well.

662
00:30:42,130 --> 00:30:43,080
You can have as many of these

663
00:30:43,080 --> 00:30:44,640
@Published vars as you want.

664
00:30:44,640 --> 00:30:46,790
Any time any of them change,

665
00:30:46,790 --> 00:30:49,200
it's going to objectWillChange.send,

666
00:30:49,200 --> 00:30:50,363
that's what it does.

667
00:30:51,490 --> 00:30:54,100
This looks all a lot nicer
than having to remember

668
00:30:54,100 --> 00:30:58,310
to put objectWillChange.send
in all these functions.

669
00:30:58,310 --> 00:30:59,440
You still have the option

670
00:30:59,440 --> 00:31:02,680
of doing objectWillChange.send
even if you use these,

671
00:31:02,680 --> 00:31:04,480
but most of the time you will not have

672
00:31:04,480 --> 00:31:06,907
to do objectWillChange.send.

673
00:31:08,060 --> 00:31:09,440
So we're almost there.

674
00:31:09,440 --> 00:31:11,040
Right now we've got our ViewModel

675
00:31:11,040 --> 00:31:15,530
so it's publishing every
time the Model changes.

676
00:31:15,530 --> 00:31:18,470
Now we just need to fix our View over here

677
00:31:18,470 --> 00:31:23,470
so that when it sees this
ViewModel publishing, it redraws.

678
00:31:25,510 --> 00:31:28,660
Redraws every time it sees this thing,

679
00:31:28,660 --> 00:31:30,990
say objectWillChange.send.

680
00:31:30,990 --> 00:31:33,410
And the way it does that is
with another property wrapper

681
00:31:33,410 --> 00:31:36,693
on this one called @ObservedObject.

682
00:31:38,000 --> 00:31:42,590
And that's saying this var
has an ObservableObject in it,

683
00:31:42,590 --> 00:31:46,100
which it does, EmojiMemoryGame
is an ObservableObject.

684
00:31:46,100 --> 00:31:50,690
And every time it says
objectWillChange.send, redraw.

685
00:31:50,690 --> 00:31:52,690
And of course redrawing this one

686
00:31:52,690 --> 00:31:57,210
is gonna cause this one
potentially to get redrawn as well.

687
00:31:57,210 --> 00:31:58,730
Now, you might kind of feel like,

688
00:31:58,730 --> 00:32:00,630
whoa, this could be really inefficient,

689
00:32:00,630 --> 00:32:02,640
what if the Model is
changing all the time,

690
00:32:02,640 --> 00:32:05,630
are we gonna be redrawing
our Views every single time?

691
00:32:05,630 --> 00:32:07,770
Well, yes and no.

692
00:32:07,770 --> 00:32:11,350
Yes, we're going to be
reacting to objectWillChange

693
00:32:11,350 --> 00:32:15,770
and redrawing, but SwiftUI
is smart about seeing

694
00:32:15,770 --> 00:32:17,900
whether something actually changed.

695
00:32:17,900 --> 00:32:19,640
So if we flip one card over,

696
00:32:19,640 --> 00:32:22,520
it's not going to redraw
every single card,

697
00:32:22,520 --> 00:32:25,160
just the one that changed and it knows

698
00:32:25,160 --> 00:32:27,430
because the Cards are Identifiable.

699
00:32:27,430 --> 00:32:30,670
You starting to see why this ForEach

700
00:32:30,670 --> 00:32:34,970
on this Array of Cards forced
us to make this Identifiable?

701
00:32:34,970 --> 00:32:37,490
It helps it to understand this one changed

702
00:32:37,490 --> 00:32:39,910
so I actually need to redraw that.

703
00:32:39,910 --> 00:32:42,680
Because actually calling this code

704
00:32:42,680 --> 00:32:44,670
is probably not very expensive.

705
00:32:44,670 --> 00:32:48,070
Actually drawing on screen,
that's pretty expensive.

706
00:32:48,070 --> 00:32:51,193
So SwiftUI does everything
it can to avoid doing that.

707
00:32:52,350 --> 00:32:55,030
But conceptually for us, it's so simple.

708
00:32:55,030 --> 00:32:57,130
Every time our Model changes,

709
00:32:57,130 --> 00:33:01,050
this @Published wrapper notices that

710
00:33:01,050 --> 00:33:04,040
we're an ObservableObject
so our View can mark

711
00:33:04,040 --> 00:33:05,990
that it's interested in that publishing

712
00:33:05,990 --> 00:33:08,280
and voila, it's gonna redraw this.

713
00:33:08,280 --> 00:33:12,000
And this is how we do
reactive programming.

714
00:33:12,000 --> 00:33:13,360
Really, that's all there is to it.

715
00:33:13,360 --> 00:33:15,660
We're gonna see some minor refinements

716
00:33:15,660 --> 00:33:20,120
to that down the road, but this
is essentially how it works.

717
00:33:20,120 --> 00:33:21,380
So let's see if it works.

718
00:33:21,380 --> 00:33:23,050
Let's go run our app.

719
00:33:23,050 --> 00:33:25,670
Hopefully when we click on the cards,

720
00:33:25,670 --> 00:33:27,020
we're gonna say card chosen

721
00:33:27,020 --> 00:33:28,470
but they're also going to flip over.

722
00:33:28,470 --> 00:33:30,053
So let's try the ghost.

723
00:33:31,210 --> 00:33:34,640
The ghost, I'm clicking on
it, it's flipping both ways.

724
00:33:34,640 --> 00:33:37,200
I'll let this guy and
this guy and this guy.

725
00:33:37,200 --> 00:33:38,590
All right.

726
00:33:38,590 --> 00:33:42,530
So what's happening here is
we are clicking on these,

727
00:33:42,530 --> 00:33:44,370
it's doing this onTapGesture.

728
00:33:44,370 --> 00:33:47,750
It's expressing this
Intent in the ViewModel.

729
00:33:47,750 --> 00:33:50,310
The ViewModel is then asking the Model

730
00:33:50,310 --> 00:33:51,560
to go ahead and do it.

731
00:33:51,560 --> 00:33:54,430
The Model is doing this mutating thing.

732
00:33:54,430 --> 00:33:56,500
Once it's done this mutating thing,

733
00:33:56,500 --> 00:33:59,860
it's easy for this to
notice that this has changed

734
00:33:59,860 --> 00:34:02,780
and it gets published,
objectWillChange.send,

735
00:34:02,780 --> 00:34:05,670
and this guy observes
those objectWillChange.send

736
00:34:05,670 --> 00:34:07,020
and is redrawing.

737
00:34:07,020 --> 00:34:11,190
That is the slides that I showed you,

738
00:34:11,190 --> 00:34:14,973
the back and forth, that's
what it looks like in code.

739
00:34:17,000 --> 00:34:21,100
So we need to jump back
into the slides right now

740
00:34:21,100 --> 00:34:23,233
and talk a little bit about protocols.

741
00:34:24,270 --> 00:34:26,410
A protocol is gonna look to you

742
00:34:26,410 --> 00:34:29,940
like it's a stripped-down class or struct,

743
00:34:29,940 --> 00:34:33,500
stripped down because it
has functions and vars

744
00:34:33,500 --> 00:34:35,460
but no implementation.

745
00:34:35,460 --> 00:34:38,460
So here's a protocol,
moveable, that I've made up.

746
00:34:38,460 --> 00:34:40,770
It has one function and two vars.

747
00:34:40,770 --> 00:34:43,240
One of the vars is read
only there hasMoved.

748
00:34:43,240 --> 00:34:46,130
You can see it has that
curly brace get there.

749
00:34:46,130 --> 00:34:47,530
And then distanceFromStart

750
00:34:47,530 --> 00:34:49,864
is actually readable and writeable,

751
00:34:49,864 --> 00:34:51,890
that's why it has get and set.

752
00:34:51,890 --> 00:34:53,660
But there's no implementation here.

753
00:34:53,660 --> 00:34:54,880
Even those curly braces there,

754
00:34:54,880 --> 00:34:57,090
that's just saying whether
those vars are read only or not,

755
00:34:57,090 --> 00:34:58,453
that's all there is.

756
00:34:59,540 --> 00:35:01,970
Once you have a protocol declared,

757
00:35:01,970 --> 00:35:05,379
now any type, struct or
class, can come along and say,

758
00:35:05,379 --> 00:35:09,620
yes, I'm gonna implement that.

759
00:35:09,620 --> 00:35:12,820
That's claiming to implement the protocol.

760
00:35:12,820 --> 00:35:15,350
So here I have a struct, portable thing

761
00:35:15,350 --> 00:35:18,740
and it says colon Moveable
in this declaration.

762
00:35:18,740 --> 00:35:21,230
And when it says that,
that immediately means

763
00:35:21,230 --> 00:35:22,880
I sign up to implement this

764
00:35:22,880 --> 00:35:25,430
and therefore it must implement every var

765
00:35:25,430 --> 00:35:28,100
and every function in Moveable.

766
00:35:28,100 --> 00:35:30,770
Now we've seen this before View,

767
00:35:30,770 --> 00:35:33,680
we have our ContentView, colon View.

768
00:35:33,680 --> 00:35:35,810
It signs up to be a View
and that's why it has

769
00:35:35,810 --> 00:35:40,040
to do var body, same thing
Card was, Identifiable.

770
00:35:40,040 --> 00:35:41,930
It signed up to implement Identifiable.

771
00:35:41,930 --> 00:35:44,623
It had to implement that var id.

772
00:35:46,370 --> 00:35:50,970
Now it's also possible
to have one protocol say

773
00:35:50,970 --> 00:35:52,610
that it requires another protocol.

774
00:35:52,610 --> 00:35:54,770
This is called protocol inheritance,

775
00:35:54,770 --> 00:35:56,970
don't get confused with class inheritance

776
00:35:56,970 --> 00:35:59,080
'cause we're just talking
about protocols here.

777
00:35:59,080 --> 00:36:01,220
So here I have a protocol Vehicle

778
00:36:01,220 --> 00:36:04,460
and it's inheriting from Moveable.

779
00:36:04,460 --> 00:36:07,550
It adds its own var there, passengerCount.

780
00:36:07,550 --> 00:36:11,350
So if a class like car comes
along at the bottom here

781
00:36:11,350 --> 00:36:13,850
and it says, I signed up to your vehicle,

782
00:36:13,850 --> 00:36:15,890
well now it has to
implement all three things

783
00:36:15,890 --> 00:36:17,850
from Moveable and it has

784
00:36:17,850 --> 00:36:19,650
to implement the thing from Vehicle.

785
00:36:20,500 --> 00:36:23,310
You can also, if you're
a struct or a class,

786
00:36:23,310 --> 00:36:25,720
claim to implement multiple protocols.

787
00:36:25,720 --> 00:36:27,560
So here I have the class car.

788
00:36:27,560 --> 00:36:29,710
It's not only saying that it's a vehicle

789
00:36:29,710 --> 00:36:32,430
but also that it's
Impoundable and Leaseable

790
00:36:32,430 --> 00:36:35,530
and now cars can have to implement
all the functions in vars

791
00:36:35,530 --> 00:36:37,773
in all three of these protocols.

792
00:36:38,740 --> 00:36:41,250
Now a protocol is a type.

793
00:36:41,250 --> 00:36:44,320
That means that most protocols can be used

794
00:36:44,320 --> 00:36:46,650
in most circumstances
where you have a type.

795
00:36:46,650 --> 00:36:51,370
For example, I can have a
variable m of type Moveable.

796
00:36:51,370 --> 00:36:54,296
That's the type of m,
it's a type Moveable.

797
00:36:54,296 --> 00:36:55,290
And what does that mean?

798
00:36:55,290 --> 00:36:57,390
Well, if I had another couple of vars,

799
00:36:57,390 --> 00:37:00,170
like car and portable,
which are of type Car

800
00:37:00,170 --> 00:37:03,480
and type PortableThing, then I can say,

801
00:37:03,480 --> 00:37:06,110
m equals car or m equals portable.

802
00:37:06,110 --> 00:37:07,240
Why can I say that?

803
00:37:07,240 --> 00:37:10,450
Because car is a Moveable,

804
00:37:10,450 --> 00:37:12,780
it implements the Moveable protocol.

805
00:37:12,780 --> 00:37:16,820
In fact, car implements Vehicle,
Vehicle inherits Moveable,

806
00:37:16,820 --> 00:37:19,130
and so therefore car is Moveable.

807
00:37:19,130 --> 00:37:22,210
And this is great because
now I have this variable m,

808
00:37:22,210 --> 00:37:25,937
I can start sending it
functions like has moved,

809
00:37:25,937 --> 00:37:29,270
has moved because I know
that m is a Moveable.

810
00:37:29,270 --> 00:37:32,010
And whether it's a Car in
there or PortableThing,

811
00:37:32,010 --> 00:37:33,820
we know that those vars and functions

812
00:37:33,820 --> 00:37:35,810
are gonna be implemented
because you're required

813
00:37:35,810 --> 00:37:39,340
to implement them if you say
you're one of those things.

814
00:37:39,340 --> 00:37:41,420
But one thing to be a
little careful of here,

815
00:37:41,420 --> 00:37:45,560
you cannot say portable equals car.

816
00:37:45,560 --> 00:37:49,270
The var portable up there
is not of type Moveable,

817
00:37:49,270 --> 00:37:52,900
it's of type PortableThing, different.

818
00:37:52,900 --> 00:37:56,660
And so a Car is not a PortableThing.

819
00:37:56,660 --> 00:37:59,950
They're both Moveables, but
a Car is a different type

820
00:37:59,950 --> 00:38:00,880
than a PortableThing.

821
00:38:00,880 --> 00:38:03,830
I think a Car was a class,
PortableThing was a struct.

822
00:38:03,830 --> 00:38:06,160
So not even the same kind of thing.

823
00:38:06,160 --> 00:38:07,970
So you cannot say that.

824
00:38:07,970 --> 00:38:09,980
While I can say m equals
each of those things,

825
00:38:09,980 --> 00:38:11,540
I can't say they equal each other

826
00:38:11,540 --> 00:38:14,720
'cause Swift is enforcing
the type of the var,

827
00:38:14,720 --> 00:38:16,300
and then when I say portable equals,

828
00:38:16,300 --> 00:38:18,620
the type of the var is PortableThing,

829
00:38:18,620 --> 00:38:20,763
not type Moveable there.

830
00:38:22,110 --> 00:38:24,320
One way to think about protocols,

831
00:38:24,320 --> 00:38:27,100
and I've already mentioned
this in the demo,

832
00:38:27,100 --> 00:38:30,530
is constrains and gains.

833
00:38:30,530 --> 00:38:34,830
I use this because it rhymes,
so hopefully easy to remember,

834
00:38:34,830 --> 00:38:37,130
and it works like this.

835
00:38:37,130 --> 00:38:41,470
So I have this struct right
here, Tesla, and it's a Vehicle,

836
00:38:41,470 --> 00:38:43,140
so it implements all of those things.

837
00:38:43,140 --> 00:38:44,800
In fact, it's constrained

838
00:38:44,800 --> 00:38:47,320
to implement all the things in Vehicle

839
00:38:47,320 --> 00:38:49,610
which includes all the things in Moveable,

840
00:38:49,610 --> 00:38:53,820
but being constrained on
that is going to make again

841
00:38:53,820 --> 00:38:58,360
all the things the world
offers to a Vehicle.

842
00:38:58,360 --> 00:39:01,674
Now, you might be saying,
well, wait a second here,

843
00:39:01,674 --> 00:39:05,270
Vehicle is a protocol,
has no implementation.

844
00:39:05,270 --> 00:39:08,093
How are we possibly
gonna gain anything here?

845
00:39:09,140 --> 00:39:12,840
It seems like I got all constrains
here and I got no gains.

846
00:39:12,840 --> 00:39:17,660
Well, the magic is in
the keyword extension.

847
00:39:17,660 --> 00:39:22,660
In Swift, we can extend
protocols to have implementation.

848
00:39:23,870 --> 00:39:26,900
and we just say extension,
name of the protocol,

849
00:39:26,900 --> 00:39:28,300
and then we can put functions

850
00:39:28,300 --> 00:39:31,750
with implementation functions
in vars with implementation.

851
00:39:31,750 --> 00:39:34,920
Now we can't have any vars
that have storage here.

852
00:39:34,920 --> 00:39:38,170
So there is that restriction,
it has to be computed vars,

853
00:39:38,170 --> 00:39:39,927
like var body was computed, remember,

854
00:39:39,927 --> 00:39:43,000
it had the curly braces
after the same thing here,

855
00:39:43,000 --> 00:39:46,440
but we can add as many things as we want.

856
00:39:46,440 --> 00:39:49,170
With this extension of
Vehicle registerWithDMV,

857
00:39:49,170 --> 00:39:51,640
now Teslas and all other Vehicles

858
00:39:51,640 --> 00:39:53,270
can be registered with DMV.

859
00:39:53,270 --> 00:39:55,620
In other words, they gained that ability

860
00:39:55,620 --> 00:39:57,970
by living with the
constraint that they have had

861
00:39:57,970 --> 00:40:00,040
to implement those methods and vars

862
00:39:57,970 --> 00:40:00,040
to implement those methods and vars

863
00:40:00,040 --> 00:40:01,623
that were in those protocols.

864
00:40:02,730 --> 00:40:05,180
So, yeah, this is really the center

865
00:40:05,180 --> 00:40:07,890
of functional programming in Swift.

866
00:40:07,890 --> 00:40:10,950
And the protocol View is probably

867
00:40:10,950 --> 00:40:13,380
the poster child for doing this.

868
00:40:13,380 --> 00:40:15,160
And we're gonna see more about View

869
00:40:15,160 --> 00:40:16,510
in a couple of slides here.

870
00:40:17,690 --> 00:40:20,210
In addition to adding functions,

871
00:40:20,210 --> 00:40:23,682
like registerWithDMV, you
can also use an extension

872
00:40:23,682 --> 00:40:28,682
to protocol if you want to
add default implementations.

873
00:40:28,710 --> 00:40:30,390
So here I am extending Moveable

874
00:40:30,390 --> 00:40:33,060
and I'm actually providing
a default implementation

875
00:40:33,060 --> 00:40:36,370
for hasMoved as hasMoved
is one of the vars

876
00:40:36,370 --> 00:40:37,720
in the protocol

877
00:40:37,720 --> 00:40:39,810
but I'm providing a default
implementation here.

878
00:40:39,810 --> 00:40:42,380
I'm just looking at my
distance from start,

879
00:40:42,380 --> 00:40:43,800
and if that's greater than zero,

880
00:40:43,800 --> 00:40:45,697
I'm gonna assume I've moved.

881
00:40:45,697 --> 00:40:49,550
And I'm doing this with
an extension to Moveable.

882
00:40:49,550 --> 00:40:52,550
So this makes it possible
for me then to have a struct,

883
00:40:52,550 --> 00:40:55,260
I have one here called
ChessPiece which is a Moveable,

884
00:40:55,260 --> 00:40:57,070
you can move chess pieces.

885
00:40:57,070 --> 00:41:00,640
ChessPiece does not need
to implement hasMoved.

886
00:41:00,640 --> 00:41:03,210
If ChessPiece just implements moveBy

887
00:41:03,210 --> 00:41:04,750
and distanceFromStart,

888
00:41:04,750 --> 00:41:07,350
then it will have successfully
implemented Moveable

889
00:41:07,350 --> 00:41:10,610
because it'll pick up the
default implementation

890
00:41:10,610 --> 00:41:12,700
from that extension right there.

891
00:41:12,700 --> 00:41:15,910
Now, if ChessPiece wanted to
implement hasMoved itself,

892
00:41:15,910 --> 00:41:18,130
it could, but it doesn't have to

893
00:41:18,130 --> 00:41:20,250
because there's a default implementation

894
00:41:20,250 --> 00:41:22,513
for hasMoved in that extension.

895
00:41:23,640 --> 00:41:25,690
Now, you can use extensions of course,

896
00:41:25,690 --> 00:41:28,220
to add code to structs
and classes as well,

897
00:41:28,220 --> 00:41:30,620
not just protocols.

898
00:41:30,620 --> 00:41:34,300
So here, for example, I
have a struct called Boat

899
00:41:34,300 --> 00:41:37,400
and it's got its own methods,
whatever they might be.

900
00:41:37,400 --> 00:41:40,330
And here I'm adding extension to Boat,

901
00:41:40,330 --> 00:41:42,650
a function sailAroundTheWorld.

902
00:41:42,650 --> 00:41:46,100
And this extension, you
can see, has curly braces,

903
00:41:46,100 --> 00:41:47,330
it has an implementation.

904
00:41:47,330 --> 00:41:50,560
This is an actual implementation
of sailAroundTheWorld

905
00:41:50,560 --> 00:41:52,233
that we've added to Boat.

906
00:41:53,410 --> 00:41:58,130
You can even make something
like a Boat conformed

907
00:41:58,130 --> 00:42:01,220
to a protocol purely by
using your extension.

908
00:42:01,220 --> 00:42:04,610
So Boat doesn't implement
any protocols right now

909
00:42:04,610 --> 00:42:07,130
but I can make Boat implement Moveable

910
00:42:07,130 --> 00:42:09,470
by having the extension to Boat

911
00:42:09,470 --> 00:42:13,060
that says colon Moveable
and then in that extension,

912
00:42:13,060 --> 00:42:16,070
implement moveBy and distanceFromStart.

913
00:42:16,070 --> 00:42:18,600
Now Boat is a Moveable.

914
00:42:18,600 --> 00:42:20,733
And I added it totally with extension.

915
00:42:22,044 --> 00:42:23,750
It's not an uncommon thing to do

916
00:42:23,750 --> 00:42:27,310
to take a structure or
class and make it conformed

917
00:42:27,310 --> 00:42:30,030
to a protocol using purely an extension,

918
00:42:30,030 --> 00:42:31,830
or you add the code in an extension.

919
00:42:33,880 --> 00:42:37,100
Why do we do all this protocol stuff?

920
00:42:37,100 --> 00:42:38,770
Now, for those of you who are coming

921
00:42:38,770 --> 00:42:40,420
from object oriented programming,

922
00:42:40,420 --> 00:42:42,230
this was gonna seem like,
what's going on here?

923
00:42:42,230 --> 00:42:43,440
Why do we do this?

924
00:42:43,440 --> 00:42:45,940
Well, there's a really
good conceptual reason

925
00:42:45,940 --> 00:42:47,780
why we're doing this.

926
00:42:47,780 --> 00:42:51,200
Protocols are away for
types, structs and classes,

927
00:42:51,200 --> 00:42:55,450
other protocols, even enums,
which we haven't talked about,

928
00:42:55,450 --> 00:42:58,140
to say what they are capable of,

929
00:42:58,140 --> 00:43:02,480
what functions they can do,
what vars they have on them,

930
00:43:02,480 --> 00:43:04,440
and it's also a way for other code

931
00:43:04,440 --> 00:43:07,800
to demand certain behavior
from other objects

932
00:43:07,800 --> 00:43:10,530
by demanding that they
conform to a protocol,

933
00:43:10,530 --> 00:43:12,860
either by having a variable of that type

934
00:43:12,860 --> 00:43:16,190
that they're trying to assign
or parameter to a function.

935
00:43:16,190 --> 00:43:18,870
And there's even other
mechanisms you're gonna see soon

936
00:43:18,870 --> 00:43:21,330
when we talk about generics and protocols

937
00:43:21,330 --> 00:43:24,340
for demanding that you want
that thing to be a Moveable.

938
00:43:24,340 --> 00:43:26,140
It has to be a Vehicle, whatever.

939
00:43:26,140 --> 00:43:29,840
You can demand it now that
you have this protocol.

940
00:43:29,840 --> 00:43:33,320
But in all of that,
neither side has to reveal

941
00:43:33,320 --> 00:43:35,820
what sort of structure class you are.

942
00:43:35,820 --> 00:43:38,340
You completely can be anything you want.

943
00:43:38,340 --> 00:43:40,540
You just say you implement Moveable

944
00:43:40,540 --> 00:43:43,360
and now you can be
operated on as a Moveable,

945
00:43:43,360 --> 00:43:44,450
but you could be anything.

946
00:43:44,450 --> 00:43:46,370
You could be a Car, you
could be a PortableThing.

947
00:43:46,370 --> 00:43:47,813
You could be a Boat.

948
00:43:48,950 --> 00:43:51,350
We know when neither side cares.

949
00:43:51,350 --> 00:43:54,020
All one side cares is that
you can do the Moveable things

950
00:43:54,020 --> 00:43:55,450
and all the other side cares is that

951
00:43:55,450 --> 00:43:58,283
it implement all those Moveable things.

952
00:43:59,590 --> 00:44:01,690
So this is what functional programming,

953
00:44:01,690 --> 00:44:05,350
or really we might call it,
protocol-oriented programming,

954
00:44:05,350 --> 00:44:06,500
is all about.

955
00:44:06,500 --> 00:44:09,220
It's about formalizing how data structures

956
00:44:09,220 --> 00:44:12,970
in our application
function, how they behaved.

957
00:44:12,970 --> 00:44:16,180
Even when we talk about vars
in the context of protocols,

958
00:44:16,180 --> 00:44:19,250
we don't define how
they're stored or computed,

959
00:44:19,250 --> 00:44:21,540
we don't even say where
they're stored or computed,

960
00:44:21,540 --> 00:44:24,180
we just talk about whether
they're read only or read, write.

961
00:44:24,180 --> 00:44:27,980
And through all this we
focus on the functionality.

962
00:44:27,980 --> 00:44:30,410
We're hiding the implementation details.

963
00:44:30,410 --> 00:44:32,540
It's kind of the ultimate promise

964
00:44:32,540 --> 00:44:35,270
of encapsulation from
object-oriented programming

965
00:44:35,270 --> 00:44:37,170
but it's really taken to a higher level

966
00:44:37,170 --> 00:44:39,850
because it doesn't mix it inexorably

967
00:44:39,850 --> 00:44:41,133
with the data and all that,

968
00:44:41,133 --> 00:44:44,533
it's just talking about the functionality.

969
00:44:45,820 --> 00:44:49,060
And all of this gets even more powerful

970
00:44:49,060 --> 00:44:51,803
when we combine it with generics.

971
00:44:52,730 --> 00:44:55,930
Protocols plus generics equals,

972
00:44:55,930 --> 00:44:58,690
as I say here, super powers.

973
00:44:58,690 --> 00:45:01,310
So let's look at how generics,

974
00:45:01,310 --> 00:45:03,500
remember that's the don't care stuff

975
00:45:03,500 --> 00:45:05,090
that we talked about last time,

976
00:45:05,090 --> 00:45:08,760
how it combines with protocols
to make super powers.

977
00:45:08,760 --> 00:45:09,890
Here we go.

978
00:45:09,890 --> 00:45:11,400
Let's do this by example.

979
00:45:11,400 --> 00:45:14,720
Let's say I had a
protocol called Greatness,

980
00:45:14,720 --> 00:45:16,810
and this protocol only
has one function in it

981
00:45:16,810 --> 00:45:19,363
which is, isGreaterThan other.

982
00:45:20,370 --> 00:45:23,100
One argument other to this
function isGreaterThan.

983
00:45:23,100 --> 00:45:25,190
By the way, this is kind
of an interesting function

984
00:45:25,190 --> 00:45:29,980
because the type of
other is capital S Self.

985
00:45:30,840 --> 00:45:34,320
That's a special kind of
name of a type in a protocol

986
00:45:34,320 --> 00:45:36,180
which means the actual type

987
00:45:36,180 --> 00:45:38,130
that's implementing this protocol,

988
00:45:38,130 --> 00:45:40,240
because remember, protocols themselves

989
00:45:40,240 --> 00:45:42,260
have no implementation,
they get implemented

990
00:45:42,260 --> 00:45:43,930
by structs and classes.

991
00:45:43,930 --> 00:45:46,430
So that Self means that
the actual structure class

992
00:45:46,430 --> 00:45:50,910
that implements this, that
is executing it at the time.

993
00:45:50,910 --> 00:45:51,743
So that's kind of cool.

994
00:45:51,743 --> 00:45:52,576
And I'm gonna show you how that works

995
00:45:52,576 --> 00:45:54,763
in just a few clicks here.

996
00:45:55,770 --> 00:45:59,350
So if we have this protocol,
look at what we can do.

997
00:45:59,350 --> 00:46:03,680
Extension Array, so I'm
adding something to Array,

998
00:46:03,680 --> 00:46:08,680
where the element, the
don't care of the Array,

999
00:46:08,750 --> 00:46:12,860
conforms to Greatness, colon Greatness.

1000
00:46:12,860 --> 00:46:14,950
So that where I put in red

1001
00:46:14,950 --> 00:46:17,240
because it's really the key part

1002
00:46:17,240 --> 00:46:19,640
of connecting generics and protocols.

1003
00:46:19,640 --> 00:46:22,460
Here, I'm actually going to add a var,

1004
00:46:22,460 --> 00:46:23,760
or I could do it with functions,

1005
00:46:23,760 --> 00:46:25,510
but I'm gonna add a var here

1006
00:46:25,510 --> 00:46:29,630
to Array so that every
Array where the element,

1007
00:46:29,630 --> 00:46:33,133
the don't care, conforms to
Greatness will get this var.

1008
00:46:34,460 --> 00:46:36,090
Let that sink in.

1009
00:46:36,090 --> 00:46:39,240
Now, this var will not exist in Arrays

1010
00:46:39,240 --> 00:46:42,480
where the don't cares don't implement

1011
00:46:42,480 --> 00:46:43,540
the protocol Greatness.

1012
00:46:43,540 --> 00:46:45,340
This var just will not be there.

1013
00:46:45,340 --> 00:46:47,100
If you tried to type it in your code,

1014
00:46:47,100 --> 00:46:48,080
the compiler would say,

1015
00:46:48,080 --> 00:46:51,240
this Array does not implement greatest

1016
00:46:51,240 --> 00:46:52,810
It would only say it implements greatest

1017
00:46:52,810 --> 00:46:56,130
only lets you type that in without error

1018
00:46:56,130 --> 00:46:57,630
if it was an Array of something

1019
00:46:57,630 --> 00:46:59,510
that implements the protocol Greatness

1020
00:46:59,510 --> 00:47:03,833
Now I like to call this,
we care a little bit.

1021
00:47:05,000 --> 00:47:07,970
Normally we call generics don't care,

1022
00:47:07,970 --> 00:47:09,700
element is a don't care,

1023
00:47:09,700 --> 00:47:12,320
Array doesn't care what's inside of it.

1024
00:47:12,320 --> 00:47:14,040
Well, this is kind of,

1025
00:47:14,040 --> 00:47:17,800
this extension to Array cares
a little bit about element.

1026
00:47:17,800 --> 00:47:19,420
It doesn't really care what element is,

1027
00:47:19,420 --> 00:47:22,840
can be any struct or class, but we do care

1028
00:47:22,840 --> 00:47:24,310
that it implements Greatness.

1029
00:47:24,310 --> 00:47:26,210
So this is care a little bit,

1030
00:47:26,210 --> 00:47:28,070
you wanna think of it that way.

1031
00:47:28,070 --> 00:47:33,070
Then this var greatness, look
what its type is, element.

1032
00:47:33,120 --> 00:47:35,210
It's the don't care because I'm gonna look

1033
00:47:35,210 --> 00:47:37,870
through the Array and find
the one that's the greatest

1034
00:47:37,870 --> 00:47:40,510
by calling isGreaterThan other

1035
00:47:40,510 --> 00:47:41,870
on all of the things in the Array

1036
00:47:41,870 --> 00:47:45,070
which I know I can do because
this extension to Array

1037
00:47:45,070 --> 00:47:48,750
is only where the elements
implement Greatness.

1038
00:47:48,750 --> 00:47:50,750
See how it all works here?

1039
00:47:50,750 --> 00:47:52,940
So you can easily imagine, I'm
not gonna show the code here,

1040
00:47:52,940 --> 00:47:55,113
but you can easily imagine
building a for loop

1041
00:47:55,113 --> 00:47:57,050
that just goes through all the elements,

1042
00:47:57,050 --> 00:47:58,710
calls isGreaterThan on all of them,

1043
00:47:58,710 --> 00:48:00,820
figures out which one is the greatest

1044
00:48:00,820 --> 00:48:02,170
and that's just returns it.

1045
00:48:03,470 --> 00:48:07,440
So let's see how we would
use an Array like this.

1046
00:48:07,440 --> 00:48:10,280
Let's imagine that I use another extension

1047
00:48:10,280 --> 00:48:12,240
to make Int the type Int

1048
00:48:12,240 --> 00:48:14,720
which is a struct, implement Greatness.

1049
00:48:14,720 --> 00:48:16,590
No problem, it's really easy

1050
00:48:16,590 --> 00:48:19,420
to implement an Int isGreaterThan other,

1051
00:48:19,420 --> 00:48:22,050
is just self isGreaterThan other Ints,

1052
00:48:22,050 --> 00:48:23,300
you can just use greater than

1053
00:48:23,300 --> 00:48:26,030
to see if something is
greater than something else.

1054
00:48:26,030 --> 00:48:28,150
But imagine I had some
totally different type.

1055
00:48:28,150 --> 00:48:31,040
Here's extension of President.

1056
00:48:31,040 --> 00:48:33,060
That's the president of the United States.

1057
00:48:33,060 --> 00:48:34,710
I'm gonna make it implement Greatness,

1058
00:48:34,710 --> 00:48:36,993
func isGreaterThan other President.

1059
00:48:38,090 --> 00:48:39,060
And I'm gonna implement...

1060
00:48:39,060 --> 00:48:40,650
Actually, I had Donald Trump,

1061
00:48:40,650 --> 00:48:44,410
guest iOS programmer come
in and implement this one.

1062
00:48:44,410 --> 00:48:46,645
He says that isGreaterThan

1063
00:48:46,645 --> 00:48:48,650
is just self.name equals Trump.

1064
00:48:48,650 --> 00:48:51,800
If that's true, then of
course isGreaterThan,

1065
00:48:51,800 --> 00:48:54,470
he's a great iOS programmer,
everybody tells me that,

1066
00:48:54,470 --> 00:48:56,040
I hear that everywhere.

1067
00:48:56,040 --> 00:48:57,890
So here we go, we got this.

1068
00:48:57,890 --> 00:48:59,780
Now, one thing I wanna point out

1069
00:48:59,780 --> 00:49:03,010
about this slide that you're seeing

1070
00:49:03,010 --> 00:49:04,800
is the stuff in purple here.

1071
00:49:04,800 --> 00:49:08,190
Remember that isGreaterThan
other Self at the top?

1072
00:49:08,190 --> 00:49:09,860
Remember that capital S Self?

1073
00:49:09,860 --> 00:49:12,700
Look how, when I've
created these extensions,

1074
00:49:12,700 --> 00:49:16,040
that self has turned into
the type I'm extending,

1075
00:49:16,040 --> 00:49:19,820
the type I'm implementing
this protocol with.

1076
00:49:19,820 --> 00:49:21,810
Hopefully that helps
you understand the Self.

1077
00:49:21,810 --> 00:49:24,080
I bring this up because
there's quite a few protocols

1078
00:49:24,080 --> 00:49:27,640
in Swift UI that do this
where they have a var

1079
00:49:27,640 --> 00:49:30,430
or a function that one of the types

1080
00:49:30,430 --> 00:49:32,880
of the arguments is the
thing implementing this.

1081
00:49:32,880 --> 00:49:35,123
So this is not uncommon.

1082
00:49:36,010 --> 00:49:38,310
So now I have Int and President.

1083
00:49:38,310 --> 00:49:41,750
They both implement this
protocol, Greatness.

1084
00:49:41,750 --> 00:49:44,730
So I should be able to call
that Array var on them.

1085
00:49:44,730 --> 00:49:46,900
I should be able to use Array var

1086
00:49:46,900 --> 00:49:50,060
that I defined right there,
greatest, to get the greatest.

1087
00:49:50,060 --> 00:49:52,330
So let's see what that looks like for Int.

1088
00:49:52,330 --> 00:49:54,410
So for Int, let's say
I have a numbersArray,

1089
00:49:54,410 --> 00:49:56,890
it's an Array of Int that's its type.

1090
00:49:56,890 --> 00:50:00,630
I'm going to set it equal
to a constant Array here,

1091
00:49:56,890 --> 00:50:00,630
I'm going to set it equal
to a constant Array here,

1092
00:50:00,630 --> 00:50:02,070
we saw that in the demo.

1093
00:50:02,070 --> 00:50:03,190
We were doing it with the emojis.

1094
00:50:03,190 --> 00:50:05,660
Here, I'm doing with the
numbers three, seven and 42,

1095
00:50:05,660 --> 00:50:07,740
so it's just an Array of
that and now I can say,

1096
00:50:07,740 --> 00:50:10,640
let foo equals the numbersArray.greatest.

1097
00:50:10,640 --> 00:50:15,020
And that compiles and works because Int is

1098
00:50:15,020 --> 00:50:17,290
what's in that Array and Int implements

1099
00:50:17,290 --> 00:50:21,060
the Greatness protocol so the greatest var

1100
00:50:21,060 --> 00:50:22,087
is defined therefore.

1101
00:50:22,087 --> 00:50:25,880
And so foo will be 42 here
'cause we do implement it

1102
00:50:25,880 --> 00:50:26,950
by just saying greater.

1103
00:50:26,950 --> 00:50:28,750
And I can do exactly the same thing

1104
00:50:28,750 --> 00:50:30,050
if I had a President in this Array.

1105
00:50:30,050 --> 00:50:32,440
Let's say the struct
President can be created

1106
00:50:32,440 --> 00:50:33,540
with the name of the president.

1107
00:50:33,540 --> 00:50:35,743
So I create some Array of Presidents here.

1108
00:50:35,743 --> 00:50:37,450
Now, I'm gonna say let foo equal

1109
00:50:37,450 --> 00:50:40,220
the presidentsArray.greatest.

1110
00:50:40,220 --> 00:50:42,047
And that's going to give me back foo

1111
00:50:42,047 --> 00:50:43,910
or foo whose name is Trump,

1112
00:50:43,910 --> 00:50:47,780
of course, based on the
code that he wrote here.

1113
00:50:47,780 --> 00:50:50,200
So hopefully this is
making it clear to you

1114
00:50:50,200 --> 00:50:53,330
how we use generics
and protocols together.

1115
00:50:53,330 --> 00:50:56,190
And we're gonna do this all
over the place in SwiftUI.

1116
00:50:58,170 --> 00:50:59,590
Some of you are looking at all this,

1117
00:50:59,590 --> 00:51:02,913
and I'm sure you're
shivering, as I say here.

1118
00:51:03,970 --> 00:51:06,040
You gotta be thinking, holy cow,

1119
00:51:06,040 --> 00:51:08,410
how am I supposed to be expected to know

1120
00:51:08,410 --> 00:51:11,930
how to design my code
using this technology?

1121
00:51:11,930 --> 00:51:14,220
I mean, this is just all new to me.

1122
00:51:14,220 --> 00:51:18,080
And this is indeed a
very powerful foundation

1123
00:51:18,080 --> 00:51:20,660
for designing things, very powerful.

1124
00:51:20,660 --> 00:51:23,760
But functional programming
does require some mastery

1125
00:51:23,760 --> 00:51:27,490
that only comes with experience.

1126
00:51:27,490 --> 00:51:30,260
And the good news is that
you can do a lot of stuff

1127
00:51:30,260 --> 00:51:32,180
in SwiftUI, most things,

1128
00:51:32,180 --> 00:51:35,550
without really mastering
functional programming.

1129
00:51:35,550 --> 00:51:38,490
But here you are at Stanford
trying to get a good education.

1130
00:51:38,490 --> 00:51:41,560
And so the reason I'm
explaining this to you now

1131
00:51:41,560 --> 00:51:44,320
is so that the more you use it in SwiftUI,

1132
00:51:44,320 --> 00:51:46,290
the more you see it in the documentation

1133
00:51:46,290 --> 00:51:49,020
where you see these wares happening,

1134
00:51:49,020 --> 00:51:50,760
we see protocols like View

1135
00:51:50,760 --> 00:51:53,200
and Identifiable coming down the road,

1136
00:51:53,200 --> 00:51:56,160
that you're not just saying,
I have to put colon View here,

1137
00:51:56,160 --> 00:51:57,540
you're actually understanding

1138
00:51:57,540 --> 00:51:59,600
how it's being designed underneath.

1139
00:51:59,600 --> 00:52:01,897
And the more you see it,
the more it's gonna sink in

1140
00:52:01,897 --> 00:52:04,930
and the more eventually you
might start to be capable

1141
00:52:04,930 --> 00:52:07,773
of doing functional
programming design as well.

1142
00:52:08,780 --> 00:52:10,733
But no one expects you, right now,

1143
00:52:10,733 --> 00:52:13,190
to be able to be designing stuff

1144
00:52:13,190 --> 00:52:15,180
where you're adding
extensions to protocols

1145
00:52:15,180 --> 00:52:16,860
with generics and all that.

1146
00:52:16,860 --> 00:52:18,870
But eventually you'll be able to.

1147
00:52:18,870 --> 00:52:20,830
And in the meantime you'll kind of know

1148
00:52:20,830 --> 00:52:22,320
what's going on in SwiftUI.

1149
00:52:25,290 --> 00:52:28,230
So I'm just putting this one
slide up here about enum,

1150
00:52:28,230 --> 00:52:33,230
but once again, not gonna talk
about enum in this lecture.

1151
00:52:33,880 --> 00:52:36,493
We'll talk about it soon, not to worry.

1152
00:52:37,440 --> 00:52:40,320
So that pretty much
covers what we're going

1153
00:52:40,320 --> 00:52:42,470
to talk about today on architecture

1154
00:52:42,470 --> 00:52:46,210
and we're almost there in
covering this entire topic.

1155
00:52:46,210 --> 00:52:48,120
And now I'm gonna shift gears entirely

1156
00:52:48,120 --> 00:52:52,410
and go to a completely
different topic which is layout,

1157
00:52:52,410 --> 00:52:54,370
in other words, how do we decide

1158
00:52:54,370 --> 00:52:57,260
where all our Views go on screen?

1159
00:52:57,260 --> 00:53:01,040
The way that SwiftUI does
this is amazingly simple.

1160
00:53:01,040 --> 00:53:04,400
It's one of the more elegant
things in all of SwiftUI.

1161
00:53:04,400 --> 00:53:07,230
There's really only three
steps to doing this.

1162
00:53:07,230 --> 00:53:10,360
The first one is the container Views,

1163
00:53:10,360 --> 00:53:13,420
like HStacks and VStacks
and things like that.

1164
00:53:13,420 --> 00:53:17,480
They offer space to the Views
that are inside of them.

1165
00:53:17,480 --> 00:53:21,130
And then those Views choose
a size for themselves,

1166
00:53:21,130 --> 00:53:22,680
what they want to be.

1167
00:53:22,680 --> 00:53:23,930
Based on that offer,

1168
00:53:23,930 --> 00:53:26,120
they could choose a
size same as the offer,

1169
00:53:26,120 --> 00:53:27,340
that's the most common,

1170
00:53:27,340 --> 00:53:29,480
they can choose a size
smaller than the offer,

1171
00:53:29,480 --> 00:53:32,743
they could choose a size that's
larger even than the offer.

1172
00:53:32,743 --> 00:53:35,740
So they use, in a very kind
of good encapsulation way,

1173
00:53:35,740 --> 00:53:38,610
Views decide what size
they're going to be.

1174
00:53:38,610 --> 00:53:40,210
No one tells them what size to be.

1175
00:53:40,210 --> 00:53:42,830
We just offer them space, they decide.

1176
00:53:42,830 --> 00:53:46,910
But then after that, the
container Views like the stacks,

1177
00:53:46,910 --> 00:53:50,560
it's their job to position their
Views inside of themselves.

1178
00:53:50,560 --> 00:53:52,970
And that's it, these are the three steps

1179
00:53:52,970 --> 00:53:56,670
to get everything laid out in SwiftUI.

1180
00:53:56,670 --> 00:53:58,030
So let's dive into this a little bit.

1181
00:53:58,030 --> 00:54:00,690
Let's talk about container Views.

1182
00:54:00,690 --> 00:54:02,480
So the most common container View

1183
00:54:02,480 --> 00:54:06,070
that you're already familiar
with is HStack and VStack.

1184
00:54:06,070 --> 00:54:08,303
Of course, there's Zstack as well

1185
00:54:08,303 --> 00:54:10,620
that kind of stacks them
on top of each other,

1186
00:54:10,620 --> 00:54:13,080
but HStack and VStack are interesting

1187
00:54:13,080 --> 00:54:16,430
in that they divide up the
space that's offered to them

1188
00:54:16,430 --> 00:54:18,220
amongst all of their subviews.

1189
00:54:18,220 --> 00:54:20,810
And we'll talk about how
that works in a moment.

1190
00:54:20,810 --> 00:54:25,010
ForEach is kind of an
unusual container View.

1191
00:54:25,010 --> 00:54:28,840
It actually defers the positioning

1192
00:54:28,840 --> 00:54:31,490
and sizing to the container that it's in,

1193
00:54:31,490 --> 00:54:33,350
that's why we put our CardViews

1194
00:54:33,350 --> 00:54:35,720
that were in that ForEach into an HStack.

1195
00:54:35,720 --> 00:54:39,720
So their ForEach is deferring
letting the HStack decide.

1196
00:54:39,720 --> 00:54:44,350
And a hidden thing that's going
on with layout is modifiers,

1197
00:54:44,350 --> 00:54:46,740
like dot padding and others.

1198
00:54:46,740 --> 00:54:50,550
They essentially contain
the View that they modify,

1199
00:54:50,550 --> 00:54:51,880
if you wanna think of it that way,

1200
00:54:51,880 --> 00:54:55,090
and some of them, like padding, do layout.

1201
00:54:55,090 --> 00:54:56,930
So let's talk a little bit more in detail

1202
00:54:56,930 --> 00:55:00,340
about HStack and VStack,
the most important one

1203
00:55:00,340 --> 00:55:03,140
or at least the one that's
doing the most layout.

1204
00:55:03,140 --> 00:55:05,440
The way that the stacks
divide up the space

1205
00:55:05,440 --> 00:55:08,790
that they're offered is
kind of divided equally

1206
00:55:08,790 --> 00:55:13,400
and then they offer it to the
least flexible Views first.

1207
00:55:13,400 --> 00:55:15,120
So what do we mean by that?

1208
00:55:15,120 --> 00:55:20,120
So an example of a very space
inflexible View is Image.

1209
00:55:20,770 --> 00:55:22,970
So we haven't talked about image yet

1210
00:55:22,970 --> 00:55:24,640
but it's just a View that shows an image,

1211
00:55:24,640 --> 00:55:25,770
as you might imagine.

1212
00:55:25,770 --> 00:55:28,640
And of course it wants to
be the size of that image,

1213
00:55:28,640 --> 00:55:30,780
pretty inflexible in that way.

1214
00:55:30,780 --> 00:55:32,710
So generally the Images are gonna get

1215
00:55:32,710 --> 00:55:34,710
the space they want first.

1216
00:55:34,710 --> 00:55:37,560
Another example of a
pretty inflexible View,

1217
00:55:37,560 --> 00:55:40,750
not quite as inflexible as Image, is Text.

1218
00:55:40,750 --> 00:55:42,850
Text always wants to size itself

1219
00:55:42,850 --> 00:55:46,290
to fit the text inside
of it understandably

1220
00:55:46,290 --> 00:55:48,830
but it does have a way to
be a little bit smaller

1221
00:55:48,830 --> 00:55:50,840
and put dot dot dot at the end of the text

1222
00:55:50,840 --> 00:55:52,880
as we'll talk about in a second here.

1223
00:55:52,880 --> 00:55:56,540
So it's not quite as
inflexible as an Image.

1224
00:55:56,540 --> 00:55:59,060
And most Views are very flexible.

1225
00:55:59,060 --> 00:56:00,570
For example, all the Shapes,

1226
00:56:00,570 --> 00:56:02,980
like RoundedRectangle that we saw,

1227
00:56:02,980 --> 00:56:05,670
whatever size you offer it,
it's pretty much gonna take that

1228
00:56:05,670 --> 00:56:09,190
and it's going to draw itself
appropriately in that size.

1229
00:56:09,190 --> 00:56:13,350
So after one of these
Views chooses its own size

1230
00:56:13,350 --> 00:56:14,960
and takes whatever size it wants,

1231
00:56:14,960 --> 00:56:18,260
that size is removed from the space

1232
00:56:18,260 --> 00:56:20,290
that the stack is trying to allocate

1233
00:56:20,290 --> 00:56:24,360
and then it goes on to the
next least flexible Views

1234
00:56:24,360 --> 00:56:26,633
and rinse and repeat until
all the space is used up.

1235
00:56:26,633 --> 00:56:28,090
So it's as simple as that.

1236
00:56:28,090 --> 00:56:32,840
That's how HStack and VStack
apportion, their space.

1237
00:56:32,840 --> 00:56:35,430
Now, after all the Views
have chosen their size

1238
00:56:35,430 --> 00:56:40,070
then the HStack and VStack
sizes itself to fit those Views

1239
00:56:40,070 --> 00:56:42,920
with whatever little spacing
in between that it provides.

1240
00:56:44,000 --> 00:56:47,330
HStack and VStack work
with any View, of course,

1241
00:56:47,330 --> 00:56:48,270
but there's a couple of them

1242
00:56:48,270 --> 00:56:50,220
that I'm gonna introduce to you here

1243
00:56:50,220 --> 00:56:52,200
that really help with layout.

1244
00:56:52,200 --> 00:56:54,540
One of them is called Spacer.

1245
00:56:54,540 --> 00:56:58,390
So a Spacer is just a View
that takes all of the space

1246
00:56:58,390 --> 00:56:59,640
that's offered to it.

1247
00:56:59,640 --> 00:57:02,390
So if you give it space,
it's gonna use that space.

1248
00:57:02,390 --> 00:57:04,610
And so it's used for filling in space.

1249
00:57:04,610 --> 00:57:06,360
Now it doesn't actually draw anything,

1250
00:57:06,360 --> 00:57:09,820
it just kind of uses up
space in an HStack or VStack,

1251
00:57:09,820 --> 00:57:11,740
that's why it's called a Spacer.

1252
00:57:11,740 --> 00:57:14,030
It has that minLength argument

1253
00:57:14,030 --> 00:57:16,990
which is the minimum
size that it should be

1254
00:57:16,990 --> 00:57:19,190
in the direction we're
laying out horizontally

1255
00:57:19,190 --> 00:57:22,330
or vertically, depending on
whether it's HStack or VStack,

1256
00:57:22,330 --> 00:57:24,000
although we usually don't specify

1257
00:57:24,000 --> 00:57:26,820
because the default for
that is the right amount

1258
00:57:26,820 --> 00:57:28,950
of space on this platform.

1259
00:57:28,950 --> 00:57:30,390
One thing that you're gonna start

1260
00:57:30,390 --> 00:57:31,853
to get used to as the quarter goes on,

1261
00:57:31,853 --> 00:57:35,040
that even though we're focusing on iOS,

1262
00:57:35,040 --> 00:57:39,250
you can use SwiftUI on
Apple Watch and Apple TV

1263
00:57:39,250 --> 00:57:42,450
and the spacing and the
layout is a little different

1264
00:57:42,450 --> 00:57:43,760
on these platforms.

1265
00:57:43,760 --> 00:57:47,390
And SwiftUI is really smart about saying,

1266
00:57:47,390 --> 00:57:50,340
I'm on an Apple watch so I'm
gonna use this much space

1267
00:57:50,340 --> 00:57:52,300
in my Spacer by default or whatever.

1268
00:57:52,300 --> 00:57:55,540
So that's why we really wanna
try and use these default

1269
00:57:55,540 --> 00:57:59,330
and not specify minLength
when we use Spacer.

1270
00:57:59,330 --> 00:58:01,605
Same thing with spacing
on the HStack itself,

1271
00:58:01,605 --> 00:58:02,471
HStack spacing.

1272
00:58:02,471 --> 00:58:03,470
And we don't wanna do that.

1273
00:58:03,470 --> 00:58:06,790
Even padding, generally
it's fine to put padding

1274
00:58:06,790 --> 00:58:08,880
but if you start putting numbers in there

1275
00:58:08,880 --> 00:58:12,350
and specifying exact paddings like we saw,

1276
00:58:12,350 --> 00:58:13,640
you're defeating a little bit

1277
00:58:13,640 --> 00:58:15,670
of the purpose of this
platform independence.

1278
00:58:15,670 --> 00:58:18,200
Now, sometimes you need it, you just do

1279
00:58:18,200 --> 00:58:21,740
but we try to use these
defaults as much as possible.

1280
00:58:21,740 --> 00:58:23,597
So another cool View to put in an HStack

1281
00:58:23,597 --> 00:58:25,620
or VStack is Divider.

1282
00:58:25,620 --> 00:58:28,270
So Divider just draws a dividing line,

1283
00:58:28,270 --> 00:58:29,680
again, platform specific,

1284
00:58:29,680 --> 00:58:31,880
it depends what a divider looks like

1285
00:58:31,880 --> 00:58:33,960
in the context that it's in.

1286
00:58:33,960 --> 00:58:37,210
Of course, the Divider
is not like a Spacer,

1287
00:58:37,210 --> 00:58:38,400
it doesn't use all up all that space.

1288
00:58:38,400 --> 00:58:41,520
It only uses enough
space to draw that line.

1289
00:58:41,520 --> 00:58:44,370
And the line obviously goes
opposite to the direction

1290
00:58:44,370 --> 00:58:45,220
that we're laying out.

1291
00:58:45,220 --> 00:58:47,980
So for an HStack, the
divider is obviously gonna be

1292
00:58:47,980 --> 00:58:49,440
a vertical line, and for a VStack,

1293
00:58:49,440 --> 00:58:51,640
it's gonna be a horizontal line.

1294
00:58:51,640 --> 00:58:54,990
So you're almost certainly
gonna want to use one

1295
00:58:54,990 --> 00:58:58,180
or both of these in your
next homework assignment.

1296
00:58:58,180 --> 00:59:01,920
And they're really valuable
for doing layout with stacks.

1297
00:59:01,920 --> 00:59:03,250
These HStacks and VStacks,

1298
00:59:03,250 --> 00:59:05,810
I told you that they're kind of choosing

1299
00:59:05,810 --> 00:59:10,810
which of its Views to offer
space to next priority wise

1300
00:59:11,350 --> 00:59:13,040
using this least flexible thing,

1301
00:59:13,040 --> 00:59:15,060
but you can actually override that

1302
00:59:15,060 --> 00:59:18,030
with this View modifier layoutPriority.

1303
00:59:18,030 --> 00:59:20,480
So here's an example of an HStack

1304
00:59:20,480 --> 00:59:22,870
that has a Text that's really important.

1305
00:59:22,870 --> 00:59:26,350
It's got an Image which we
know is very not flexible,

1306
00:59:26,350 --> 00:59:29,850
and so normally would get a
lot of attention from HStack.

1307
00:59:29,850 --> 00:59:33,550
And then it has another Text
which is less important.

1308
00:59:33,550 --> 00:59:38,420
So I've added the View
modifier dot layoutPriority 100

1309
00:59:38,420 --> 00:59:40,530
which I can pick any
number I want there really,

1310
00:59:40,530 --> 00:59:42,400
it doesn't matter, it's
a floating point number.

1311
00:59:42,400 --> 00:59:45,330
And that's more than the
default layoutPriority

1312
00:59:45,330 --> 00:59:46,290
which is zero.

1313
00:59:46,290 --> 00:59:48,820
So when this HStack
goes to offer its space,

1314
00:59:48,820 --> 00:59:51,610
it's going to offer this Text space first.

1315
00:59:51,610 --> 00:59:53,210
And that Text is gonna say,

1316
00:59:53,210 --> 00:59:54,880
well, sure, I wanna be this big

1317
00:59:54,880 --> 00:59:58,110
so I can fit this word,
important, all the way.

1318
00:59:58,110 --> 00:59:59,450
Then it's gonna say, okay,

1319
00:59:59,450 --> 01:00:01,600
well there's no other high priority ones.

1320
00:59:59,450 --> 01:00:01,600
well there's no other high priority ones.

1321
01:00:01,600 --> 01:00:03,770
There could be other ones
with different numbers.

1322
01:00:03,770 --> 01:00:05,950
It starts with the highest
priority and goes down.

1323
01:00:05,950 --> 01:00:07,650
And so now it goes to do the Image

1324
01:00:07,650 --> 01:00:09,930
because that's less
flexible than the Text,

1325
01:00:09,930 --> 01:00:13,010
Image gets it space and then
the unimportant text has

1326
01:00:13,010 --> 01:00:15,960
to fit itself into the space remaining.

1327
01:00:15,960 --> 01:00:17,250
And as we mentioned before,

1328
01:00:17,250 --> 01:00:19,530
when a Text doesn't get enough space,

1329
01:00:19,530 --> 01:00:23,270
it will put dot dot dot in there to elide

1330
01:00:23,270 --> 01:00:26,630
or shorten the text to
fit the space it did get.

1331
01:00:26,630 --> 01:00:28,040
It always wants to be its space.

1332
01:00:28,040 --> 01:00:31,680
It never wants to be larger
than its text fits in.

1333
01:00:31,680 --> 01:00:33,240
It always wants to be the exact size

1334
01:00:33,240 --> 01:00:34,970
but if it's forced to be smaller,

1335
01:00:34,970 --> 01:00:36,683
it knows how to do dot dot dot.

1336
01:00:37,650 --> 01:00:40,987
Another and significant part of HStack

1337
01:00:40,987 --> 01:00:44,580
and VStack's layout is their alignment.

1338
01:00:44,580 --> 01:00:48,350
So imagine you have a VStack,
a vertical stack of Views.

1339
01:00:48,350 --> 01:00:50,960
And what if those Views
pick their own size

1340
01:00:50,960 --> 01:00:53,060
and they're not the same width.

1341
01:00:53,060 --> 01:00:56,030
So they can't all be kind
of filling the whole width

1342
01:00:56,030 --> 01:00:57,490
of this vertical stack.

1343
01:00:57,490 --> 01:00:59,800
So does the VStack left align them

1344
01:00:59,800 --> 01:01:02,070
or center them or right align them?

1345
01:01:02,070 --> 01:01:04,810
How does it know where to put them?

1346
01:01:04,810 --> 01:01:07,610
Well, there's actually an
argument to VStack and HStack.

1347
01:01:07,610 --> 01:01:08,477
We already know that VStack

1348
01:01:08,477 --> 01:01:11,030
and HStack have the argument spacing

1349
01:01:11,030 --> 01:01:13,560
which determines the
spacing between the Views.

1350
01:01:13,560 --> 01:01:16,120
It also has another argument, alignment.

1351
01:01:16,120 --> 01:01:19,580
And alignment takes an
alignment guide as its argument.

1352
01:01:19,580 --> 01:01:23,260
And one of the alignment
guides, for example, is leading.

1353
01:01:23,260 --> 01:01:27,250
Now, why leading here instead of left?

1354
01:01:27,250 --> 01:01:28,710
If I just want this VStack

1355
01:01:28,710 --> 01:01:30,290
to have all of these be left aligned,

1356
01:01:30,290 --> 01:01:31,237
why don't I say dot left?

1357
01:01:31,237 --> 01:01:34,350
And in fact, there's no
such thing as dot left.

1358
01:01:34,350 --> 01:01:38,130
And dot leading means to have the things

1359
01:01:38,130 --> 01:01:41,460
in the VStack line up so
that their edges start

1360
01:01:41,460 --> 01:01:44,050
from where text comes from.

1361
01:01:44,050 --> 01:01:46,460
In different languages
sometimes the text comes

1362
01:01:46,460 --> 01:01:48,220
from the right and moves to the left,

1363
01:01:48,220 --> 01:01:49,840
like Hebrew and Arabic.

1364
01:01:49,840 --> 01:01:54,470
So we want our VStacks
to generally match up

1365
01:01:54,470 --> 01:01:56,373
with that text coming from that side.

1366
01:01:57,750 --> 01:02:00,460
Text baselines can also be lined up.

1367
01:02:00,460 --> 01:02:04,020
So HStacks, well, it only
makes sense in an HStack.

1368
01:02:04,020 --> 01:02:06,450
You can line it up so that
the bottom of the text,

1369
01:02:06,450 --> 01:02:09,380
even if they're different
fonts, will all be lined up.

1370
01:02:09,380 --> 01:02:11,900
For those of you know about
fonts, there are two baselines.

1371
01:02:11,900 --> 01:02:12,830
I'm not gonna talk about that

1372
01:02:12,830 --> 01:02:15,150
but you can line up with
the first text baseline

1373
01:02:15,150 --> 01:02:18,570
or the second text
baseline in your HStack.

1374
01:02:18,570 --> 01:02:20,800
You can even define your own things

1375
01:02:20,800 --> 01:02:23,680
to line up alignment guides.

1376
01:02:23,680 --> 01:02:26,210
And that's a little beyond
the scope of this course.

1377
01:02:26,210 --> 01:02:29,250
So we're just gonna use the
built in ones like dot center

1378
01:02:29,250 --> 01:02:31,280
which is usually the default alignment is

1379
01:02:31,280 --> 01:02:32,870
to center the thing in the middle

1380
01:02:32,870 --> 01:02:34,870
of the VStack or the HStack.

1381
01:02:34,870 --> 01:02:35,810
But there's also top

1382
01:02:35,810 --> 01:02:38,280
and bottom trailing
leading all these things.

1383
01:02:38,280 --> 01:02:40,290
As you can imagine, when
you just start typing

1384
01:02:40,290 --> 01:02:42,540
in an Xcode, VStack alignment colon,

1385
01:02:42,540 --> 01:02:44,330
of course, Xcode will
help you and tell you

1386
01:02:44,330 --> 01:02:46,523
what all those built-ins are.

1387
01:02:48,620 --> 01:02:50,746
That's it for stacks.

1388
01:02:50,746 --> 01:02:52,130
Stacks are very important.

1389
01:02:52,130 --> 01:02:54,220
But there's this other thing, modifiers,

1390
01:02:54,220 --> 01:02:57,430
like dot padding, that I said kind of act

1391
01:02:57,430 --> 01:03:00,180
like essentially container Views.

1392
01:03:00,180 --> 01:03:03,460
Remember that these things,
dot padding, et cetera,

1393
01:03:03,460 --> 01:03:05,370
they return a View.

1394
01:03:05,370 --> 01:03:07,320
And you might've thought
they just return a View

1395
01:03:07,320 --> 01:03:09,620
so that we could then send them another,

1396
01:03:09,620 --> 01:03:12,050
call another function on
them, dot foregroundColor

1397
01:03:12,050 --> 01:03:14,060
and then that gives us a View back,

1398
01:03:14,060 --> 01:03:15,030
we call dot padding on that.

1399
01:03:15,030 --> 01:03:18,810
And that gives us a View back
and call dot font on that.

1400
01:03:18,810 --> 01:03:20,850
So it's not just to give us a View back

1401
01:03:20,850 --> 01:03:23,150
so we can call another function on it.

1402
01:03:23,150 --> 01:03:26,880
Those Views that come back
might actually be participating

1403
01:03:26,880 --> 01:03:28,590
in the layout.

1404
01:03:28,590 --> 01:03:30,560
Now, most of them don't participate,

1405
01:03:30,560 --> 01:03:32,320
like font and foregroundColor.

1406
01:03:32,320 --> 01:03:36,380
They're not affecting layouts
so any space they're offered

1407
01:03:36,380 --> 01:03:38,010
by an HStack or some other container,

1408
01:03:38,010 --> 01:03:42,290
they're just gonna pass it on
to whatever View they contain.

1409
01:03:42,290 --> 01:03:44,010
For the purposes of this
slide, we're gonna think

1410
01:03:44,010 --> 01:03:48,170
of a View that these modifiers
modify as being contained

1411
01:03:48,170 --> 01:03:52,440
by that View that the modifier
returns which it kind of is.

1412
01:03:52,440 --> 01:03:56,860
We're gonna see how these View
modifiers are made next week,

1413
01:03:56,860 --> 01:04:00,020
probably, or the week after,
depending on how things go.

1414
01:04:00,020 --> 01:04:01,670
And you'll see that kind of really

1415
01:04:01,670 --> 01:04:03,420
what's happening is that it's containing

1416
01:04:03,420 --> 01:04:04,980
the View it's modifying.

1417
01:04:04,980 --> 01:04:08,830
What about these modifiers
that actually participate

1418
01:04:08,830 --> 01:04:10,960
in the layout process like padding.

1419
01:04:10,960 --> 01:04:12,840
Let's look at padding.

1420
01:04:12,840 --> 01:04:16,580
The View that's returned by
dot padding, this modifier,

1421
01:04:16,580 --> 01:04:20,560
it offers the View that
it's modifying a space

1422
01:04:20,560 --> 01:04:23,450
that's the same size as was offered to it

1423
01:04:23,450 --> 01:04:25,910
but reduced by 10 points in this case,

1424
01:04:25,910 --> 01:04:26,880
whatever the padding is.

1425
01:04:26,880 --> 01:04:28,700
It might be if that 10 is not there,

1426
01:04:28,700 --> 01:04:31,870
then it would be whatever
system appropriate padding.

1427
01:04:31,870 --> 01:04:33,970
It's essentially removing that 10

1428
01:04:33,970 --> 01:04:36,620
because it knows it's
supposed to provide the 10.

1429
01:04:36,620 --> 01:04:38,820
And then that View that's returned

1430
01:04:38,820 --> 01:04:41,160
by padding chooses its own size

1431
01:04:41,160 --> 01:04:43,600
to be whatever size the thing

1432
01:04:43,600 --> 01:04:46,300
that it's modifying
ended up being plus 10.

1433
01:04:46,300 --> 01:04:47,670
So that's what padding does,

1434
01:04:47,670 --> 01:04:51,500
it adds 10 points around the outside

1435
01:04:51,500 --> 01:04:53,970
or whatever edges you say.

1436
01:04:53,970 --> 01:04:55,480
Another thing is modifying.

1437
01:04:55,480 --> 01:04:59,430
So you see how dot padding
modifier is just a View

1438
01:04:59,430 --> 01:05:01,900
that participates in the layout.

1439
01:05:01,900 --> 01:05:03,440
What's another example of this?

1440
01:05:03,440 --> 01:05:05,340
You've already used it in your homework,

1441
01:05:05,340 --> 01:05:07,350
dot aspectRatio.

1442
01:05:07,350 --> 01:05:10,420
The View that's returned by
dot aspectRatio modifier,

1443
01:05:10,420 --> 01:05:12,770
it takes the space offered to it

1444
01:05:12,770 --> 01:05:15,060
and it picks a size for itself

1445
01:05:15,060 --> 01:05:18,040
that's either smaller
than that offered size

1446
01:05:18,040 --> 01:05:19,760
and has the aspect ratio,

1447
01:05:19,760 --> 01:05:23,040
that's if we choose the dot
fit option of aspectRatio,

1448
01:05:23,040 --> 01:05:26,270
or it could be bigger than
the size that's offered to it,

1449
01:05:26,270 --> 01:05:30,610
that's the dot fill option that
uses all the offered space.

1450
01:05:30,610 --> 01:05:33,090
And so yes, it is possible
when you're a View,

1451
01:05:33,090 --> 01:05:34,590
when you're offered a
certain amount of space,

1452
01:05:34,590 --> 01:05:37,210
you can choose your size to be larger.

1453
01:05:37,210 --> 01:05:39,060
Now that's rare.

1454
01:05:39,060 --> 01:05:41,390
We don't generally want
Views kind of spilling out

1455
01:05:41,390 --> 01:05:44,360
all over each other, but it makes sense,

1456
01:05:44,360 --> 01:05:47,780
like in this aspectRatio
fill, maybe that makes sense.

1457
01:05:47,780 --> 01:05:51,090
So then the aspectRatio
View that's now sized itself

1458
01:05:51,090 --> 01:05:55,230
to have that aspect ratio,
offers the space that it chose

1459
01:05:55,230 --> 01:05:58,850
to whatever View it's
modifying, like our CardView.

1460
01:05:58,850 --> 01:06:00,920
So our CardView fits itself then

1461
01:06:00,920 --> 01:06:03,063
in that nice aspect ratio space.

1462
01:06:04,550 --> 01:06:08,370
So let's see an example
of a full layout happening

1463
01:06:08,370 --> 01:06:10,830
in the size being passed
around and things like that.

1464
01:06:10,830 --> 01:06:14,810
So here's an HStack
similar to the one we have

1465
01:06:14,810 --> 01:06:17,910
in our Memorize game, not exactly the same

1466
01:06:17,910 --> 01:06:19,430
but very very similar.

1467
01:06:19,430 --> 01:06:23,310
How is the space for
this thing apportioned?

1468
01:06:23,310 --> 01:06:24,640
Well, the first thing to understand is

1469
01:06:24,640 --> 01:06:27,510
that the first View that's
gonna be offered the space

1470
01:06:27,510 --> 01:06:31,880
into which this whole green
thing goes is that padding View.

1471
01:06:31,880 --> 01:06:33,130
It's the outermost View.

1472
01:06:33,130 --> 01:06:37,630
It's actually the View that
is this whole thing in the end

1473
01:06:37,630 --> 01:06:40,080
but it's gonna be offered
whatever space is available

1474
01:06:40,080 --> 01:06:42,640
for this whole green construct here.

1475
01:06:42,640 --> 01:06:45,940
Now what it's going to
do, it's going to reduce,

1476
01:06:45,940 --> 01:06:48,510
take 10 points, off the edges of it

1477
01:06:48,510 --> 01:06:52,470
and pass that space that's
left onto the next View

1478
01:06:52,470 --> 01:06:56,650
which is the View returned by
the foregroundColor modifier.

1479
01:06:56,650 --> 01:06:59,630
Now that modifier isn't really
participating in the layout,

1480
01:06:59,630 --> 01:07:01,820
doesn't really have any effect on the size

1481
01:07:01,820 --> 01:07:02,850
and position the thing,

1482
01:07:02,850 --> 01:07:07,430
so it just passes that on
untouched to the HStack.

1483
01:07:07,430 --> 01:07:11,310
Now, the HStack, as we know,
is big time layout View.

1484
01:07:11,310 --> 01:07:15,240
It's going to divide up its
space starting out equally

1485
01:07:15,240 --> 01:07:18,960
and since the aspectRatios
aren't things like Images

1486
01:07:18,960 --> 01:07:20,760
or Texts that are fixed sizes,

1487
01:07:20,760 --> 01:07:23,450
it's going to end up
dividing the space equally

1488
01:07:23,450 --> 01:07:27,880
among all of the aspectRatio
Views in the ForEach,

1489
01:07:27,880 --> 01:07:30,610
because we know the
ForEach itself just defers

1490
01:07:30,610 --> 01:07:31,980
to the HStack.

1491
01:07:31,980 --> 01:07:34,390
So it's the aspectRatio Views now

1492
01:07:34,390 --> 01:07:36,960
that are being laid out in HStack.

1493
01:07:36,960 --> 01:07:39,990
Each aspectRatio View is
going to set its width

1494
01:07:39,990 --> 01:07:42,640
to be its share of the HStack's width

1495
01:07:42,640 --> 01:07:45,270
and then pick a height that
matches the aspect ratio,

1496
01:07:45,270 --> 01:07:49,660
the 2/3 aspect ratio, or if
the height is limited here,

1497
01:07:49,660 --> 01:07:51,160
it might be the other way around

1498
01:07:51,160 --> 01:07:53,650
where the aspectRatio View takes all

1499
01:07:53,650 --> 01:07:56,810
of the height it's offered
and instead chooses a width

1500
01:07:56,810 --> 01:07:58,560
that's less to fit.

1501
01:07:58,560 --> 01:07:59,630
So it could go either way.

1502
01:07:59,630 --> 01:08:02,470
It depends on whichever is gonna fit best

1503
01:08:02,470 --> 01:08:04,830
in the space that is offered.

1504
01:08:04,830 --> 01:08:07,680
Then the aspectRatio has picked that size.

1505
01:08:07,680 --> 01:08:09,630
It's going to offer that to the CardView

1506
01:08:09,630 --> 01:08:11,670
and the CardView is going
to use all of the space

1507
01:08:11,670 --> 01:08:13,410
because it's like a normal View,

1508
01:08:13,410 --> 01:08:16,950
whatever space you offer it,
pretty much it's going to use.

1509
01:08:16,950 --> 01:08:20,580
After all this offering
and sizing happens,

1510
01:08:20,580 --> 01:08:23,620
what's going to be the size
of this whole green View?

1511
01:08:23,620 --> 01:08:24,730
Well, it's gonna be the size

1512
01:08:24,730 --> 01:08:27,010
of whatever View.padding 10 returns

1513
01:08:27,010 --> 01:08:30,290
which is the result of
the HStack sizing itself

1514
01:08:30,290 --> 01:08:32,450
to fit all those aspectRatio Views

1515
01:08:32,450 --> 01:08:34,790
plus 10 points on all sides.

1516
01:08:34,790 --> 01:08:38,110
That's gonna be the size
of this whole green thing.

1517
01:08:38,110 --> 01:08:40,290
Let's talk about Views
that take all the space

1518
01:08:40,290 --> 01:08:41,610
that's offered to them.

1519
01:08:41,610 --> 01:08:43,420
Obviously things like RoundedRectangle,

1520
01:08:43,420 --> 01:08:44,820
it's real easy for them.

1521
01:08:44,820 --> 01:08:47,920
They just crawl around a
rectangle all the way to the edges

1522
01:08:47,920 --> 01:08:50,110
of what they're offered.

1523
01:08:50,110 --> 01:08:52,890
But what about custom Views like CardView?

1524
01:08:52,890 --> 01:08:55,220
CardView we built out of a ZStack

1525
01:08:55,220 --> 01:08:58,230
with RoundedRectangle, Texts,
we're building this thing.

1526
01:08:58,230 --> 01:09:00,900
It takes all the space
that's offered to it,

1527
01:09:00,900 --> 01:09:02,450
and there's no reason it shouldn't,

1528
01:09:02,450 --> 01:09:05,080
but it should really be adapting itself

1529
01:09:05,080 --> 01:09:06,950
to whatever space was offered.

1530
01:09:06,950 --> 01:09:09,170
And we really see this desperately

1531
01:09:09,170 --> 01:09:11,690
with the font size of the emoji.

1532
01:09:11,690 --> 01:09:13,110
And in your homework I asked you

1533
01:09:13,110 --> 01:09:16,440
for really small cards to
switch to a smaller font.

1534
01:09:16,440 --> 01:09:17,880
And I'm sure you'll probably realize,

1535
01:09:17,880 --> 01:09:21,290
wow, this is a really bad
solution to this problem.

1536
01:09:21,290 --> 01:09:22,540
And of course it is.

1537
01:09:22,540 --> 01:09:25,940
Really, what we need to do and
we're gonna do in our demo,

1538
01:09:25,940 --> 01:09:29,360
is pick a font size that is related

1539
01:09:29,360 --> 01:09:31,220
to the size that were offered.

1540
01:09:31,220 --> 01:09:33,540
Since we're gonna accept
the size offered to us,

1541
01:09:33,540 --> 01:09:36,720
we should pick this
font size that fits it.

1542
01:09:36,720 --> 01:09:40,600
So how does a View know
what space was offered to it

1543
01:09:40,600 --> 01:09:44,534
and can make that font
choosing decision, for example?

1544
01:09:44,534 --> 01:09:46,390
Well, we do that with a special View.

1545
01:09:46,390 --> 01:09:48,500
It's just a View, but
it is kind of special,

1546
01:09:48,500 --> 01:09:51,130
called GeometryReader.

1547
01:09:51,130 --> 01:09:53,680
And what you do with a GeometryReader View

1548
01:09:53,680 --> 01:09:56,570
is it wraps around whatever
thing that you want

1549
01:09:56,570 --> 01:09:58,970
to adapt to the size.

1550
01:09:58,970 --> 01:10:01,730
And so this would normally just
take whatever's in your body

1551
01:09:58,970 --> 01:10:01,730
And so this would normally just
take whatever's in your body

1552
01:10:01,730 --> 01:10:05,810
and you just wrap GeometryReader
around it like this.

1553
01:10:05,810 --> 01:10:07,420
GeometryReader is just a View.

1554
01:10:07,420 --> 01:10:11,093
And I'm not showing you
the obvious thing here.

1555
01:10:11,093 --> 01:10:13,540
GeometryReader, open parentheses, content,

1556
01:10:13,540 --> 01:10:16,090
colon, all this, just like
in HStack or whatever,

1557
01:10:16,090 --> 01:10:17,960
this is just the content.

1558
01:10:17,960 --> 01:10:20,840
But you do notice that it
has a little argument there

1559
01:10:20,840 --> 01:10:23,950
geometry in, similar to
how ForEach has an argument

1560
01:10:23,950 --> 01:10:25,740
which is the thing we're iterating over.

1561
01:10:25,740 --> 01:10:27,653
This also has an argument.

1562
01:10:28,660 --> 01:10:31,930
So this argument is of type GeometryProxy.

1563
01:10:32,985 --> 01:10:35,247
And this GeometryProxy is just a struct

1564
01:10:35,247 --> 01:10:37,067
and it has some nice information in there,

1565
01:10:37,067 --> 01:10:39,640
the most important of which
is the first one you see,

1566
01:10:39,640 --> 01:10:43,430
var size, that is the
size you're being offered.

1567
01:10:43,430 --> 01:10:46,320
The width and height CGSize
is a width and height

1568
01:10:46,320 --> 01:10:47,197
that you're being offered.

1569
01:10:47,197 --> 01:10:49,557
And you can use that size, it's in points,

1570
01:10:49,557 --> 01:10:51,420
and of course font sizes are in points.

1571
01:10:51,420 --> 01:10:52,760
So it's gonna be pretty easy for us

1572
01:10:52,760 --> 01:10:56,680
to pick a font size that
fits nicely in that size.

1573
01:10:56,680 --> 01:10:58,410
You see some other things here,

1574
01:10:58,410 --> 01:11:00,760
like the frame is
actually not only the size

1575
01:11:00,760 --> 01:11:03,360
but it's a rectangle where we are

1576
01:11:03,360 --> 01:11:05,280
in a certain coordinate space like

1577
01:11:05,280 --> 01:11:08,640
our parents coordinate space
or the global coordinate space

1578
01:11:08,640 --> 01:11:12,080
we can even look at if we like.

1579
01:11:12,080 --> 01:11:13,740
And I'm gonna talk about
the last one there,

1580
01:11:13,740 --> 01:11:16,143
safeAreaInsets, on the next slide.

1581
01:11:17,350 --> 01:11:19,850
One thing to remember
about GeometeryReader,

1582
01:11:19,850 --> 01:11:23,960
it's just a View but it always accepts

1583
01:11:23,960 --> 01:11:25,543
the space offered to it.

1584
01:11:26,560 --> 01:11:30,043
And I underline that because
it requires a little sinking in

1585
01:11:30,043 --> 01:11:33,890
because you don't wanna get
into a recursive loop here

1586
01:11:33,890 --> 01:11:37,090
where the GeometryReader
is reading its size

1587
01:11:37,090 --> 01:11:39,240
and then you're trying to
actually change the size

1588
01:11:39,240 --> 01:11:41,850
of the GeometryReader based
on the size that it read.

1589
01:11:41,850 --> 01:11:42,820
It doesn't work that way.

1590
01:11:42,820 --> 01:11:46,330
GeometryReaders always
accept the size, the space,

1591
01:11:46,330 --> 01:11:47,163
that's offered to them,

1592
01:11:47,163 --> 01:11:48,490
you have to think of it that way.

1593
01:11:48,490 --> 01:11:51,670
So GeometryReaders utility is just limited

1594
01:11:51,670 --> 01:11:54,210
to knowing what size you're being offered

1595
01:11:54,210 --> 01:11:56,670
and adjusting how you look on the inside,

1596
01:11:56,670 --> 01:11:58,130
that's what GeometryReader is for.

1597
01:11:58,130 --> 01:12:01,870
Don't try to twist GeometryReader
into something it's not.

1598
01:12:01,870 --> 01:12:03,510
It's just reading your geometry.,

1599
01:12:03,510 --> 01:12:04,800
it's called GeometryReader,
it reads the geometry

1600
01:12:06,720 --> 01:12:09,580
and you adapt to it so
you can change your font

1601
01:12:09,580 --> 01:12:10,693
and things like that.

1602
01:12:12,540 --> 01:12:14,520
The safe area thing that we mentioned,

1603
01:12:14,520 --> 01:12:15,353
that safeAreaInsets

1604
01:12:15,353 --> 01:12:18,130
that the GeometryReader tells you about.

1605
01:12:18,130 --> 01:12:21,740
The safe area is best
visualized by thinking

1606
01:12:21,740 --> 01:12:24,170
of the notch on the iPhone 10.

1607
01:12:24,170 --> 01:12:27,150
Most of the time, you
don't wanna be drawing up

1608
01:12:27,150 --> 01:12:29,120
on the size where the notch is up there,

1609
01:12:29,120 --> 01:12:30,400
not always though.

1610
01:12:30,400 --> 01:12:33,100
Sometimes you might actually
wanna draw up there.

1611
01:12:33,100 --> 01:12:34,890
And there's other safe area things too.

1612
01:12:34,890 --> 01:12:37,290
Sometimes Views will add adornments

1613
01:12:37,290 --> 01:12:40,090
or the way they kind of draw on screen

1614
01:12:40,090 --> 01:12:42,680
where they don't want you
drawing in certain spaces

1615
01:12:42,680 --> 01:12:46,250
so they kind of create this
safe area for you to draw in.

1616
01:12:46,250 --> 01:12:49,630
But if you wanna go outside
your safe area, you can,

1617
01:12:49,630 --> 01:12:50,990
and the way you do that is

1618
01:12:50,990 --> 01:12:54,387
by the View modifier here
edgesIgnoringSafeArea,

1619
01:12:54,387 --> 01:12:57,160
and you specify which edges that you want

1620
01:12:57,160 --> 01:12:58,930
to ignore that safe area.

1621
01:12:58,930 --> 01:13:01,730
So if I say edgesIgnoringSafeArea top,

1622
01:13:01,730 --> 01:13:04,070
then that ZStack and
everything in it is going

1623
01:13:04,070 --> 01:13:06,800
to ignore that there's
a safe area on the top

1624
01:13:06,800 --> 01:13:10,790
and just draw right up
underneath that notch up there.

1625
01:13:10,790 --> 01:13:13,530
And so it could be photo
viewing app or something,

1626
01:13:13,530 --> 01:13:15,460
maybe you wanna go all
the way to the edges

1627
01:13:15,460 --> 01:13:16,673
so you can do that here.

1628
01:13:18,870 --> 01:13:20,150
Let's talk a little bit about

1629
01:13:20,150 --> 01:13:22,510
how containers do what they do

1630
01:13:22,510 --> 01:13:25,870
which is offer space to their
Views and then position them.

1631
01:13:25,870 --> 01:13:29,320
It offers space with this modifier frame.

1632
01:13:29,320 --> 01:13:32,290
Now, I'm not gonna talk
about frame in detail here.

1633
01:13:32,290 --> 01:13:34,330
You can go look at the documentation frame

1634
01:13:34,330 --> 01:13:36,420
has quite a lot of arguments, you know,

1635
01:13:36,420 --> 01:13:39,910
ideal width, minimum width,
all of these kinds of things

1636
01:13:39,910 --> 01:13:44,910
to try and communicate to the
Views here is where the space

1637
01:13:44,920 --> 01:13:46,103
that I'm offering you.

1638
01:13:47,070 --> 01:13:48,410
So that's all for space.

1639
01:13:48,410 --> 01:13:51,160
And then once the View
has chosen its own size,

1640
01:13:51,160 --> 01:13:53,900
then we're gonna use
this modifier position

1641
01:13:53,900 --> 01:13:56,390
to put it somewhere in
our coordinate space

1642
01:13:56,390 --> 01:13:57,600
before the container.

1643
01:13:57,600 --> 01:14:00,900
So that's how they do that.

1644
01:14:00,900 --> 01:14:02,220
Pretty straightforward.

1645
01:14:02,220 --> 01:14:05,810
Stacks, for example, would use
their alignment information

1646
01:14:05,810 --> 01:14:08,630
and the spacing and all that

1647
01:14:08,630 --> 01:14:10,970
to figure out where their Views should go,

1648
01:14:10,970 --> 01:14:13,330
and it would set this CGPoint

1649
01:14:13,330 --> 01:14:16,340
which is the center of
the Views, at the CGPoint

1650
01:14:16,340 --> 01:14:17,820
for each of the Views.

1651
01:14:17,820 --> 01:14:20,280
By the way, it's kind of a
cool little modifier here

1652
01:14:20,280 --> 01:14:23,760
called offset which will offset the View

1653
01:14:23,760 --> 01:14:25,480
from wherever container put it.

1654
01:14:25,480 --> 01:14:27,530
So you can let the container do its job,

1655
01:14:27,530 --> 01:14:28,570
put the thing somewhere

1656
01:14:28,570 --> 01:14:31,340
and then you can still offset
it a little bit by something.

1657
01:14:31,340 --> 01:14:32,420
And the container could do this

1658
01:14:32,420 --> 01:14:33,680
but also someone else could do it.

1659
01:14:33,680 --> 01:14:34,950
The View could do it to itself.

1660
01:14:34,950 --> 01:14:36,500
I wanna be offset by a little bit.

1661
01:14:36,500 --> 01:14:38,540
So offset is kind of a fun little one.

1662
01:14:38,540 --> 01:14:39,890
We don't use offset that much

1663
01:14:39,890 --> 01:14:42,150
but I just wanna let you know it's there.

1664
01:14:42,150 --> 01:14:44,890
Now, for Memorize, we're
gonna use frame and position

1665
01:14:44,890 --> 01:14:46,780
to create our own container View

1666
01:14:46,780 --> 01:14:48,420
which is kind of like a stack.

1667
01:14:48,420 --> 01:14:52,350
It's gonna be called a Grid
and it's 2D, rows and columns,

1668
01:14:52,350 --> 01:14:54,270
instead of just a horizontal row

1669
01:14:54,270 --> 01:14:56,120
which is a pretty sad looking game,

1670
01:14:56,120 --> 01:14:58,137
if I do say so myself right now.

1671
01:14:58,137 --> 01:15:00,270
And we obviously want that
to be rows and columns.

1672
01:15:00,270 --> 01:15:03,190
We'll do that by using frame and position

1673
01:15:03,190 --> 01:15:04,590
to create our own container.

1674
01:15:06,690 --> 01:15:09,040
So we're gonna go back to the demo today.

1675
01:15:09,040 --> 01:15:11,710
I'd love to have time to
actually go do that container,

1676
01:15:11,710 --> 01:15:14,970
but we don't have that,
end of lecture three here.

1677
01:15:14,970 --> 01:15:17,640
I do have a short demo
though I'm going to do

1678
01:15:17,640 --> 01:15:19,890
just to show you how GeometryReader works.

1679
01:15:19,890 --> 01:15:22,450
And what we're gonna do is
what I've been talking about,

1680
01:15:22,450 --> 01:15:26,440
make our font, our emoji font, size better

1681
01:15:26,440 --> 01:15:30,000
to the space we're offered
using a GeometryReader.

1682
01:15:30,000 --> 01:15:31,710
While I'm there, I may
do a quick little thing

1683
01:15:31,710 --> 01:15:33,500
where I'm gonna show you the best way

1684
01:15:33,500 --> 01:15:35,940
or the kind of way we've all agreed on

1685
01:15:35,940 --> 01:15:39,260
to collect magic numbers in our code.

1686
01:15:39,260 --> 01:15:41,600
If you already have one in
there like cornerRadius 10,

1687
01:15:41,600 --> 01:15:43,500
that 10 is a magic number,

1688
01:15:43,500 --> 01:15:45,020
it really shouldn't be
embedded in our code.

1689
01:15:45,020 --> 01:15:46,930
There's kind of a canonical way in Swift

1690
01:15:46,930 --> 01:15:50,460
to take that out and put
it in its own little space

1691
01:15:50,460 --> 01:15:52,263
so it's well-documented and typed.

1692
01:15:54,130 --> 01:15:56,170
Now we'll start our next lecture though,

1693
01:15:56,170 --> 01:15:59,380
using GeometryReader and
also generics with protocols

1694
01:15:59,380 --> 01:16:01,450
and functions as types

1695
01:16:01,450 --> 01:16:05,290
to make this beautiful
little simple Grid View

1696
01:16:05,290 --> 01:16:06,440
that's just gonna be like an HStack.

1697
01:16:06,440 --> 01:16:10,030
We're gonna replace our HStack
by just using this Grid View

1698
01:16:10,030 --> 01:16:12,300
and make our cards be in a nice grid.

1699
01:16:12,300 --> 01:16:13,830
So let's hop into that demo

1700
01:16:13,830 --> 01:16:15,940
and then that'll be the
end of this lecture.

1701
01:16:15,940 --> 01:16:18,190
Now in your homework, you were asked

1702
01:16:18,190 --> 01:16:21,360
to adjust the font choice here

1703
01:16:21,360 --> 01:16:24,547
to fit really small cards
because small cards,

1704
01:16:24,547 --> 01:16:27,530
the font we chose,
large title was too big.

1705
01:16:27,530 --> 01:16:30,170
And that might have fixed
it just for small cards

1706
01:16:30,170 --> 01:16:32,720
but I made you do that almost to realize,

1707
01:16:32,720 --> 01:16:34,580
well, that's no good solution,

1708
01:16:34,580 --> 01:16:36,570
especially when we're in landscape

1709
01:16:36,570 --> 01:16:39,440
where even large title is way too small.

1710
01:16:39,440 --> 01:16:42,990
So what we really want is for our card

1711
01:16:42,990 --> 01:16:45,050
to pick a font that uses all the space.

1712
01:16:45,050 --> 01:16:47,280
That's really what we wanna do.

1713
01:16:47,280 --> 01:16:49,290
So how are we going to do that?

1714
01:16:49,290 --> 01:16:51,860
Well, we're gonna do
that with a special View.

1715
01:16:51,860 --> 01:16:54,180
It's another View, just
like HStack is a View

1716
01:16:54,180 --> 01:16:57,880
and ForEach is a View and
ZStack is a few, Text is a View.

1717
01:16:57,880 --> 01:16:59,570
These are all just Views.

1718
01:16:59,570 --> 01:17:02,730
There's a special View that is called

1719
01:17:02,730 --> 01:17:07,520
the GeometryReader View.

1720
01:17:07,520 --> 01:17:10,120
So GeometryReader has one argument

1721
01:17:10,120 --> 01:17:12,340
which is the content that it's going

1722
01:17:12,340 --> 01:17:14,090
to display inside of itself

1723
01:17:14,090 --> 01:17:17,113
which is just another View like our card,

1724
01:17:18,248 --> 01:17:20,100
the ZStack that will make our card,

1725
01:17:20,100 --> 01:17:24,330
but it has a nice argument
here called geometry,

1726
01:17:24,330 --> 01:17:28,200
just like ForEach was a View
that had an argument here

1727
01:17:28,200 --> 01:17:30,720
but it also had this content argument

1728
01:17:30,720 --> 01:17:34,470
and it provided the Card that
it was iterating through.

1729
01:17:34,470 --> 01:17:37,130
Same thing here,
GeometryReader, it has content,

1730
01:17:37,130 --> 01:17:41,050
asks for a View but it
provides this special geometry.

1731
01:17:41,050 --> 01:17:43,210
And we're gonna look
at this little variable

1732
01:17:43,210 --> 01:17:45,260
that is given to you inside here

1733
01:17:45,260 --> 01:17:46,590
'cause we can look at this and see

1734
01:17:46,590 --> 01:17:48,600
what the size of our View is.

1735
01:17:48,600 --> 01:17:52,041
Now notice that when we
put our code, our ZStack,

1736
01:17:52,041 --> 01:17:54,980
inside of a GeometryReader content,

1737
01:17:54,980 --> 01:17:58,120
we got these requires self dot thing.

1738
01:17:58,120 --> 01:18:02,458
So to go through here and
do a fix out of this one,

1739
01:18:02,458 --> 01:18:04,653
fix that one as well, pick that up.

1740
01:18:06,030 --> 01:18:07,660
So what is this?

1741
01:18:07,660 --> 01:18:10,772
Let's take a look at the
documentation for GeometryReader.

1742
01:18:10,772 --> 01:18:14,140
So I'm gonna do Option + click
to look at GeometryReader.

1743
01:18:14,140 --> 01:18:16,280
And you can see here
struct GeometryReader.

1744
01:18:16,280 --> 01:18:19,290
It's got a don't care called Content

1745
01:18:19,290 --> 01:18:21,440
where that Content is a View.

1746
01:18:21,440 --> 01:18:24,300
And so now, hopefully, you are starting

1747
01:18:24,300 --> 01:18:25,770
to understand what that means,

1748
01:18:25,770 --> 01:18:27,980
where Content is a View, right?

1749
01:18:27,980 --> 01:18:30,780
Content is a don't care,
View is a protocol.

1750
01:18:30,780 --> 01:18:32,940
So we've turned that don't care into a,

1751
01:18:32,940 --> 01:18:34,950
well we care a little bit, right?

1752
01:18:34,950 --> 01:18:38,220
We care that the Content of
a GeometryReader is a View,

1753
01:18:38,220 --> 01:18:40,320
but otherwise it can be anything it wants.

1754
01:18:41,450 --> 01:18:44,490
And so I'm gonna open
that in the documentation

1755
01:18:44,490 --> 01:18:46,080
and take a look, see what it says.

1756
01:18:46,080 --> 01:18:47,610
And here's the init.

1757
01:18:47,610 --> 01:18:50,530
You can see that it takes
this one argument content

1758
01:18:50,530 --> 01:18:53,940
which actually you should be
recognizing this syntax here

1759
01:18:53,940 --> 01:18:56,830
because really, it takes a function

1760
01:18:56,830 --> 01:18:59,540
that returns this Content don't care,

1761
01:18:59,540 --> 01:19:02,720
which we know is actually a
we care a little bit Content

1762
01:19:02,720 --> 01:19:06,430
where Content colon View so
we know it has to be a View.

1763
01:19:06,430 --> 01:19:09,762
And so that's a function,
function that takes an argument,

1764
01:19:09,762 --> 01:19:14,280
GeometryProxy, and returns
this don't care Content.

1765
01:19:14,280 --> 01:19:17,060
Don't worry about that @escaping there.

1766
01:19:17,060 --> 01:19:19,900
We'll be talking about
that in the weeks to come.

1767
01:19:19,900 --> 01:19:22,960
So let's click on this GeometryProxy

1768
01:19:22,960 --> 01:19:25,230
and see its decoration.

1769
01:19:25,230 --> 01:19:26,660
Here it is, and you can see it has

1770
01:19:26,660 --> 01:19:29,130
the things we talked about in the slides.

1771
01:19:29,130 --> 01:19:32,510
Now I'm gonna focus obviously
on the size right here.

1772
01:19:32,510 --> 01:19:34,890
So let's click on that.

1773
01:19:34,890 --> 01:19:37,410
And you can see that
size is just a CGSize,

1774
01:19:37,410 --> 01:19:38,807
it's get only, it's read only.

1775
01:19:38,807 --> 01:19:41,210
It's just going to tell
us the width and height

1776
01:19:41,210 --> 01:19:44,303
that we've been offered
to draw this View in.

1777
01:19:45,790 --> 01:19:47,430
So that's exactly what we want.

1778
01:19:47,430 --> 01:19:49,810
We want this geometry size right here.

1779
01:19:49,810 --> 01:19:51,630
And what I'm gonna do is I'm gonna have

1780
01:19:51,630 --> 01:19:54,570
my CardView take ownership

1781
01:19:54,570 --> 01:19:58,280
for setting its own font right here.

1782
01:19:58,280 --> 01:19:59,640
So it's gonna go to font.

1783
01:19:59,640 --> 01:20:02,550
So I'm no longer setting
the font in the game itself.

1784
01:19:59,640 --> 01:20:02,550
So I'm no longer setting
the font in the game itself.

1785
01:20:02,550 --> 01:20:04,670
I'm letting the Card set its own font

1786
01:20:04,670 --> 01:20:07,210
which is probably better
encapsulation anyway.

1787
01:20:07,210 --> 01:20:08,470
Why we're here, of course,

1788
01:20:08,470 --> 01:20:12,317
we don't need this colon
content thing just like HStack

1789
01:20:12,317 --> 01:20:13,390
and all these other things.

1790
01:20:13,390 --> 01:20:16,310
We can get rid of that and get rid of that

1791
01:20:16,310 --> 01:20:18,940
so this looks a lot cleaner there.

1792
01:20:18,940 --> 01:20:22,190
So we wanna do a font
here, so write some font,

1793
01:20:22,190 --> 01:20:25,640
whose size is based on that geometry size.

1794
01:20:25,640 --> 01:20:27,353
So I'm gonna create a system font,

1795
01:20:27,353 --> 01:20:29,810
just different ways to make
the system font right here,

1796
01:20:29,810 --> 01:20:30,930
styles and sizes.

1797
01:20:30,930 --> 01:20:33,718
So I'm just gonna pick size.

1798
01:20:33,718 --> 01:20:37,140
I want a CGFloat with
the size, the point size.

1799
01:20:37,140 --> 01:20:39,840
And remember the point
size of font is related

1800
01:20:39,840 --> 01:20:42,910
to the point width and
the point height there.

1801
01:20:42,910 --> 01:20:45,200
So I'm actually gonna pick the minimum

1802
01:20:45,200 --> 01:20:46,230
of the width to the height

1803
01:20:46,230 --> 01:20:47,920
'cause I don't necessarily want to depend

1804
01:20:47,920 --> 01:20:50,600
on knowing what my aspect ratio here is.

1805
01:20:50,600 --> 01:20:52,740
And so I'm just gonna pick
the minimum of those two

1806
01:20:52,740 --> 01:20:55,290
to make sure that I pick a font that fits.

1807
01:20:55,290 --> 01:21:00,290
So that's min geometry size width

1808
01:21:00,330 --> 01:21:03,570
and the geometry size height.

1809
01:21:03,570 --> 01:21:05,950
So I'm using that size var that we saw

1810
01:21:05,950 --> 01:21:08,840
that's in this GeometryProxy right here.

1811
01:21:08,840 --> 01:21:10,850
And maybe we could just try this.

1812
01:21:10,850 --> 01:21:13,070
Let's just pick a font size

1813
01:21:13,070 --> 01:21:15,440
that is the minimum of these two

1814
01:21:15,440 --> 01:21:16,930
and just see what this looks like.

1815
01:21:16,930 --> 01:21:17,973
So let's run this.

1816
01:21:20,470 --> 01:21:21,640
Look at that.

1817
01:21:21,640 --> 01:21:25,620
So that is a much closer size
and you even got smaller.

1818
01:21:25,620 --> 01:21:27,540
But this is actually a little too big.

1819
01:21:27,540 --> 01:21:30,030
It's got a little too big there.

1820
01:21:30,030 --> 01:21:33,920
Maybe that's just because plot point sizes

1821
01:21:33,920 --> 01:21:36,380
aren't exactly the width of the font.

1822
01:21:36,380 --> 01:21:39,330
It may probably closer
related to the height,

1823
01:21:39,330 --> 01:21:42,930
but also we do put a little
stroke around the edge

1824
01:21:42,930 --> 01:21:45,340
that takes away a little space as well.

1825
01:21:45,340 --> 01:21:49,290
So probably I need some sort
of constant multiplier here,

1826
01:21:49,290 --> 01:21:54,290
like maybe times 75%,
0.75, something like that.

1827
01:21:56,850 --> 01:22:00,540
And 75% actually looks pretty good.

1828
01:22:00,540 --> 01:22:03,493
Looks good when it's big,
looks good when it's small.

1829
01:22:04,640 --> 01:22:07,090
Before we finish up lecture three,

1830
01:22:07,090 --> 01:22:09,160
I wanna take just a moment here

1831
01:22:09,160 --> 01:22:12,240
to talk about a coding style issue.

1832
01:22:12,240 --> 01:22:15,780
I don't often talk too
much about coding style,

1833
01:22:15,780 --> 01:22:19,070
purely for time constraints
in these lectures

1834
01:22:19,070 --> 01:22:20,830
but this time I am going to mention this.

1835
01:22:20,830 --> 01:22:23,400
'cause it's a little bit of a segue

1836
01:22:23,400 --> 01:22:27,010
into how we're going to
structure our View code

1837
01:22:27,010 --> 01:22:29,500
to make it as readable as possible.

1838
01:22:29,500 --> 01:22:33,390
This problem I'm worried
about is these magic numbers.

1839
01:22:33,390 --> 01:22:35,710
We've created these blue magic numbers

1840
01:22:35,710 --> 01:22:38,590
and started to sprinkle them
out throughout our code.

1841
01:22:38,590 --> 01:22:41,406
That's not very good coding style.

1842
01:22:41,406 --> 01:22:43,610
SwiftUI is declarative.

1843
01:22:43,610 --> 01:22:46,600
We're essentially declaring
the UI directly here.

1844
01:22:46,600 --> 01:22:49,470
We're not calling functions
to tell it to build itself,

1845
01:22:49,470 --> 01:22:51,310
we are declaring it right here.

1846
01:22:51,310 --> 01:22:53,960
And when we do that,
these blue numbers end up

1847
01:22:53,960 --> 01:22:57,010
being kind of the knobs that we can turn

1848
01:22:57,010 --> 01:23:01,220
to fine tune the way our View
looks and get it just right.

1849
01:23:01,220 --> 01:23:02,390
Well, right now our knobs

1850
01:23:02,390 --> 01:23:04,870
are just spread all over the place here.

1851
01:23:04,870 --> 01:23:08,560
Really nice if we could
have a control panel.

1852
01:23:08,560 --> 01:23:11,870
So I'm going to create
a little control panel.

1853
01:23:11,870 --> 01:23:15,650
I'm gonna comment here to
MARK it drawing constants,

1854
01:23:15,650 --> 01:23:16,930
I'm gonna call it,

1855
01:23:16,930 --> 01:23:19,800
and put all my drawing constants down here

1856
01:23:19,800 --> 01:23:24,130
as just vars and lets and
functions on my struct.

1857
01:23:24,130 --> 01:23:26,900
And this idea of putting vars and lets

1858
01:23:26,900 --> 01:23:28,820
and functions in your struct

1859
01:23:28,820 --> 01:23:32,070
to clean up or fix magic numbers

1860
01:23:32,070 --> 01:23:34,540
in your View, really important.

1861
01:23:34,540 --> 01:23:38,530
You're gonna see that
most Views have a few vars

1862
01:23:38,530 --> 01:23:40,360
and lets and funcs down here

1863
01:23:40,360 --> 01:23:44,930
to make this look as clean and
understandable as possible.

1864
01:23:44,930 --> 01:23:48,980
So let's use this idea to get
these magic numbers out here.

1865
01:23:48,980 --> 01:23:50,390
These happened to be constants.

1866
01:23:50,390 --> 01:23:52,430
So I'm gonna use let.

1867
01:23:52,430 --> 01:23:55,280
Remember, let is like var except

1868
01:23:55,280 --> 01:23:57,450
for let means it's a constant.

1869
01:23:57,450 --> 01:24:01,270
So let's do the corner radius
up there, cornerRadius.

1870
01:24:01,270 --> 01:24:04,710
You might think you could
say cornerRadius equals 10

1871
01:24:04,710 --> 01:24:07,870
but this doesn't work and
I'm gonna show you why here.

1872
01:24:07,870 --> 01:24:10,580
If you hold down the option key, remember,

1873
01:24:10,580 --> 01:24:13,880
and click, it'll tell you the declaration

1874
01:24:13,880 --> 01:24:16,340
of this thing that you clicked on.

1875
01:24:16,340 --> 01:24:17,920
In our case, it's our cornerRadius

1876
01:24:17,920 --> 01:24:20,820
and it has been typed as an Int.

1877
01:24:20,820 --> 01:24:23,930
Remember that if we say
let a var equal something

1878
01:24:23,930 --> 01:24:26,907
and we don't specify it's
type, Swift will infer it.

1879
01:24:26,907 --> 01:24:28,730
And here it's looking at this 10

1880
01:24:28,730 --> 01:24:31,370
and referring, looks like an Int.

1881
01:24:31,370 --> 01:24:33,100
That's not what we want.

1882
01:24:33,100 --> 01:24:37,340
All of these blue numbers
in here are CGFloats,

1883
01:24:37,340 --> 01:24:40,070
floating point numbers we use to draw.

1884
01:24:40,070 --> 01:24:42,670
Now, I can't even just say 10.0.

1885
01:24:42,670 --> 01:24:46,340
If I do that and Option +
click, it thinks it's a Double.

1886
01:24:46,340 --> 01:24:48,760
These are not double precision
floating point numbers.

1887
01:24:48,760 --> 01:24:52,810
This Double struct is not
the same as a CGFloat struct.

1888
01:24:52,810 --> 01:24:56,003
So I have to explicitly
type this, CGFloat.

1889
01:24:57,140 --> 01:25:01,290
And that's not necessarily
that burdensome or onerous,

1890
01:25:01,290 --> 01:25:03,640
it's kind of nice in
a way to remind myself

1891
01:25:03,640 --> 01:25:05,803
these are drawing constants down here.

1892
01:25:06,890 --> 01:25:07,800
Let's do our other ones.

1893
01:25:07,800 --> 01:25:10,300
We got the edgeLineWidth.

1894
01:25:10,300 --> 01:25:12,020
There's another constant we have up there,

1895
01:25:12,020 --> 01:25:15,930
that number three, and of
course we have this .75

1896
01:25:15,930 --> 01:25:19,070
which is really like a
scaling factor for our fonts.

1897
01:25:19,070 --> 01:25:21,137
I'm gonna call it fontScaleFactor,

1898
01:25:22,370 --> 01:25:24,723
that's also a CGFloat, 0.75.

1899
01:25:26,470 --> 01:25:28,520
Now that I have these down here,

1900
01:25:28,520 --> 01:25:31,550
I can replace all my
magic numbers with these

1901
01:25:31,550 --> 01:25:35,120
and this becomes the
knobs on my control panel.

1902
01:25:35,120 --> 01:25:35,953
So let's do that.

1903
01:25:35,953 --> 01:25:37,083
We've got this one.

1904
01:25:38,239 --> 01:25:41,283
I'm gonna copy and paste,
make this go a little quicker.

1905
01:25:42,670 --> 01:25:47,150
And over here, this three
is this edge line right here

1906
01:25:48,750 --> 01:25:53,693
and our fontScaleFactor
here is this .75 here.

1907
01:25:55,100 --> 01:25:55,940
This is nice.

1908
01:25:55,940 --> 01:26:00,460
This actually makes this
code read nicely as well,

1909
01:26:00,460 --> 01:26:02,210
pretty much like the English language,

1910
01:26:02,210 --> 01:26:03,890
trying to understand what's going on.

1911
01:26:03,890 --> 01:26:05,690
However, you notice it's introduced

1912
01:26:05,690 --> 01:26:08,020
a whole slew of errors here.

1913
01:26:08,020 --> 01:26:09,960
They're actually all the same error.

1914
01:26:09,960 --> 01:26:12,770
It's the dreaded explicit self dot

1915
01:26:12,770 --> 01:26:15,600
to make capture semantics explicit.

1916
01:26:15,600 --> 01:26:18,140
And we could just, maybe fix this one

1917
01:26:18,140 --> 01:26:20,110
and click here and then fix this one

1918
01:26:20,110 --> 01:26:21,280
and I click it and fix it,

1919
01:26:21,280 --> 01:26:23,750
but I'm gonna show you
a trick for avoiding

1920
01:26:23,750 --> 01:26:28,480
this self dot thing in this
common case of GeometryReader.

1921
01:26:28,480 --> 01:26:30,600
So whenever you do a GeometryReader,

1922
01:26:30,600 --> 01:26:32,760
the stuff inside is always gonna complain

1923
01:26:32,760 --> 01:26:33,880
about this self dot.

1924
01:26:33,880 --> 01:26:35,882
By the way, same thing with ForEach.

1925
01:26:35,882 --> 01:26:38,890
ForEach stuff inside is gonna
complain about self dot.

1926
01:26:38,890 --> 01:26:40,617
Not every View does that

1927
01:26:40,617 --> 01:26:43,960
but those two do and
they're commonly used.

1928
01:26:43,960 --> 01:26:45,370
I'm gonna create a func

1929
01:26:45,370 --> 01:26:50,370
which I'm gonna call
body for size, CGSize,

1930
01:26:50,801 --> 01:26:52,470
and it's gonna return my body,

1931
01:26:52,470 --> 01:26:55,570
so that's gonna be some View just like

1932
01:26:55,570 --> 01:26:59,020
I can have some View be
the type of this var,

1933
01:26:59,020 --> 01:27:02,680
I can have some View be the
return type of this func.

1934
01:27:02,680 --> 01:27:05,693
And I'm gonna put my body,
to cut it out of here,

1935
01:27:05,693 --> 01:27:09,940
and put it in here, and
then just call this function

1936
01:27:09,940 --> 01:27:13,570
in my GeometryReader, self.body

1937
01:27:13,570 --> 01:27:16,383
for the geometry size.

1938
01:27:18,600 --> 01:27:20,870
This code cleaned up
actually kind of nicely.

1939
01:27:20,870 --> 01:27:22,500
This makes perfect sense.

1940
01:27:22,500 --> 01:27:26,150
And this code now is no longer embedded

1941
01:27:26,150 --> 01:27:28,200
inside this GeometryReader like this

1942
01:27:28,200 --> 01:27:30,290
so you don't need these self dot.

1943
01:27:30,290 --> 01:27:31,867
So I can get rid of that one and that one

1944
01:27:31,867 --> 01:27:33,580
and that one and this one.

1945
01:27:33,580 --> 01:27:35,530
All those self dots are gone.

1946
01:27:35,530 --> 01:27:38,660
What's more here, I didn't
pass the entire geometry

1947
01:27:38,660 --> 01:27:42,630
to this body, just the
size, the geometry size var.

1948
01:27:42,630 --> 01:27:46,730
So down here, I don't
need to say geometry.size.

1949
01:27:46,730 --> 01:27:50,190
This geometry.size is now just size,

1950
01:27:50,190 --> 01:27:52,490
this size that I passed in.

1951
01:27:52,490 --> 01:27:54,890
So that made this code look a lot nicer

1952
01:27:54,890 --> 01:27:57,380
and I almost always recommend,

1953
01:27:57,380 --> 01:27:59,080
at least for the next couple of months

1954
01:27:59,080 --> 01:28:03,580
until they put that Swift
self dot change in there

1955
01:28:03,580 --> 01:28:06,560
so the self dot is not
causing this problem anymore.

1956
01:28:06,560 --> 01:28:09,890
This is a real clean way
to have this code not have

1957
01:28:09,890 --> 01:28:11,300
to worry about self dot.

1958
01:28:11,300 --> 01:28:15,363
And you can do the same thing
body for item in a ForEach

1959
01:28:16,351 --> 01:28:17,870
'cause ForEach is gonna cause

1960
01:28:17,870 --> 01:28:20,330
that self dot problem as well.

1961
01:28:20,330 --> 01:28:21,880
We could do one other thing here.

1962
01:28:21,880 --> 01:28:23,560
Here, I could have a func

1963
01:28:23,560 --> 01:28:26,403
for the font size called
fontSize for size,

1964
01:28:27,470 --> 01:28:30,830
have it return a font size
which is also a CGFloat,

1965
01:28:30,830 --> 01:28:35,350
and put this code right here down in here

1966
01:28:35,350 --> 01:28:39,113
so that this just reads fontSize for size.

1967
01:28:40,060 --> 01:28:43,150
You might think this is
a very simple expression,

1968
01:28:43,150 --> 01:28:46,420
I don't really need to turn
it into its own func here,

1969
01:28:46,420 --> 01:28:50,420
but again, you can't make this too simple.

1970
01:28:50,420 --> 01:28:52,700
You really want to have
this be simple as possible.

1971
01:28:52,700 --> 01:28:54,540
And sometimes you're
forced to make it simple.

1972
01:28:54,540 --> 01:28:56,230
These ifs, as I explained,

1973
01:28:56,230 --> 01:28:59,100
can't be arbitrarily complex expressions.

1974
01:28:59,100 --> 01:29:00,790
So sometimes this needs to be a function

1975
01:29:00,790 --> 01:29:02,660
that returns a Bool, not in this case,

1976
01:29:02,660 --> 01:29:04,770
'cause this is simple Bool.

1977
01:29:04,770 --> 01:29:08,300
But making these little
one liner functions

1978
01:29:08,300 --> 01:29:13,030
that make this body look
cleaner, very common.

1979
01:29:13,030 --> 01:29:14,940
Here, we might even not have

1980
01:29:14,940 --> 01:29:19,730
to have this fontScaleFactor
be its own separate let

1981
01:29:19,730 --> 01:29:21,800
because you can kind of
think of the font size

1982
01:29:21,800 --> 01:29:23,870
as just part of the drawing constants.

1983
01:29:23,870 --> 01:29:28,313
This is the constant font
size for a given size.

1984
01:29:29,540 --> 01:29:31,450
So that's it for lecture three.

1985
01:29:31,450 --> 01:29:34,260
And we're gonna dive right back in,

1986
01:29:34,260 --> 01:29:36,820
start with lecture four
and continue with this demo

1987
01:29:36,820 --> 01:29:40,980
and make our HStack up here be a 2D grid.

1988
01:29:40,980 --> 01:29:44,070
We're gonna learn a lot
of stuff doing that.

1989
01:29:44,070 --> 01:29:47,533
- [Narrator] For more, please
visit us at stanford.edu.

