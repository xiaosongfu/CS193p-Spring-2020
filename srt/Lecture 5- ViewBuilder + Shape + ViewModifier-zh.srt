1
00:00:00,541 --> 00:00:03,207
 （空气哇声） 

2
00:00:04,929 --> 00:00:06,580
 -[旁白]斯坦福大学。 

3
00:00:08,470 --> 00:00:10,300
 -[讲师]好的，第五课。 

4
00:00:10,300 --> 00:00:13,713
斯坦福CS193P 2020年春季。 

5
00:00:14,859 --> 00:00:18,219
今天我们将从一个小样开始

6
00:00:18,219 --> 00:00:21,189
记忆中的访问控制。 

7
00:00:21,190 --> 00:00:24,260
您已经了解了访问控制

8
00:00:24,260 --> 00:00:25,879
在阅读作业中

9
00:00:26,079 --> 00:00:29,859
我们实际上使用了访问控制

10
00:00:29,859 --> 00:00:32,579
在“记住”中，但是现在该应用访问控制了

11
00:00:32,579 --> 00:00:35,329
记住并继续使用

12
00:00:35,329 --> 00:00:36,449
而你应该使用它

13
00:00:36,450 --> 00:00:39,823
在您所有的SwiftUI编程中永无止境。 

14
00:00:41,130 --> 00:00:42,596
演示之后，我们要回来

15
00:00:42,796 --> 00:00:45,039
再谈一下ViewBuilder。 

16
00:00:45,039 --> 00:00:48,060
非常重要，非常简单的小概念

17
00:00:48,060 --> 00:00:50,929
我在上一讲中已经提到过几次

18
00:00:50,929 --> 00:00:54,159
但现在我们只想清楚地阐明

19
00:00:54,159 --> 00:00:55,715
 ViewBuilder的全部用途。 

20
00:00:55,716 --> 00:00:57,990
然后我们将讨论当天的主要话题， 

21
00:00:57,990 --> 00:00:59,084
这是形状。 

22
00:00:59,284 --> 00:01:01,859
如果我想绘制视图怎么办

23
00:01:01,859 --> 00:01:04,409
而不是从其他视图中删除我的视图？ 

24
00:01:04,409 --> 00:01:06,179
我怎么做？ 

25
00:01:06,180 --> 00:01:08,614
我们将在“记忆”中进行演示，在其中添加形状

26
00:01:08,614 --> 00:01:11,929
表情符号后面的那个小馅饼

27
00:01:12,129 --> 00:01:15,253
您在第一堂课中看到的

28
00:01:15,254 --> 00:01:18,466
然后我们进入动画主题

29
00:01:18,466 --> 00:01:21,340
我们将意识到动画非常重要

30
00:01:21,340 --> 00:01:24,259
在移动应用程序中，而且在Swift中超级简单

31
00:01:24,459 --> 00:01:27,419
在某些方面几乎是免费的， 

32
00:01:27,420 --> 00:01:29,239
但是当我们开始谈论动画时

33
00:01:29,239 --> 00:01:31,030
我们将迅速到达这一点

34
00:01:31,030 --> 00:01:33,250
在这里我们需要谈论另一个概念

35
00:01:33,250 --> 00:01:35,022
称为ViewModifiers。 

36
00:01:35,022 --> 00:01:36,750
 ViewModifiers是基础

37
00:01:36,750 --> 00:01:40,120
我们如何构建这些视图

38
00:01:40,120 --> 00:01:41,509
而且您到处都在使用ViewModifiers 

39
00:01:41,709 --> 00:01:44,746
甚至可能根本没有意识到您正在这样做

40
00:01:44,746 --> 00:01:47,950
我们将深入了解正在发生的事情

41
00:01:47,950 --> 00:01:50,283
在您编写的所有SwiftUI代码中。 

42
00:01:52,109 --> 00:01:56,040
顺便说一句，本周不需要遵循

43
00:01:56,040 --> 00:01:57,099
通过作业。 

44
00:01:57,299 --> 00:01:59,009
实际上，这周的功课

45
00:01:59,010 --> 00:02:00,980
甚至不会被记住。 

46
00:02:00,980 --> 00:02:03,289
是时候编写您自己的应用程序了

47
00:02:03,489 --> 00:02:04,500
从头开始。 

48
00:02:04,500 --> 00:02:08,229
但是我现在要做的访问控制功能

49
00:02:08,229 --> 00:02:10,030
是你必须申请的东西

50
00:02:10,030 --> 00:02:11,219
您的所有代码。 

51
00:02:11,219 --> 00:02:13,430
所以跟着记住

52
00:02:13,430 --> 00:02:15,495
可能是一个很好的学习经验。 

53
00:02:15,495 --> 00:02:18,969
在本季度末，我们很有可能会回来

54
00:02:19,169 --> 00:02:21,439
记住做功课

55
00:02:21,439 --> 00:02:23,500
您尚未完成记忆。 

56
00:02:23,500 --> 00:02:26,699
在那种情况下，我会尽力做到这一点

57
00:02:26,699 --> 00:02:30,669
这样我本周要向您展示的代码

58
00:02:30,669 --> 00:02:35,500
将来的作业中不必包括

59
00:02:35,500 --> 00:02:36,332
记住。 

60
00:02:36,332 --> 00:02:37,966
我不能百分百地承诺， 

61
00:02:37,966 --> 00:02:40,710
但我希望情况确实如此。 

62
00:02:40,710 --> 00:02:43,930
话虽如此，很多学生发现

63
00:02:43,930 --> 00:02:46,879
跟随或真正帮助他们学习， 

64
00:02:46,879 --> 00:02:51,120
所以我想我实际上建议您这样做。 

65
00:02:51,120 --> 00:02:54,129
因此，让我们从潜水开始

66
00:02:54,129 --> 00:02:57,823
将整个访问控制更改为“记住”。 

67
00:02:58,919 --> 00:03:03,609
现在，我们已经在记忆中使用过一次作为控件

68
00:03:03,610 --> 00:03:06,960
只有一次，就在这里，私人的。 

69
00:03:06,960 --> 00:03:10,030
访问控制就是控制访问

70
00:03:10,229 --> 00:03:14,219
不同的结构必须具有彼此的变量。 

71
00:03:14,219 --> 00:03:16,925
通过使该模型完全私有

72
00:03:16,925 --> 00:03:19,030
在我们的ViewModel中， 

73
00:03:19,030 --> 00:03:23,460
我们已经迫使ViewModel制作这种无功卡

74
00:03:23,460 --> 00:03:25,117
以便视图可以获取卡片， 

75
00:03:25,117 --> 00:03:28,650
当然我们要有这个意图

76
00:03:28,650 --> 00:03:30,500
这样，如果有人想更改模型， 

77
00:03:30,699 --> 00:03:34,417
他们必须表达自己的意图，如何做到这一点

78
00:03:34,417 --> 00:03:36,870
很好，这使它变得私有。 

79
00:03:36,870 --> 00:03:40,439
但是，我们可以更进一步。 

80
00:03:40,639 --> 00:03:44,169
在我们的模型中，卡片本身

81
00:03:44,169 --> 00:03:47,889
可能想成为私人的。 

82
00:03:47,889 --> 00:03:48,869
这是为什么？ 

83
00:03:48,870 --> 00:03:51,539
好吧，我们不要任何人进来

84
00:03:51,539 --> 00:03:53,000
并把这些卡片弄糟。 

85
00:03:53,000 --> 00:03:54,659
设置为isMatched 

86
00:03:54,659 --> 00:03:57,099
甚至将它们正面朝上或朝下放置。 

87
00:03:57,099 --> 00:04:00,323
卡是否匹配完全在权限范围内

88
00:04:00,323 --> 00:04:02,310
此MemoryGame模型。 

89
00:04:02,509 --> 00:04:05,669
只有它知道卡是否应该匹配

90
00:04:05,669 --> 00:04:08,399
所有逻辑都在选择卡中。 

91
00:04:08,400 --> 00:04:11,750
因此，我们真的想将此私有化。 

92
00:04:11,949 --> 00:04:15,000
但是将其私有化实际上将是一个问题。 

93
00:04:15,000 --> 00:04:17,579
如果我们回到这里，看看这行代码

94
00:04:17,579 --> 00:04:20,490
并与那里的那个人一起编译它， 

95
00:04:20,490 --> 00:04:21,579
您可以看到我们收到错误消息。 

96
00:04:21,779 --> 00:04:23,869
提示无法访问卡

97
00:04:23,870 --> 00:04:26,240
由于私人保护水平。 

98
00:04:26,240 --> 00:04:28,483
实际上，这些卡现在是私人的

99
00:04:28,483 --> 00:04:32,110
因此不再允许使用ViewModel 

100
00:04:32,110 --> 00:04:33,485
访问此变量。 

101
00:04:33,685 --> 00:04:35,846
但是ViewModel确实需要访问

102
00:04:35,846 --> 00:04:38,199
至少要阅读卡片。 

103
00:04:38,199 --> 00:04:41,240
我们还要如何在用户界面中显示卡片？ 

104
00:04:41,240 --> 00:04:44,079
因此，我们不能真正将其私有化， 

105
00:04:44,079 --> 00:04:46,469
但是我们可以使用不同的访问控制级别

106
00:04:46,470 --> 00:04:48,600
设置好了。 

107
00:04:48,600 --> 00:04:53,600
私有集意味着将其设置为私有， 

108
00:04:53,610 --> 00:04:56,391
但不是。 

109
00:04:56,391 --> 00:04:58,670
这正是我们在这种情况下想要的。 

110
00:04:58,670 --> 00:05:00,970
我们希望人们能够看一下我们的卡片

111
00:05:00,970 --> 00:05:03,879
因此他们可以将它们放在用户界面中，进行显示。 

112
00:05:04,079 --> 00:05:07,019
但是，在更换卡片时， 

113
00:05:07,019 --> 00:05:10,089
我们绝对希望为我们自己保留。 

114
00:05:10,089 --> 00:05:14,992
因此，私有集是要设置的真正的通用访问控制。 

115
00:05:16,240 --> 00:05:21,240
现在，访问控制不仅仅是我们在var上设置的功能。 

116
00:05:21,540 --> 00:05:23,860
这也是我们可以在功能上设置的

117
00:05:23,860 --> 00:05:26,910
和我们自己的内部计算机变量。 

118
00:05:26,910 --> 00:05:29,500
例如，indexOfTheOneAndOnlyFaceUpCard 

119
00:05:29,699 --> 00:05:32,439
在我们的模型中，这纯粹是私人的事情。 

120
00:05:32,439 --> 00:05:35,920
这是我们要弄清楚怎么做的私人逻辑

121
00:05:35,920 --> 00:05:37,199
我们的配对游戏。 

122
00:05:37,199 --> 00:05:40,149
这绝对是要私密的。 

123
00:05:40,149 --> 00:05:43,089
我们当然不希望任何人设置此设置， 

124
00:05:43,089 --> 00:05:45,169
可能完全把我们搞砸了

125
00:05:45,170 --> 00:05:47,550
我们真的不希望有人看着它

126
00:05:47,550 --> 00:05:49,829
因为如果他们开始看它

127
00:05:49,829 --> 00:05:50,957
他们可能会依赖它

128
00:05:50,958 --> 00:05:54,750
然后我必须始终使用这种特殊策略

129
00:05:54,949 --> 00:05:56,682
按照我可能不想做的逻辑， 

130
00:05:56,682 --> 00:05:59,889
所以这就是我们要保持此私密性的原因。 

131
00:06:00,089 --> 00:06:02,099
当然选择不能是私有的。 

132
00:06:02,100 --> 00:06:04,540
这是人们玩我们的游戏的方式

133
00:06:04,540 --> 00:06:07,490
而且我们的init不想成为私有的。 

134
00:06:07,490 --> 00:06:09,961
允许您使用私有初始化。 

135
00:06:09,961 --> 00:06:11,810
这是一种罕见的情况， 

136
00:06:11,810 --> 00:06:14,589
但是你可以让init只在你的结构内部使用

137
00:06:14,589 --> 00:06:18,332
创建也许将要使用的私有实例。 

138
00:06:19,269 --> 00:06:21,719
现在struct Card在这里很有意思。 

139
00:06:21,720 --> 00:06:25,079
您可能在想，哦，私人场景，私人场景， 

140
00:06:25,279 --> 00:06:26,629
私有集，私有集。 

141
00:06:26,629 --> 00:06:29,269
我们不希望任何人设置这些。 

142
00:06:29,269 --> 00:06:32,769
但是，获取卡的唯一途径

143
00:06:32,769 --> 00:06:36,837
模型之外的对象就是通过此数组。 

144
00:06:36,838 --> 00:06:38,946
并且此数组已经是私有集。 

145
00:06:38,946 --> 00:06:40,810
这是一个值类型。 

146
00:06:40,810 --> 00:06:43,519
实际的卡在此阵列中。 

147
00:06:43,519 --> 00:06:45,860
当有人打电话给这个变种来获得这个， 

148
00:06:45,860 --> 00:06:49,899
他们正在获取副本，并且该副本是只读的

149
00:06:49,899 --> 00:06:51,339
因为私人订位。 

150
00:06:51,339 --> 00:06:54,469
因此，由于任何人都无法获得可写卡， 

151
00:06:54,470 --> 00:06:57,423
对我们来说，以这种方式离开这些变量非常好。 

152
00:06:58,350 --> 00:07:01,610
好吧，那回到我们的ViewModel呢？ 

153
00:07:01,610 --> 00:07:03,600
清楚地访问模型。 

154
00:07:03,600 --> 00:07:06,500
这不必是私有的。 

155
00:07:06,699 --> 00:07:10,439
无论如何它都是只读的，因为它是只读的var。 

156
00:07:10,439 --> 00:07:13,490
绝对意图是非私有的。 

157
00:07:13,490 --> 00:07:16,129
人们还会如何表达自己的意图？ 

158
00:07:16,129 --> 00:07:18,829
但是这个createMemoryGame，这个静态函数

159
00:07:18,829 --> 00:07:21,289
那可能想成为私人的。 

160
00:07:21,290 --> 00:07:25,370
我们可能不想要其他人， 

161
00:07:25,370 --> 00:07:28,600
特别是我们的View，以创建一个MemoryGame。 

162
00:07:28,600 --> 00:07:30,259
创建一个MemoryGame，创建我们的模型， 

163
00:07:30,459 --> 00:07:32,199
那是我们要做的。 

164
00:07:32,199 --> 00:07:34,779
在家庭作业中，您必须具有新的游戏功能。 

165
00:07:34,779 --> 00:07:37,250
您可能会在这里创建一个新的MemoryGame， 

166
00:07:37,250 --> 00:07:39,709
但这将必须在您的ViewModel中发生

167
00:07:39,709 --> 00:07:43,599
因为例如Views绝不可能

168
00:07:43,600 --> 00:07:45,225
可以负责创建模型。 

169
00:07:45,425 --> 00:07:48,822
因此，ViewModel确实希望这是私有函数。 

170
00:07:50,860 --> 00:07:52,069
我们认为呢？ 

171
00:07:52,269 --> 00:07:54,299
所以这是我们对这里的看法。 

172
00:07:54,300 --> 00:07:55,550
现在让我们看一下CardView。 

173
00:07:55,550 --> 00:07:56,509
这很有趣。 

174
00:07:56,709 --> 00:07:58,849
这些绘图常数在这里。 

175
00:07:58,850 --> 00:08:00,259
这些绝对可以是私人的。 

176
00:08:00,459 --> 00:08:03,750
真的没有任何人会的理由，他们是

177
00:08:03,750 --> 00:08:05,422
还是可以，但是没有理由有人

178
00:08:05,422 --> 00:08:08,509
想要在这里访问这些东西， 

179
00:08:08,709 --> 00:08:10,598
因此这绝对可以是私人的。 

180
00:08:10,598 --> 00:08:14,060
此var主体必须是非私有的

181
00:08:14,060 --> 00:08:16,579
因为系统将调用该名称。 

182
00:08:16,579 --> 00:08:18,979
就是这样，它如何为我们的视图赋予主体

183
00:08:18,980 --> 00:08:21,740
它会在需要的任何时间打电话

184
00:08:21,740 --> 00:08:24,263
了解如何绘制此CardView。 

185
00:08:25,180 --> 00:08:27,199
但是这个小助手功能

186
00:08:27,399 --> 00:08:29,014
我们从GeometryReader内部调用的

187
00:08:29,014 --> 00:08:31,599
没有理由公开，好吗？ 

188
00:08:31,600 --> 00:08:33,870
只有我们从自己的代码中调用它

189
00:08:33,870 --> 00:08:35,253
在CardView内部。 

190
00:08:36,379 --> 00:08:37,429
那这个变种呢？ 

191
00:08:37,429 --> 00:08:38,859
这可以是私人的吗？ 

192
00:08:38,860 --> 00:08:42,159
不，因为当我们创建CardView时， 

193
00:08:42,159 --> 00:08:44,616
我们需要给这个东西一个初始值， 

194
00:08:44,616 --> 00:08:47,399
因此我们必须能够在此处访问它。 

195
00:08:47,399 --> 00:08:48,413
如果我们将此设为私人， 

196
00:08:48,413 --> 00:08:50,263
那么我们将无法在创建它时对其进行设置

197
00:08:50,263 --> 00:08:52,110
这将是未初始化的

198
00:08:52,110 --> 00:08:54,302
而这在Swift中是不允许的。 

199
00:08:55,919 --> 00:08:57,579
那这里呢？ 

200
00:08:57,580 --> 00:09:00,839
好吧，同样，var body必须公开

201
00:09:00,839 --> 00:09:04,359
而且这里的ViewModel必须是公开的

202
00:09:04,559 --> 00:09:07,379
因为例如当我们创建预览器时， 

203
00:09:07,379 --> 00:09:08,769
我们正在指定ViewModel， 

204
00:09:08,769 --> 00:09:10,809
在我们的小SceneDelegate中， 

205
00:09:10,809 --> 00:09:15,659
当我们创建应用程序窗口的主视图时， 

206
00:09:15,659 --> 00:09:17,069
我们在这里表达它。 

207
00:09:17,070 --> 00:09:19,313
同样，这必须是公开的。 

208
00:09:21,269 --> 00:09:23,225
在Grid中呢？ 

209
00:09:23,225 --> 00:09:26,909
因此在Grid中，这是一个有趣的案例。 

210
00:09:26,909 --> 00:09:29,490
这些var必须公开吗？ 

211
00:09:29,490 --> 00:09:32,940
嗯，不是因为我们有这个公共初始化程序

212
00:09:32,940 --> 00:09:34,309
设置这些变量。 

213
00:09:34,509 --> 00:09:36,860
因此我们可以将这些完全设为私人

214
00:09:36,860 --> 00:09:39,182
那会很好。 

215
00:09:40,429 --> 00:09:42,609
这些var只需要公开

216
00:09:42,610 --> 00:09:46,000
如果您要让人们直接初始化它们。 

217
00:09:46,000 --> 00:09:47,899
但是由于我们有一个初始化器来初始化它们， 

218
00:09:47,899 --> 00:09:49,549
他们不需要公开。 

219
00:09:49,549 --> 00:09:51,549
可能希望它们是私有的。 

220
00:09:52,820 --> 00:09:54,945
当然，Var主体必须是公开的。 

221
00:09:55,145 --> 00:09:57,916
但是，这些小小的身体助手功能， 

222
00:09:57,917 --> 00:10:00,113
他们不需要公开。 

223
00:10:04,389 --> 00:10:06,159
在GridLayout中如何？ 

224
00:10:06,159 --> 00:10:07,399
因此，我们有了GridLayout。 

225
00:10:07,399 --> 00:10:09,269
当然我们需要构造函数

226
00:10:09,269 --> 00:10:10,909
或将初始化程序公开

227
00:10:10,909 --> 00:10:13,449
我们需要itemSize和位置公开， 

228
00:10:13,450 --> 00:10:14,995
否则，人们将如何使用它？ 

229
00:10:14,995 --> 00:10:19,995
但是这些变量对于使这些私有集非常重要。 

230
00:10:20,639 --> 00:10:24,870
为什么将这三个变量设为私有集如此重要？ 

231
00:10:24,870 --> 00:10:27,970
计算这三个变量

232
00:10:31,269 --> 00:10:32,740
从初始化程序， 

233
00:10:32,740 --> 00:10:35,610
初始化程序中通过的值在这里。 

234
00:10:35,610 --> 00:10:37,570
如果我们不将这些私人套装， 

235
00:10:37,570 --> 00:10:40,819
有人可能会认为他们可以重置此大小变量

236
00:10:41,019 --> 00:10:43,460
并且这些将自动重置。 

237
00:10:43,460 --> 00:10:44,503
但这不是事实。 

238
00:10:45,539 --> 00:10:49,169
初始化GridLayout后，它将永久修复。 

239
00:10:49,169 --> 00:10:50,620
所以我们希望人们知道

240
00:10:50,620 --> 00:10:53,019
他们只能从此处读取这些值。 

241
00:10:53,019 --> 00:10:55,870
您无法设置此项，并期望它们会发生变化

242
00:10:55,870 --> 00:10:56,919
或类似的东西。 

243
00:10:58,260 --> 00:11:00,860
这就是访问控制的情况

244
00:11:00,860 --> 00:11:04,062
实际上可以帮助人们了解如何使用此东西。 

245
00:11:05,712 --> 00:11:09,069
好吧，显然是我们的firstIndex，我们想要那个公众。 

246
00:11:09,070 --> 00:11:10,151
我们将其添加到所有数组中。 

247
00:11:10,351 --> 00:11:12,399
与我们的var相同。 

248
00:11:12,399 --> 00:11:13,992
我们正在公开场合。 

249
00:11:16,330 --> 00:11:17,099
就是这样了。 

250
00:11:17,299 --> 00:11:20,665
这就是我们在Memorize中设置访问控制的方式。 

251
00:11:20,666 --> 00:11:22,740
每次我们添加新功能时， 

252
00:11:22,740 --> 00:11:24,053
当您在家庭作业中这样做时， 

253
00:11:24,053 --> 00:11:27,735
你绝对应该把私人

254
00:11:27,735 --> 00:11:30,144
无论什么地方都应该是私人的。 

255
00:11:30,144 --> 00:11:33,139
现在你们中的许多人已经在做家庭作业。 

256
00:11:33,139 --> 00:11:35,100
您尚未执行此操作，我鼓励您继续执行此操作。 

257
00:11:35,100 --> 00:11:36,960
我们不会让您对此负责

258
00:11:36,960 --> 00:11:37,829
在第二个作业中

259
00:11:38,029 --> 00:11:40,919
但是我们肯定会在第三项任务中。 

260
00:11:40,919 --> 00:11:41,752
让我们运行我们的应用程序

261
00:11:41,753 --> 00:11:44,579
并确保将所有这些私有工作

262
00:11:44,779 --> 00:11:45,612
它做到了。 

263
00:11:45,613 --> 00:11:47,599
有时您会运行您的应用程序，并且会意识到， 

264
00:11:47,799 --> 00:11:50,969
哦，我将其设为私有，但实际上这是必需的。 

265
00:11:50,970 --> 00:11:52,070
然后你必须决定， 

266
00:11:52,070 --> 00:11:54,599
真的要我们访问吗？ 

267
00:11:54,799 --> 00:11:57,543
如果是这样，是私有集还是私有集？ 

268
00:11:58,590 --> 00:12:01,302
这就是我们很少进行访问控制的过程。 

269
00:12:01,302 --> 00:12:03,279
让我们回到幻灯片

270
00:12:03,279 --> 00:12:05,634
并详细讨论ViewBuilder。 

271
00:12:05,634 --> 00:12:08,990
因此，ViewBuilder基于通用技术

272
00:12:08,990 --> 00:12:10,860
最近添加到了Swift 

273
00:12:10,860 --> 00:12:14,350
支持面向列表的语法。 

274
00:12:14,350 --> 00:12:17,440
有很多东西被表达为列表， 

275
00:12:17,440 --> 00:12:19,942
例如HTML，它只是一个列表。 

276
00:12:19,942 --> 00:12:22,323
一段然后是一个嵌入的东西

277
00:12:22,323 --> 00:12:25,569
然后是另一个段落，标题或其他内容， 

278
00:12:25,570 --> 00:12:27,820
它们只是在页面上列出。 

279
00:12:27,820 --> 00:12:29,100
所以在Swift中会很好

280
00:12:29,100 --> 00:12:30,317
能够代表这些

281
00:12:30,317 --> 00:12:34,431
某些面向列表的本地语法。 

282
00:12:34,431 --> 00:12:37,990
一旦有了这种机制，您就会迅速意识到， 

283
00:12:37,990 --> 00:12:39,110
哦，有很多地方

284
00:12:39,110 --> 00:12:40,734
我们只需要一个View列表， 

285
00:12:40,934 --> 00:12:42,454
就像我们卡的正面一样。 

286
00:12:42,455 --> 00:12:44,320
我们只想列出两个RoundedRectangles 

287
00:12:44,520 --> 00:12:46,689
还有表情符号

288
00:12:46,690 --> 00:12:50,374
因此，ViewBuilder让开发人员可以做到这一点

289
00:12:50,374 --> 00:12:52,990
 @ViewBuilder是关键字。 

290
00:12:52,990 --> 00:12:55,049
再次，它不是语言的一部分。 

291
00:12:55,049 --> 00:12:58,250
 @ViewBuilder就像@Published 

292
00:12:58,250 --> 00:12:59,769
或@ObservedObject， 

293
00:12:59,769 --> 00:13:02,398
这是基于其他技术的东西。 

294
00:13:02,398 --> 00:13:06,440
但是@ViewBuilder，可以标记此关键字

295
00:13:06,440 --> 00:13:10,740
到返回某些View的任何函数上。 

296
00:13:10,740 --> 00:13:12,312
所以只要函数返回一些View 

297
00:13:12,312 --> 00:13:16,460
您可以使用@ViewBuilder标记该功能

298
00:13:16,460 --> 00:13:19,379
现在编译器将解释

299
00:13:19,379 --> 00:13:21,559
该函数的花括号中包含什么

300
00:13:21,559 --> 00:13:25,399
成为视图列表，而不仅仅是任意代码， 

301
00:13:25,399 --> 00:13:27,029
视图列表。 

302
00:13:27,029 --> 00:13:29,659
这就是ViewBuilder的工作方式。 

303
00:13:29,659 --> 00:13:31,809
现在，您要标记的功能

304
00:13:31,809 --> 00:13:32,859
使用@ViewBuilder， 

305
00:13:32,860 --> 00:13:36,169
它返回一些视图，它是单个视图。 

306
00:13:36,169 --> 00:13:38,375
所以ViewBuilder，这就是为什么它被称为ViewBuilder， 

307
00:13:38,375 --> 00:13:41,602
它将视图列表构建为一个视图。 

308
00:13:42,470 --> 00:13:44,649
结合起来的那个观点

309
00:13:44,649 --> 00:13:47,409
很多时候将是一个TupleView。 

310
00:13:47,409 --> 00:13:49,646
因此，如果其中有2到10个视图， 

311
00:13:49,647 --> 00:13:51,990
这将是一个TupleView。 

312
00:13:51,990 --> 00:13:55,080
 TupleView最多有10个无关项， 

313
00:13:55,080 --> 00:13:57,768
其中有10个视图。 

314
00:13:57,768 --> 00:14:00,590
并注意它仅限于10。 

315
00:14:00,590 --> 00:14:02,609
因此，如果您开始拥有11个以上的视图， 

316
00:14:02,809 --> 00:14:05,459
您将不得不将其分成几组， 

317
00:14:05,460 --> 00:14:08,769
 TupleViews的TupleViews可在其中获得那么多视图。 

318
00:14:08,769 --> 00:14:12,539
很难想象拥有超过10个视图

319
00:14:12,539 --> 00:14:14,069
刚连续列出。 

320
00:14:14,070 --> 00:14:15,971
你几乎肯定会把它分解

321
00:14:15,971 --> 00:14:19,277
带有CardViews之类的子视图， 

322
00:14:19,277 --> 00:14:22,427
 EmojiGameView等的子视图。 

323
00:14:22,427 --> 00:14:26,620
因此，实际上并没有太大的限制，但确实存在。 

324
00:14:26,620 --> 00:14:28,730
另一种观点可能是

325
00:14:28,730 --> 00:14:30,740
作为ConditionalContent视图， 

326
00:14:30,740 --> 00:14:32,970
下栏的ConditionalContent视图， 

327
00:14:32,970 --> 00:14:33,878
这就是视图创建的

328
00:14:34,078 --> 00:14:36,009
当那里有if-else时。 

329
00:14:36,009 --> 00:14:38,149
请记住，ViewBuilder中的if-elses 

330
00:14:38,149 --> 00:14:41,209
只是选择要包含在列表中的视图， 

331
00:14:41,210 --> 00:14:43,500
就像是CardViews的正面一样

332
00:14:43,500 --> 00:14:45,075
或CardView的背面。 

333
00:14:45,075 --> 00:14:48,023
因此，将创建此ConditionalContent视图

334
00:14:48,023 --> 00:14:51,870
只是有谓词可以测试isFaceUp 

335
00:14:51,870 --> 00:14:55,070
然后有两个视图

336
00:14:55,070 --> 00:14:57,969
可能是TupleView或其他视图

337
00:14:58,169 --> 00:14:59,870
它会从中选择。 

338
00:14:59,870 --> 00:15:01,763
甚至可以是允许的EmptyView。 

339
00:15:01,763 --> 00:15:03,730
我不知道你为什么一定要那样

340
00:15:03,730 --> 00:15:04,671
但你可以拥有它。 

341
00:15:04,871 --> 00:15:06,639
但是要记住的最重要的一点是

342
00:15:06,639 --> 00:15:08,970
可以是这些东西的任何组合。 

343
00:15:08,970 --> 00:15:10,129
所以你可以有一个TupleView 

344
00:15:10,129 --> 00:15:11,918
或TupleView中的其中一项是条件视图

345
00:15:11,918 --> 00:15:13,470
在该条件视图中

346
00:15:13,470 --> 00:15:16,029
还有另一个TupleView等。 

347
00:15:16,029 --> 00:15:19,572
这样您就可以构建这种任意复杂的

348
00:15:19,572 --> 00:15:21,709
视图的条件列表

349
00:15:21,710 --> 00:15:23,993
这才是真正的目的。 

350
00:15:23,993 --> 00:15:26,463
现在请注意，其中一些ViewBuilder API 

351
00:15:26,663 --> 00:15:28,370
尚未完全公开。 

352
00:15:28,370 --> 00:15:31,509
就像看到条件栏下的条件， 

353
00:15:31,509 --> 00:15:33,899
显然前面有一个下杠

354
00:15:33,899 --> 00:15:36,929
还没准备好迎接黄金时段，还没有完全公开。 

355
00:15:36,929 --> 00:15:38,709
我敢打赌，如果您在文档中查找

356
00:15:38,710 --> 00:15:40,720
你甚至在那里都找不到任何东西， 

357
00:15:40,720 --> 00:15:44,017
但这没关系，因为我们实际上不在乎

358
00:15:44,017 --> 00:15:46,069
这些是什么样的看法。 

359
00:15:46,269 --> 00:15:48,409
 TupleViews，ConditionalContent等

360
00:15:48,409 --> 00:15:50,889
我们所关心的只是它的某些视图，对不对？ 

361
00:15:50,889 --> 00:15:53,691
我们只能标记一个返回一些View的函数

362
00:15:53,691 --> 00:15:55,099
用这个东西。 

363
00:15:55,299 --> 00:15:56,419
这就是我们所关心的。 

364
00:15:56,419 --> 00:15:58,009
所有这些东西都是一些观点

365
00:15:58,009 --> 00:15:59,802
这样对我们来说足够了。 

366
00:16:00,730 --> 00:16:04,370
同样，任何函数，也是只读的计算变量

367
00:16:04,370 --> 00:16:06,460
也可以使用此ViewBuilder进行标记

368
00:16:06,460 --> 00:16:09,840
并在上面标记它，以便功能

369
00:16:09,840 --> 00:16:11,599
被解释为ViewBuilder。 

370
00:16:11,799 --> 00:16:14,139
这是我们的记忆样本。 

371
00:16:14,139 --> 00:16:17,860
假设我想排除卡片的正面， 

372
00:16:17,860 --> 00:16:20,919
这两个RoundedRectangles和您在此处看到的文本

373
00:16:20,919 --> 00:16:23,019
变成自己的小功能。 

374
00:16:23,019 --> 00:16:25,559
好吧，我可以使用func，卡片正面

375
00:16:25,559 --> 00:16:27,579
它返回一些视图

376
00:16:27,580 --> 00:16:31,990
在这里，我通常必须将其放在一个组中

377
00:16:31,990 --> 00:16:33,269
或类似的东西， 

378
00:16:33,269 --> 00:16:36,279
但是相反，我可以将其标记为@ViewBuilder 

379
00:16:36,279 --> 00:16:38,659
现在里面的花括号

380
00:16:38,659 --> 00:16:40,990
将被解释为视图列表。 

381
00:16:40,990 --> 00:16:43,788
我可以在这里放一些东西

382
00:16:43,788 --> 00:16:47,080
如果我想在这里做整个卡，我可以

383
00:16:47,080 --> 00:16:49,079
并拥有if isFaceUp， 

384
00:16:49,279 --> 00:16:50,769
所有这些东西完全允许。 

385
00:16:50,769 --> 00:16:53,338
这只是带有这些if-thens的View列表

386
00:16:53,339 --> 00:16:54,733
允许在那里。 

387
00:16:55,957 --> 00:16:59,420
此特定的绿色代码将返回TupleView 

388
00:16:59,421 --> 00:17:01,869
三个不在乎

389
00:17:01,869 --> 00:17:04,399
是RoundedRectangle，RoundedRectangle，Text。 

390
00:17:04,599 --> 00:17:08,149
当然，有两个TupleViews与八个无关项

391
00:17:08,150 --> 00:17:10,653
九，否则将是三。 

392
00:17:11,559 --> 00:17:14,539
同样，我们不在乎它在那儿执行TupleView。 

393
00:17:14,539 --> 00:17:15,649
绝对不在乎。 

394
00:17:15,650 --> 00:17:17,453
我们只关心这一些视图。 

395
00:17:19,470 --> 00:17:21,970
现在您也可以使用此@ViewBuilder 

396
00:17:21,970 --> 00:17:25,470
标记功能参数

397
00:17:25,470 --> 00:17:28,839
本身就是返回某些View的函数。 

398
00:17:28,839 --> 00:17:33,449
例如，我们的Grid的viewForItem参数，对不对？ 

399
00:17:33,450 --> 00:17:35,029
那是一个带物品的功能

400
00:17:35,029 --> 00:17:38,920
并返回了一个视图，那将是合格的

401
00:17:38,920 --> 00:17:42,240
用@ViewBuilder标记。 

402
00:17:42,240 --> 00:17:43,609
现在我们不在网格中执行此操作

403
00:17:43,609 --> 00:17:45,699
我将在稍后讨论，为什么我们没有， 

404
00:17:45,700 --> 00:17:47,986
但做到这一点的人是GeometryReader 

405
00:17:48,186 --> 00:17:51,959
 HStack，VStack和ForEach都这样做， 

406
00:17:51,960 --> 00:17:53,857
但让我们看看声明

407
00:17:53,857 --> 00:17:58,200
 GeometryReader的初始值设定项可能看起来像。 

408
00:17:58,200 --> 00:17:59,659
您已经有了GeometryReader，对吗？ 

409
00:17:59,859 --> 00:18:01,548
这是无关紧要的内容， 

410
00:18:01,548 --> 00:18:04,240
被限制为一个视图。 

411
00:18:04,240 --> 00:18:07,299
因此，GeometryReader的初始化程序

412
00:18:07,299 --> 00:18:10,159
我们知道需要满足，这花括号的东西， 

413
00:18:10,160 --> 00:18:12,139
给您GeometryProxy， 

414
00:18:12,339 --> 00:18:14,329
我们得到大小的东西， 

415
00:18:14,329 --> 00:18:17,319
它返回的内容就是一些View。 

416
00:18:17,319 --> 00:18:19,809
所以既然这个内容争论

417
00:18:19,809 --> 00:18:22,059
是一个返回一些View的函数， 

418
00:18:22,059 --> 00:18:23,909
可以将其标记为@ViewBuilder 

419
00:18:23,910 --> 00:18:25,349
 GeometryReader的功能。 

420
00:18:25,549 --> 00:18:27,230
它将其标记为@ViewBuilder。 

421
00:18:27,230 --> 00:18:29,222
这意味着您的GeometryReader里面是什么， 

422
00:18:29,222 --> 00:18:31,849
小花括号是“视图”列表， 

423
00:18:31,849 --> 00:18:35,339
将被解释为视图列表。 

424
00:18:35,339 --> 00:18:36,490
就这么简单。 

425
00:18:37,339 --> 00:18:40,393
通常取决于GeometryReader之类的东西， 

426
00:18:40,393 --> 00:18:41,970
 Hstack，VStack， 

427
00:18:41,970 --> 00:18:44,923
决定您是否通过了争论

428
00:18:44,923 --> 00:18:46,980
成为视图列表很有意义。 

429
00:18:46,980 --> 00:18:49,563
对于那些家伙，这就是他们的决定。 

430
00:18:51,869 --> 00:18:55,589
现在，您可能会问，为什么我们不在Grid中执行此操作？ 

431
00:18:55,589 --> 00:19:00,589
网格要求您提供特定项目的视图

432
00:19:01,170 --> 00:19:02,629
然后我们传递一个函数

433
00:19:02,829 --> 00:19:04,619
我们为什么不说@ViewBuilder 

434
00:19:04,619 --> 00:19:07,199
在网格中查看项目参数？ 

435
00:19:07,200 --> 00:19:09,909
那么答案与这件事有关

436
00:19:10,109 --> 00:19:12,899
 ViewBuilder仍然是私有的。 

437
00:19:12,900 --> 00:19:14,930
例如它的实现

438
00:19:14,930 --> 00:19:17,834
无法提取视图

439
00:19:17,834 --> 00:19:19,683
从TupleView，ConditionalContent， 

440
00:19:20,573 --> 00:19:23,160
只是你不能让他们离开那里。 

441
00:19:23,160 --> 00:19:26,258
因此，Grid不可能知道它们的全部。 

442
00:19:26,258 --> 00:19:30,399
在当前的@ViewBuilder中不公开。 

443
00:19:30,599 --> 00:19:32,019
我确定这将是公开的

444
00:19:32,019 --> 00:19:33,039
最终你可以做到

445
00:19:33,039 --> 00:19:36,079
然后也许有Grid的论点是有意义的， 

446
00:19:36,079 --> 00:19:38,839
但即使到那时Grid还是二维数组。 

447
00:19:38,839 --> 00:19:40,567
通常，这将是相当数量的View。 

448
00:19:40,567 --> 00:19:43,017
您不太可能会列出他们， 

449
00:19:43,017 --> 00:19:46,219
特别是如果您要拥有10个或更少

450
00:19:46,219 --> 00:19:48,129
可能，但不太可能。 

451
00:19:48,329 --> 00:19:50,869
因此，Grid与ForEach息息相关

452
00:19:50,869 --> 00:19:52,979
并以ForEach相同的方式表示

453
00:19:52,980 --> 00:19:54,663
可能还不错。 

454
00:19:56,779 --> 00:19:58,079
就在我们离开ViewBuilder之前， 

455
00:19:58,079 --> 00:19:59,569
我只想重申一下。 

456
00:19:59,569 --> 00:20:01,062
这张幻灯片不是新内容。 

457
00:20:01,063 --> 00:20:04,389
标记为ViewBuilder的内容只是视图列表。 

458
00:20:04,589 --> 00:20:06,679
是的，里面有条件

459
00:20:06,680 --> 00:20:08,859
看看您是否在列表中包含“视图”， 

460
00:20:09,059 --> 00:20:10,279
但是只有一个视图列表。 

461
00:20:10,279 --> 00:20:12,676
因此无法在其中声明var， 

462
00:20:12,676 --> 00:20:14,909
您不能有任意代码。 

463
00:20:14,910 --> 00:20:16,710
只要您拥有ViewBuilder， 

464
00:20:16,710 --> 00:20:18,764
这只是其中包含if-thens的Views列表

465
00:20:18,964 --> 00:20:20,612
选择哪个视图。 

466
00:20:22,549 --> 00:20:24,569
当天的主要话题，形状。 

467
00:20:24,569 --> 00:20:26,525
形状是一种协议。 

468
00:20:26,526 --> 00:20:30,650
它继承自View，因此所有Shapes都是View。 

469
00:20:30,650 --> 00:20:33,089
因此，您始终可以将Shape放在ZStack或其他任何对象中

470
00:20:33,289 --> 00:20:34,123
如我们所见

471
00:20:34,123 --> 00:20:36,293
 RoundedRectangle，我们把它扔在那里，没问题。 

472
00:20:36,493 --> 00:20:38,790
当然有常见的形状

473
00:20:38,790 --> 00:20:40,571
像RoundedRectangle，Circle， 

474
00:20:40,571 --> 00:20:44,439
胶囊是一种椭圆形的东西

475
00:20:44,440 --> 00:20:45,993
和那里的其他人。 

476
00:20:47,450 --> 00:20:49,687
现在，形状默认情况下会自行绘制

477
00:20:49,887 --> 00:20:53,720
通过使用当前的前景色填充自己。 

478
00:20:53,720 --> 00:20:56,509
我们在卡片背面看到了这一点。 

479
00:20:56,509 --> 00:21:00,379
他们采用RoundedRectangle，默认情况下会填充它。 

480
00:21:00,380 --> 00:21:03,470
但是我们也了解到我们可以调用笔触或填充

481
00:21:03,470 --> 00:21:08,089
带有更改Shape外观方式的参数。 

482
00:21:08,089 --> 00:21:11,106
现在我想谈谈填充和描边

483
00:21:11,106 --> 00:21:14,270
以及可以传递给它的参数。 

484
00:21:14,270 --> 00:21:17,899
看起来，当我们完成记忆代码时， 

485
00:21:17,900 --> 00:21:21,470
传递给fill的参数实际上是Color 

486
00:21:21,470 --> 00:21:24,169
因为您会记得第二个RoundedRectangle 

487
00:21:24,369 --> 00:21:26,518
从后面，实际上不， 

488
00:21:26,519 --> 00:21:28,549
背面的矩形一直是白色。 

489
00:21:28,549 --> 00:21:30,589
然后，将描边的一个放在上面。 

490
00:21:30,589 --> 00:21:33,209
因此，我们说的那个白色填充Color.white。 

491
00:21:33,210 --> 00:21:35,660
这样看来，哦，填充需要一种颜色。 

492
00:21:35,660 --> 00:21:38,239
但实际上填充参数不是颜色

493
00:21:38,239 --> 00:21:40,836
我将借此机会充实和中风

494
00:21:40,836 --> 00:21:43,609
谈论Swift中的另一个功能

495
00:21:43,609 --> 00:21:46,529
称为通用函数。 

496
00:21:46,529 --> 00:21:48,039
您已经了解通用类型

497
00:21:48,039 --> 00:21:49,990
例如Array和MemoryGame， 

498
00:21:49,990 --> 00:21:52,400
它的CardContent无关紧要。 

499
00:21:52,400 --> 00:21:54,720
好吧，函数也可以不在乎。 

500
00:21:54,720 --> 00:21:55,913
它们也可以是通用的。 

501
00:21:55,913 --> 00:21:59,250
并且他们执行类似的语法。 

502
00:21:59,250 --> 00:22:03,619
您可以看到填充具有此无关位S， 

503
00:22:03,619 --> 00:22:05,752
用S型填充什么， 

504
00:22:05,752 --> 00:22:07,980
看到这是一种S， 

505
00:22:07,980 --> 00:22:09,779
并限制了它

506
00:22:09,779 --> 00:22:11,200
所以它不是完整的不在乎

507
00:22:11,200 --> 00:22:13,139
有点像在乎

508
00:22:13,339 --> 00:22:17,529
 S必须在其中实现ShapeStyle协议。 

509
00:22:17,529 --> 00:22:19,884
所以这个ShapeStyle协议，我们不再谈论它， 

510
00:22:19,884 --> 00:22:22,640
但是如果您实现此ShapeStyle协议， 

511
00:22:22,640 --> 00:22:27,319
那么您就可以用来填充或描画形状。 

512
00:22:27,519 --> 00:22:29,700
什么样的东西实现ShapeStyle？ 

513
00:22:29,700 --> 00:22:30,909
好吧，颜色，显然我们知道

514
00:22:30,909 --> 00:22:33,380
因为我们称填充为颜色， 

515
00:22:33,380 --> 00:22:36,450
还有ImagePaint，可以拍摄JPEG图像

516
00:22:36,450 --> 00:22:38,380
并在那里铺上油漆

517
00:22:38,380 --> 00:22:41,230
好像它只是该图像的画笔一样。 

518
00:22:41,230 --> 00:22:44,059
也有渐变，角度和线性渐变

519
00:22:44,059 --> 00:22:46,896
会显示出一系列颜色或其他颜色。 

520
00:22:46,896 --> 00:22:48,629
所以这些东西完全不同， 

521
00:22:48,630 --> 00:22:53,470
颜色，渐变，图像绘制，非常不同的东西， 

522
00:22:53,470 --> 00:22:55,419
真正的填充并不关心它们是什么。 

523
00:22:55,619 --> 00:22:57,329
这就是为什么S是无关紧要的原因。 

524
00:22:57,329 --> 00:22:59,480
但这确实很在乎，因为它们都实现了ShapeStyle 

525
00:22:59,480 --> 00:23:00,932
因为如果他们没有实现ShapeStyle 

526
00:23:00,932 --> 00:23:04,410
那么Shape并不真正知道如何使用它们

527
00:23:04,410 --> 00:23:06,169
做填充和描边。 

528
00:23:06,369 --> 00:23:08,289
再说一次，我主要是向你展示这个， 

529
00:23:08,289 --> 00:23:11,319
是的，这样您就可以知道可以填充图像

530
00:23:11,319 --> 00:23:12,839
或渐变或颜色， 

531
00:23:12,839 --> 00:23:14,049
而且所以你应该意识到

532
00:23:14,049 --> 00:23:16,190
有这些通用功能， 

533
00:23:16,190 --> 00:23:18,082
无关功能

534
00:23:18,282 --> 00:23:20,673
作为他们某些论点的类型。 

535
00:23:21,950 --> 00:23:24,059
如果您想创建自己的形状该怎么办？ 

536
00:23:24,059 --> 00:23:26,217
您不想使用RoundedRectangle，Circle， 

537
00:23:26,218 --> 00:23:28,500
无论如何，您想要自己的形状。 

538
00:23:28,500 --> 00:23:31,619
好吧，Shape协议使用了扩展

539
00:23:31,619 --> 00:23:34,295
为您实现View的body var，对吗？ 

540
00:23:34,296 --> 00:23:37,821
因为Shape继承自View，所以Shape是View。 

541
00:23:38,021 --> 00:23:39,875
因此，它必须实现body var。 

542
00:23:39,875 --> 00:23:41,639
所有视图都必须实现该主体变量。 

543
00:23:41,640 --> 00:23:42,970
但是Shape为您实现了这一点。 

544
00:23:42,970 --> 00:23:44,909
协议及其扩展

545
00:23:45,109 --> 00:23:46,289
为您实现。 

546
00:23:46,289 --> 00:23:48,739
但是，Shape引入了新的功能

547
00:23:48,739 --> 00:23:51,769
您需要实施。 

548
00:23:51,769 --> 00:23:54,389
在rect中称为路径。 

549
00:23:54,390 --> 00:23:58,629
所以rect中的此功能路径将仅返回

550
00:23:58,829 --> 00:24:00,960
称为路径的东西。 

551
00:24:00,960 --> 00:24:03,559
现在，路径上有很多功能， 

552
00:24:03,559 --> 00:24:08,249
像线到，圆弧和贝塞尔曲线。 

553
00:24:08,249 --> 00:24:11,329
所有这些让您从本质上画画

554
00:24:11,329 --> 00:24:13,699
就像您用笔绘图一样。 

555
00:24:13,700 --> 00:24:16,909
因此，您将建立一些路径

556
00:24:17,109 --> 00:24:20,689
用这支笔绘图，然后将其返回此处。 

557
00:24:20,690 --> 00:24:23,670
现在，一旦您将其退回，Shape就拥有了所有需要知道的信息

558
00:24:23,670 --> 00:24:24,609
去做它做的事， 

559
00:24:24,809 --> 00:24:28,332
它提供了可以抚摸和填充的Shape。 

560
00:24:29,730 --> 00:24:33,710
现在最好通过演示展示它的工作原理。 

561
00:24:33,710 --> 00:24:36,309
所以我们要回到记忆

562
00:24:36,309 --> 00:24:38,240
并实施那个小馅饼。 

563
00:24:38,240 --> 00:24:40,894
如果您还记得我们的第一堂课

564
00:24:40,894 --> 00:24:43,819
有那个小馅饼，它充满生气

565
00:24:43,819 --> 00:24:46,009
有点倒计时

566
00:24:46,009 --> 00:24:47,629
这样，如果您足够快地匹配卡片， 

567
00:24:47,630 --> 00:24:49,210
你有加分。 

568
00:24:49,210 --> 00:24:52,279
因此，我们将在我们的记忆游戏中画图。 

569
00:24:52,279 --> 00:24:53,370
我们还没有动画。 

570
00:24:53,371 --> 00:24:55,410
动画是我们的下一个主题。 

571
00:24:55,410 --> 00:24:56,639
我们将回到这一点。 

572
00:24:56,839 --> 00:25:00,299
所以今天我们只是在学习如何创建自己的形状

573
00:25:00,299 --> 00:25:01,712
通过建立那个馅饼。 

574
00:25:04,720 --> 00:25:09,720
我已经将游戏中的视频截图了

575
00:25:09,720 --> 00:25:12,615
这样我们就可以知道我们要拍摄什么。 

576
00:25:12,615 --> 00:25:16,673
我们正在尝试构建这个小饼图

577
00:25:16,673 --> 00:25:20,890
看起来像吃豆人之类的东西

578
00:25:20,890 --> 00:25:22,339
在我们的幽灵后面。 

579
00:25:22,539 --> 00:25:26,230
而且SwiftUI中没有内置这样的Shape， 

580
00:25:26,230 --> 00:25:27,599
这种吃豆人形状

581
00:25:27,599 --> 00:25:30,099
所以我们必须自己构建。 

582
00:25:30,099 --> 00:25:32,221
但是在我们开始构建自定义形状之前， 

583
00:25:32,221 --> 00:25:34,509
让我们尝试一个圆圈

584
00:25:34,509 --> 00:25:37,650
在这个鬼魂后面。 

585
00:25:37,650 --> 00:25:39,686
 “因为我们知道有一个内置的Circle， 

586
00:25:39,886 --> 00:25:42,702
就像这里有一个RoundedRectangle内置的大对象一样。 

587
00:25:43,890 --> 00:25:45,500
因此，这样做非常简单。 

588
00:25:45,500 --> 00:25:48,124
这是我们的视图，这是我们的CardView。 

589
00:25:48,124 --> 00:25:52,930
就在这里，这里是，这是背景。 

590
00:25:52,930 --> 00:25:54,660
这是我们的表情符号所在的位置

591
00:25:54,660 --> 00:25:57,380
而这个圈子只是想活下去

592
00:25:57,380 --> 00:25:58,970
就在这之间

593
00:25:58,970 --> 00:26:01,400
就在背景和表情符号之间

594
00:26:01,400 --> 00:26:02,119
让我们来看看。 

595
00:26:02,319 --> 00:26:03,153
这样就行了。 

596
00:26:03,153 --> 00:26:05,640
也许这就是我们开始所需要的。 

597
00:26:05,840 --> 00:26:06,909
好吧，让我们单击。 

598
00:26:06,910 --> 00:26:10,160
哦，实际上到了那里。 

599
00:26:10,160 --> 00:26:10,792
看一看。 

600
00:26:10,992 --> 00:26:12,889
哦，差不多了。 

601
00:26:12,890 --> 00:26:14,966
现在不太正确。 

602
00:26:15,166 --> 00:26:17,889
距离那里的边缘太近了， 

603
00:26:17,890 --> 00:26:19,650
应该有一点差距， 

604
00:26:19,650 --> 00:26:23,509
而且这种颜色有点太橙色了

605
00:26:23,509 --> 00:26:25,640
但在球场上。 

606
00:26:25,640 --> 00:26:28,980
现在我们可以回到这里尝试解决此问题

607
00:26:28,980 --> 00:26:31,450
然后再次运行，然后再修复一些

608
00:26:31,450 --> 00:26:33,630
然后再次运行并对其进行一些调整。 

609
00:26:33,630 --> 00:26:35,170
但这有点乏味

610
00:26:35,170 --> 00:26:37,859
当然，我们有一个更好的工具， 

611
00:26:38,059 --> 00:26:41,037
这是我们这里的画布

612
00:26:41,037 --> 00:26:45,082
我们可以恢复并看到我们的样子

613
00:26:45,282 --> 00:26:47,314
看起来像... 

614
00:26:47,315 --> 00:26:51,009
哦，不，所有卡都朝下。 

615
00:26:51,009 --> 00:26:54,451
哪种才有意义，因为那是游戏开始的方式， 

616
00:26:54,451 --> 00:26:56,400
但这对我来说毫无用处

617
00:26:56,400 --> 00:26:58,019
使所有这些卡面朝下。 

618
00:26:58,019 --> 00:27:00,769
我真的希望至少其中一张卡面朝上

619
00:27:00,769 --> 00:27:02,519
所以我可以做这个。 

620
00:27:02,519 --> 00:27:04,920
我们该怎么做？ 

621
00:27:04,920 --> 00:27:07,160
原来，这段代码在底部

622
00:27:07,160 --> 00:27:08,690
我推开了

623
00:27:08,690 --> 00:27:11,809
不像我说的那样可怕

624
00:27:11,809 --> 00:27:13,690
通过将其推开。 

625
00:27:13,690 --> 00:27:18,430
这实际上只是一个静态var，其类型为

626
00:27:18,430 --> 00:27:23,430
返回整个视图以预览我们的

627
00:27:25,069 --> 00:27:26,669
 EmojiMemoryGameView。 

628
00:27:26,670 --> 00:27:28,399
现在我们正在创建一个

629
00:27:28,599 --> 00:27:29,789
 EmojiMemoryGameView。 

630
00:27:29,789 --> 00:27:31,720
我们给它这个ViewModel 

631
00:27:31,720 --> 00:27:33,950
我们刚刚创建的。 

632
00:27:33,950 --> 00:27:34,950
但是没有理由

633
00:27:34,950 --> 00:27:36,980
我们不能只是从这里带走这个， 

634
00:27:36,980 --> 00:27:39,650
把它放在一个变量中，我称之为游戏， 

635
00:27:39,650 --> 00:27:42,139
要求该游戏选择其中一张纸牌， 

636
00:27:42,339 --> 00:27:45,496
如何选择游戏中的第一张牌， 

637
00:27:45,497 --> 00:27:47,150
这样的事情

638
00:27:47,150 --> 00:27:48,839
然后在这里使用该游戏

639
00:27:49,039 --> 00:27:51,219
作为我们要预览的东西。 

640
00:27:51,219 --> 00:27:52,630
当然要回去了

641
00:27:52,630 --> 00:27:54,089
由于我们没有单行功能， 

642
00:27:54,289 --> 00:27:57,584
瞧，我们马上就看到面朝上的卡片

643
00:27:57,584 --> 00:28:01,909
我可能会选择第三张卡

644
00:28:02,109 --> 00:28:03,990
现在向我展示了第三张卡片。 

645
00:28:03,990 --> 00:28:05,731
所以我可以让它挑选几张卡片。 

646
00:28:05,731 --> 00:28:08,220
当然如果我选三张卡

647
00:28:08,220 --> 00:28:10,553
然后去玩游戏并进行比赛。 

648
00:28:11,509 --> 00:28:13,460
但是，这非常适合我们的需求。 

649
00:28:13,460 --> 00:28:15,900
我们可以回到这里开始在这个圈子上工作

650
00:28:15,900 --> 00:28:20,440
并尝试使其看起来更像我们打算在这里进行。 

651
00:28:20,440 --> 00:28:22,670
让我们开始尝试从边缘入手

652
00:28:22,670 --> 00:28:25,150
一点，所以它不会粉碎到边缘。 

653
00:28:25,150 --> 00:28:26,519
我们知道该怎么做。 

654
00:28:26,519 --> 00:28:29,500
只需在此Circle周围放置一些填充物即可。 

655
00:28:29,500 --> 00:28:33,562
好吧，现在，这并不是我们想要的。 

656
00:28:33,563 --> 00:28:34,640
填充太多。 

657
00:28:34,640 --> 00:28:36,140
如果我们不知道怎么办， 

658
00:28:36,140 --> 00:28:38,240
在那儿放些填料？ 

659
00:28:38,240 --> 00:28:40,381
是的，我对此很满意。 

660
00:28:40,381 --> 00:28:43,892
虽然我的幽灵有点大， 

661
00:28:43,892 --> 00:28:47,170
我认为我不想猛冲到那里的边缘。 

662
00:28:47,170 --> 00:28:50,139
所以也许我会在这里进入常量控制面板

663
00:28:50,339 --> 00:28:52,599
并将其更改为0.7， 

664
00:28:52,599 --> 00:28:57,299
也许0.65不，70％看起来不错。 

665
00:28:57,299 --> 00:28:58,569
我不想这太小。 

666
00:28:58,569 --> 00:29:01,210
这是该卡的目的，实际上是为了证明这一点。 

667
00:29:01,210 --> 00:29:03,611
所以我不想在那儿过小。 

668
00:29:03,611 --> 00:29:08,140
那么这种真正的鲜艳橙色呢？ 

669
00:29:08,140 --> 00:29:10,460
好吧，事实证明我们可以做一个橙色

670
00:29:10,460 --> 00:29:14,299
在这里有点通透或透视

671
00:29:14,299 --> 00:29:17,001
通过使其半透明。 

672
00:29:17,001 --> 00:29:21,319
而且View有一个很棒的修改器，不透明度

673
00:29:21,319 --> 00:29:24,329
叫做零之间的两倍

674
00:29:24,329 --> 00:29:26,970
这意味着完全透明

675
00:29:26,970 --> 00:29:29,299
一到完全不透明。 

676
00:29:29,299 --> 00:29:33,210
现在我们可以进入中间，大概是70％ 

677
00:29:33,210 --> 00:29:36,106
也许10％哦，太轻了。 

678
00:29:36,106 --> 00:29:39,569
 30％，40％，我有点喜欢40％。 

679
00:29:39,569 --> 00:29:42,240
我认为这就是我在这里结束的事情。 

680
00:29:42,240 --> 00:29:44,053
差不多了。 

681
00:29:45,170 --> 00:29:48,450
您可以看到我们确实拥有我们想要的外观

682
00:29:48,450 --> 00:29:52,420
除了这是一个圆形而不是我们的饼图。 

683
00:29:52,420 --> 00:29:54,410
做我们的吃豆人派

684
00:29:54,410 --> 00:29:57,000
我们只需要在这里替换Circle 

685
00:29:57,000 --> 00:29:59,365
与我们自己的自定义形状。 

686
00:29:59,365 --> 00:30:01,079
因此，让我们创建它。 

687
00:30:01,079 --> 00:30:02,119
我要去File，New 

688
00:30:02,119 --> 00:30:04,781
因为我们在这里创建新事物。 

689
00:30:04,781 --> 00:30:08,157
这将是一个SwiftUI视图，因为形状是视图， 

690
00:30:08,157 --> 00:30:11,500
但是如果我们选择此模板，我们将获得该var body 

691
00:30:11,500 --> 00:30:14,089
 Shape协议为我们提供了这一点。 

692
00:30:14,089 --> 00:30:16,548
所以我们要在这里选择Swift文件

693
00:30:16,548 --> 00:30:18,259
确保我们将其放在正确的位置。 

694
00:30:18,259 --> 00:30:22,057
我将其命名为Pie，这是我自定义Shape的名称。 

695
00:30:22,057 --> 00:30:25,009
让我们来创建它。 

696
00:30:25,009 --> 00:30:25,843
开始了。 

697
00:30:25,843 --> 00:30:28,169
当然，现在Shape很大程度上是UI的事情， 

698
00:30:28,369 --> 00:30:32,049
所以我们要导入SwiftUI，而不是那里的Foundation。 

699
00:30:32,049 --> 00:30:35,409
并创建一个Shape，如此简单，构造Pie。 

700
00:30:35,410 --> 00:30:38,009
符合Shape协议

701
00:30:38,009 --> 00:30:40,900
限制和收获

702
00:30:40,900 --> 00:30:42,869
它会得到一个事实，那就是视图

703
00:30:43,069 --> 00:30:45,929
它可以被充满和抚摸，各种收获， 

704
00:30:45,930 --> 00:30:49,129
而这里唯一真正的约束是这个功能， 

705
00:30:49,329 --> 00:30:51,960
在rect中称为路径

706
00:30:53,605 --> 00:30:57,519
它返回我们必须创建的路径， 

707
00:30:57,519 --> 00:31:00,859
而这条路径将成为边缘

708
00:31:00,859 --> 00:31:01,769
我们正在画的东西。 

709
00:31:01,769 --> 00:31:04,394
所以对我们来说，它将从中间开始，然后上升， 

710
00:31:04,394 --> 00:31:07,599
在这里，回到中间。 

711
00:31:07,599 --> 00:31:09,629
那就是我们要建立的道路。 

712
00:31:09,630 --> 00:31:11,970
我们将使用Path中的函数进行构建

713
00:31:11,970 --> 00:31:14,942
就像在此处画一条线并在此处画一条弧。 

714
00:31:14,942 --> 00:31:16,960
我们将把所有这些结合起来

715
00:31:16,960 --> 00:31:18,490
做这条路。 

716
00:31:18,490 --> 00:31:21,009
一旦完成，Shape便会处理所有其余的工作。 

717
00:31:21,009 --> 00:31:22,049
能够填补这一切

718
00:31:22,049 --> 00:31:25,349
都会照顾我们的。 

719
00:31:25,349 --> 00:31:28,109
我们如何返回这个路径的东西？ 

720
00:31:28,109 --> 00:31:31,959
我要创建一个空的，我将其命名为p Path。 

721
00:31:31,960 --> 00:31:34,799
那是一条空的路径，我要归还它。 

722
00:31:34,799 --> 00:31:38,450
在这之间，我只需要调用Path中的函数

723
00:31:38,450 --> 00:31:42,049
移动，画出我想画的线。 

724
00:31:42,049 --> 00:31:45,109
现在传递给我们的是什么？ 

725
00:31:45,109 --> 00:31:49,019
那就是我们应该适合我们的形状的矩形。 

726
00:31:49,019 --> 00:31:51,650
现在几乎所有的形状

727
00:31:51,650 --> 00:31:54,880
通常使用给他们的直肠中的所有空间

728
00:31:54,880 --> 00:31:58,599
是的，您猜对了，因为Shape是一个View， 

729
00:31:58,799 --> 00:32:00,097
直肠会给你在这里

730
00:32:00,097 --> 00:32:03,919
是为其提供的空间。 

731
00:32:03,920 --> 00:32:05,990
提供的空间。 

732
00:32:05,990 --> 00:32:08,289
我们有这条路，有这条路， 

733
00:32:08,289 --> 00:32:09,639
我们该怎么做？ 

734
00:32:09,640 --> 00:32:12,919
让我们从矩形的中心开始。 

735
00:32:13,119 --> 00:32:15,599
因此，我们将获得此矩形以进行绘制。 

736
00:32:15,599 --> 00:32:18,419
让我们直接到它的中心开始， 

737
00:32:18,420 --> 00:32:19,730
就在这里，然后我们要往上走。 

738
00:32:19,730 --> 00:32:21,400
因此，让我们从中间开始。 

739
00:32:21,400 --> 00:32:23,829
因此，获得中间位置非常容易。 

740
00:32:24,029 --> 00:32:27,529
我只是说p路径走到中间， 

741
00:32:27,529 --> 00:32:32,529
这就是路径，点移到中心。 

742
00:32:32,789 --> 00:32:35,389
而中心将是一个变种。 

743
00:32:35,390 --> 00:32:36,640
让中心相等。 

744
00:32:36,840 --> 00:32:39,479
为了获得中心，我将创建一个CGPoint。 

745
00:32:39,480 --> 00:32:41,910
现在注意所有这些绘图内容， 

746
00:32:41,910 --> 00:32:45,129
不仅是CGFloat，还包括CGRect，CGPoint，CGSize 

747
00:32:45,329 --> 00:32:48,179
我们在GeometryReader上看到的，它们都是从CG开始的。 

748
00:32:48,180 --> 00:32:50,680
此CG代表核心图形。 

749
00:32:50,680 --> 00:32:52,359
那就是底层的图形系统

750
00:32:52,559 --> 00:32:55,347
所有这些都是建立在

751
00:32:55,347 --> 00:32:58,669
因此，找到该矩形的中心真的很容易。 

752
00:32:58,670 --> 00:33:01,033
 X的位置就是正中

753
00:33:02,107 --> 00:33:04,857
 Y是矩形midY。 

754
00:33:06,536 --> 00:33:07,168
就是这样了。 

755
00:33:07,368 --> 00:33:10,159
我们有了中心，我们已经在这里开始了， 

756
00:33:10,160 --> 00:33:11,349
但是我们还没有画任何东西。 

757
00:33:11,549 --> 00:33:13,849
我们实际上还没有画线或任何东西。 

758
00:33:13,849 --> 00:33:15,629
所以接下来我们要做

759
00:33:16,789 --> 00:33:20,123
从中心到此处画一条线。 

760
00:33:21,329 --> 00:33:23,399
现在我要去做，让我的馅饼， 

761
00:33:23,400 --> 00:33:26,730
这个开始角度和这个结束角度， 

762
00:33:26,730 --> 00:33:27,727
可以是您想要的任何东西。 

763
00:33:27,727 --> 00:33:30,859
所以你可以把你的派变成一小块

764
00:33:31,059 --> 00:33:33,240
或指向任何方向的大馅饼。 

765
00:33:33,240 --> 00:33:34,710
所以我需要几个变量

766
00:33:34,710 --> 00:33:36,630
一个是我的出发点

767
00:33:36,630 --> 00:33:38,940
一个是我的结束角度。 

768
00:33:38,940 --> 00:33:41,000
因此，让我们将这些var放在Shape中。 

769
00:33:41,000 --> 00:33:41,930
这只是一个结构。 

770
00:33:41,930 --> 00:33:44,700
这样他就可以让vars startAngle， 

771
00:33:44,700 --> 00:33:46,150
但是角度是什么类型？ 

772
00:33:46,150 --> 00:33:49,129
好吧，您可以将其设置为CGFloat或类似的东西， 

773
00:33:49,329 --> 00:33:52,579
但是Swift中有一个很棒的东西叫做Angle 

774
00:33:52,579 --> 00:33:53,889
我会告诉你的

775
00:33:53,890 --> 00:33:58,169
因此，我们将使这些起始角度和终止角度成为角度。 

776
00:33:58,369 --> 00:33:59,549
什么是角度？ 

777
00:33:59,549 --> 00:34:03,202
让我们继续阅读文档中的内容。 

778
00:34:04,180 --> 00:34:05,774
这是struct Angle，它只是一个struct 

779
00:34:05,974 --> 00:34:09,880
它使您可以使用度数或弧度创建角度。 

780
00:34:09,880 --> 00:34:12,579
希望每个人都记得三角学课

781
00:34:12,579 --> 00:34:15,949
什么是弧度，对吗？零度到360度

782
00:34:15,949 --> 00:34:16,879
绕圈， 

783
00:34:16,880 --> 00:34:20,809
弧度为零到2π。 

784
00:34:20,809 --> 00:34:23,983
 2πr是圆的周长。 

785
00:34:23,983 --> 00:34:28,119
因此，弧度在圆周围为零到2π。 

786
00:34:28,119 --> 00:34:29,989
并注意该角度的动画效果。 

787
00:34:29,989 --> 00:34:32,669
以后对我们会很好。 

788
00:34:32,670 --> 00:34:33,730
也可以散列， 

789
00:34:33,929 --> 00:34:36,169
这意味着可以将其放入字典或哈希表中。 

790
00:34:36,170 --> 00:34:38,773
我们不需要这样做，但是这个角度非常好

791
00:34:38,773 --> 00:34:41,519
我们的小类型。 

792
00:34:41,519 --> 00:34:44,326
我需要以某种方式计算起始位置

793
00:34:44,327 --> 00:34:48,030
在这里的顶部，这个小位置， 

794
00:34:48,030 --> 00:34:50,210
这样我才能从这里画一条线。 

795
00:34:50,210 --> 00:34:51,717
所以我要说的是

796
00:34:51,717 --> 00:34:56,717
 addLine到顶部的开头。 

797
00:34:56,833 --> 00:34:58,022
所以我需要开始。 

798
00:34:58,023 --> 00:35:02,643
起点也等于点，CGPoint也是如此。 

799
00:35:02,842 --> 00:35:06,409
让我们继续将它放在多行上

800
00:35:06,409 --> 00:35:11,129
并将X放在一行上，将Y放在另一行上。 

801
00:35:11,130 --> 00:35:13,579
所以X位置，水平位置

802
00:35:13,579 --> 00:35:18,579
是中心的X加上圆的半径， 

803
00:35:19,130 --> 00:35:20,125
我们将不得不弄清楚， 

804
00:35:20,324 --> 00:35:22,940
一次又一次，我希望你能记住

805
00:35:22,940 --> 00:35:27,629
八年级或九年级的三角函数

806
00:35:27,630 --> 00:35:29,918
或这些天教授三角学的时候

807
00:35:29,918 --> 00:35:34,420
我想做那个起始角度的余弦， 

808
00:35:34,420 --> 00:35:36,260
我必须用弧度来做

809
00:35:36,260 --> 00:35:39,721
因为Swift中的余弦函数会产生弧度， 

810
00:35:39,920 --> 00:35:43,669
我也想在CGFloat世界中做到这一点， 

811
00:35:43,670 --> 00:35:46,039
不是Double的。 

812
00:35:46,239 --> 00:35:48,559
同样，Y只是中心点Y 

813
00:35:48,559 --> 00:35:52,820
加上半径乘以CGFloat的正弦

814
00:35:52,820 --> 00:35:55,789
 startAngle点弧度。 

815
00:35:55,989 --> 00:35:57,389
因此，我需要半径。 

816
00:35:57,389 --> 00:36:02,389
我的圆半径将是多少？ 

817
00:36:02,554 --> 00:36:07,159
好吧，我可以把它的宽度

818
00:36:07,159 --> 00:36:09,210
或者我可以把它做成高度。 

819
00:36:09,210 --> 00:36:11,559
我真的希望它是两者中的较小者。 

820
00:36:11,559 --> 00:36:14,730
所以在这种情况下，我绝对不想拥有自己的半径

821
00:36:14,730 --> 00:36:18,309
等于这个空间的一半

822
00:36:18,309 --> 00:36:20,519
因为那样的话太大了。 

823
00:36:20,519 --> 00:36:22,780
所以我要选择宽度或高度中较小的一个

824
00:36:22,780 --> 00:36:24,340
并将其除以二，以得出半径

825
00:36:24,539 --> 00:36:26,019
而不是直径。 

826
00:36:26,019 --> 00:36:29,826
因此，让我们使半径等于最小值

827
00:36:29,827 --> 00:36:34,148
矩形的宽度和矩形的高度

828
00:36:34,347 --> 00:36:35,713
我们除以二。 

829
00:36:36,983 --> 00:36:38,889
所以我认为这就是我们要做的

830
00:36:38,889 --> 00:36:42,369
起床到这里的顶部。 

831
00:36:42,369 --> 00:36:45,500
现在我们需要大步向前。 

832
00:36:45,500 --> 00:36:46,719
好吧，转弯。 

833
00:36:46,719 --> 00:36:51,239
幸运的是Path也具有起弧功能。 

834
00:36:51,239 --> 00:36:55,779
它称为addArc，您可以用不同的方法来做。 

835
00:36:55,780 --> 00:36:57,860
我要在这里选择最简单的一个

836
00:36:58,059 --> 00:36:59,329
让您创建弧线

837
00:36:59,329 --> 00:37:03,319
通过指定圆弧的中心，圆弧的半径， 

838
00:37:03,320 --> 00:37:05,400
起始角度和终止角度

839
00:37:05,400 --> 00:37:08,121
以及您是否要顺时针旋转

840
00:37:08,121 --> 00:37:10,420
还是逆时针，对不对？ 

841
00:37:10,420 --> 00:37:12,711
所以我们是否要像这样逆时针走

842
00:37:12,911 --> 00:37:15,422
或者我们是否要像这样顺时针旋转。 

843
00:37:16,619 --> 00:37:17,929
因此，让我们给这个中心。 

844
00:37:17,929 --> 00:37:20,329
我们知道中心就是那个中心半径。 

845
00:37:20,329 --> 00:37:21,920
是的，我们也知道。 

846
00:37:21,920 --> 00:37:23,222
起始角度？ 

847
00:37:23,222 --> 00:37:25,489
是的，我们知道起始角度。 

848
00:37:25,489 --> 00:37:26,719
结束角？ 

849
00:37:26,719 --> 00:37:28,519
是的，这就是这里的变量。 

850
00:37:28,519 --> 00:37:29,530
这真的很容易。 

851
00:37:29,530 --> 00:37:31,750
那顺时针呢？ 

852
00:37:31,750 --> 00:37:33,376
这是一个布尔值，无论我们是否顺时针旋转， 

853
00:37:33,376 --> 00:37:36,519
让我们也允许人们使用我们来告诉我们。 

854
00:37:36,719 --> 00:37:38,480
所以我们说顺时针是一个布尔， 

855
00:37:39,530 --> 00:37:40,983
顺时针放在这里。 

856
00:37:41,958 --> 00:37:44,960
而且，我们不要让他们这么说。 

857
00:37:44,960 --> 00:37:49,070
我们将使用默认值，我们将使用顺时针false。 

858
00:37:49,070 --> 00:37:51,141
那恰好是我们想要的方式，对吗？ 

859
00:37:51,340 --> 00:37:54,559
逆时针旋转，所以我们将顺时针旋转为false 

860
00:37:54,559 --> 00:37:56,130
为我们的派工作。 

861
00:37:56,130 --> 00:37:58,260
但这只是默认设置，我们不得不选择其中之一， 

862
00:37:58,260 --> 00:37:59,810
我们不妨选择这个。 

863
00:38:01,010 --> 00:38:02,190
那是弧线。 

864
00:38:02,190 --> 00:38:05,059
我们在这里的小路径几乎完成了。 

865
00:38:05,059 --> 00:38:07,889
它绕了过去，现在需要回到中间。 

866
00:38:07,889 --> 00:38:10,779
所以我们需要一条线回到那里的中心。 

867
00:38:10,780 --> 00:38:14,823
这就是p点addLine到中心。 

868
00:38:15,657 --> 00:38:16,960
就是这样。 

869
00:38:16,960 --> 00:38:18,639
我们在这里完成了自定义形状。 

870
00:38:18,639 --> 00:38:21,973
我们要做的就是定义此Path并返回它， 

871
00:38:21,974 --> 00:38:23,780
我们有一个自定义的形状

872
00:38:23,780 --> 00:38:25,519
形状会照顾其他一切， 

873
00:38:25,519 --> 00:38:27,476
填满它，抚摸它，所有这些东西

874
00:38:27,476 --> 00:38:28,772
它知道该怎么做。 

875
00:38:29,929 --> 00:38:31,119
让我们回到我们的观点

876
00:38:31,119 --> 00:38:33,980
在这里使用Circle的地方

877
00:38:33,980 --> 00:38:36,539
我们将改用Pie。 

878
00:38:36,539 --> 00:38:37,962
所以，让我们做派。 

879
00:38:39,769 --> 00:38:42,480
糟糕，抱歉，在那里退出Xcode。 

880
00:38:42,480 --> 00:38:45,269
让我们回到这里。 

881
00:38:45,269 --> 00:38:46,242
对于那个很抱歉。 

882
00:38:47,130 --> 00:38:49,269
我们知道Pie有一些变种。 

883
00:38:49,469 --> 00:38:52,089
我要初始化起始角度和终止角度。 

884
00:38:52,090 --> 00:38:54,670
请注意，顺时针方向是可选的。 

885
00:38:54,869 --> 00:38:56,579
我们不必指定。 

886
00:38:56,579 --> 00:38:58,949
因此，我们选择在此处进行起始和终止角度。 

887
00:38:58,949 --> 00:39:01,163
现在我们要从什么角度开始？ 

888
00:39:01,163 --> 00:39:04,715
好吧，我们想从这里开始

889
00:39:04,715 --> 00:39:08,170
然后逆时针转到此处。 

890
00:39:08,170 --> 00:39:12,840
所以直线向上可能是角度点度为零， 

891
00:39:14,570 --> 00:39:17,023
然后是结束角，我们在哪里结束？ 

892
00:39:17,960 --> 00:39:20,070
我们在这里结束。 

893
00:39:20,070 --> 00:39:23,460
好吧，如果这是零，那将是90 

894
00:39:23,460 --> 00:39:26,539
所以就像110度

895
00:39:26,539 --> 00:39:28,150
这样的事情。 

896
00:39:28,150 --> 00:39:31,356
让我们尝试角度角度为110。 

897
00:39:33,949 --> 00:39:36,559
哦，那还不行。 

898
00:39:36,559 --> 00:39:37,989
这里发生了什么？ 

899
00:39:37,989 --> 00:39:41,869
看起来不像这样。 

900
00:39:41,869 --> 00:39:43,313
那么为什么这是一个问题呢？ 

901
00:39:44,199 --> 00:39:46,300
好吧，首先要了解的是iOS 

902
00:39:46,300 --> 00:39:51,259
是零角度，零度不向上， 

903
00:39:51,260 --> 00:39:53,440
它在右边。 

904
00:39:53,639 --> 00:39:55,199
零角度在右边。 

905
00:39:55,199 --> 00:39:58,109
所以如果我们希望这种程度

906
00:39:58,110 --> 00:39:59,420
零直线上升

907
00:39:59,619 --> 00:40:02,395
我们要减去90度

908
00:40:02,396 --> 00:40:04,110
从所有这些角度来看。 

909
00:40:04,110 --> 00:40:06,099
所以那90度

910
00:40:06,099 --> 00:40:08,365
与那个角度成90度角

911
00:40:08,365 --> 00:40:10,420
但这也不是很有效。 

912
00:40:10,420 --> 00:40:13,041
那仍然不是我们在这里寻找的东西。 

913
00:40:13,041 --> 00:40:15,539
好像是从零开始的

914
00:40:15,539 --> 00:40:20,025
但它是顺时针而不是逆时针。 

915
00:40:20,025 --> 00:40:24,099
我可以肯定在这里我说的是顺时针错误。 

916
00:40:24,099 --> 00:40:25,119
是的，逆时针旋转。 

917
00:40:25,119 --> 00:40:26,452
这是怎么回事？ 

918
00:40:27,710 --> 00:40:30,443
那是不可能的，那不可能发生。 

919
00:40:30,643 --> 00:40:33,682
嗯，这是因为在iOS中， 

920
00:40:37,130 --> 00:40:40,230
您要在其中绘制的图形坐标系

921
00:40:40,230 --> 00:40:41,063
就在这儿， 

922
00:40:41,063 --> 00:40:46,063
在左上角有（0，0），并且上下颠倒。 

923
00:40:46,170 --> 00:40:47,800
因此，这将增加Y。 

924
00:40:47,800 --> 00:40:49,210
从（0，0）开始

925
00:40:49,210 --> 00:40:51,130
随着我们来到这里，Y越来越大。 

926
00:40:51,130 --> 00:40:53,976
您习惯的不是笛卡尔坐标

927
00:40:53,976 --> 00:40:56,150
从您的三角学课。 

928
00:40:56,150 --> 00:40:59,500
这不是（0，0），这里是（0，0）。 

929
00:40:59,699 --> 00:41:01,583
因此，由于整个过程都是颠倒的， 

930
00:41:01,583 --> 00:41:03,440
顺时针和逆时针

931
00:41:03,440 --> 00:41:05,519
也正朝着相反的方向发展。 

932
00:41:05,719 --> 00:41:09,189
所以我们实际上需要这个起始角度，终止角度

933
00:41:09,190 --> 00:41:14,190
而且我们也希望顺时针为真。 

934
00:41:14,239 --> 00:41:17,172
因此，即使我们确实走了相反的方向， 

935
00:41:17,172 --> 00:41:19,422
我们不得不说顺时针是真的。 

936
00:41:20,599 --> 00:41:24,130
可以肯定的是，这正是我们想要的。 

937
00:41:26,320 --> 00:41:29,920
现在，在下一个讲座中，我们将开始对此进行动画处理。 

938
00:41:29,920 --> 00:41:32,349
举例来说，我们仍然让它从零开始， 

939
00:41:32,349 --> 00:41:34,319
但是随着时间的流逝， 

940
00:41:34,320 --> 00:41:37,313
从110、150开始， 

941
00:41:38,280 --> 00:41:39,733
 200， 

942
00:41:40,679 --> 00:41:41,889
 300， 

943
00:41:41,889 --> 00:41:44,710
滴答作响350 

944
00:41:44,710 --> 00:41:47,980
几乎提高了360倍。 

945
00:41:47,980 --> 00:41:50,789
所以我们要为这个角度做动画

946
00:41:50,989 --> 00:41:53,132
下降到零。 

947
00:41:54,570 --> 00:41:55,800
这将在下一次演讲中

948
00:41:55,800 --> 00:41:57,420
当我们谈论动画时。 

949
00:41:57,420 --> 00:41:59,079
我们要在动画中谈论的第一件事

950
00:41:59,079 --> 00:42:00,679
给Views设置动画。 

951
00:42:00,679 --> 00:42:02,389
意见来来去去， 

952
00:42:02,389 --> 00:42:04,089
他们越来越大。 

953
00:42:04,090 --> 00:42:05,329
有时候他们在做特别的事情

954
00:42:05,329 --> 00:42:07,677
就像CardView可能会翻转一样。 

955
00:42:07,677 --> 00:42:11,766
好的，可以做3D旋转来翻转。 

956
00:42:11,965 --> 00:42:14,913
现在，查看动画的方式不同。 

957
00:42:14,913 --> 00:42:18,032
形状是动画的，它们直接为自己设置动画。 

958
00:42:18,032 --> 00:42:21,646
视图通过其修改器进行动画处理。 

959
00:42:21,646 --> 00:42:24,653
因此，要了解如何为视图设置动画， 

960
00:42:24,653 --> 00:42:26,635
我们将不得不花一点时间来动画

961
00:42:26,635 --> 00:42:30,498
并讨论什么是ViewModifier。 

962
00:42:30,498 --> 00:42:32,009
现在，您一直在使用ViewModifiers 

963
00:42:32,009 --> 00:42:34,760
到目前为止，在记忆的整个地方， 

964
00:42:34,760 --> 00:42:37,967
 AspectRatio，填充，字体，前景颜色。 

965
00:42:38,166 --> 00:42:41,309
所有这些都是ViewModifiers。 

966
00:42:41,309 --> 00:42:44,489
他们修改一个视图并返回一个新的视图

967
00:42:44,489 --> 00:42:47,289
那是您调用它们的View的修改版本。 

968
00:42:47,289 --> 00:42:50,190
这就是ViewModifiers所做的。 

969
00:42:50,190 --> 00:42:53,340
现在，大多数修饰符，不是全部，而是大多数， 

970
00:42:53,340 --> 00:42:55,829
可能只是转过身来实现

971
00:42:55,829 --> 00:43:00,103
并在View协议中调用一个非常重要的功能， 

972
00:43:00,103 --> 00:43:03,829
通过扩展名添加到View协议

973
00:43:03,829 --> 00:43:05,952
称为修饰符。 

974
00:43:05,952 --> 00:43:08,269
 View中的此功能修饰符， 

975
00:43:08,269 --> 00:43:10,199
需要一个论点

976
00:43:10,199 --> 00:43:12,513
这本质上是实现

977
00:43:12,514 --> 00:43:15,090
 ViewModifier协议。 

978
00:43:15,090 --> 00:43:16,240
所以这里aspectRatio 2/3 

979
00:43:17,719 --> 00:43:20,039
由于空间原因，我放弃了合适的人选， 

980
00:43:20,239 --> 00:43:21,791
但是aspectRatio 2/3 

981
00:43:21,791 --> 00:43:25,599
可能会执行类似调用View的操作， 

982
00:43:25,599 --> 00:43:28,089
在您将AspectRatio发送到的同一视图上， 

983
00:43:28,090 --> 00:43:29,224
就是说点修饰符， 

984
00:43:29,224 --> 00:43:32,803
 AspectModifier是2/3的某种结构。 

985
00:43:33,800 --> 00:43:37,400
因此，让我们谈谈ViewModifier协议是什么。 

986
00:43:37,400 --> 00:43:39,324
顾名思义，您几乎可以猜到。 

987
00:43:39,324 --> 00:43:41,519
它只有一个功能

988
00:43:41,719 --> 00:43:43,978
而唯一起作用的就是拿点东西

989
00:43:43,978 --> 00:43:46,219
并对其进行修改以生成一个View。 

990
00:43:46,219 --> 00:43:49,730
例如，您可以调整空间

991
00:43:49,730 --> 00:43:52,769
提供aspectRatio 2/3， 

992
00:43:52,769 --> 00:43:55,820
或ViewModifier可以在外部添加一些填充。 

993
00:43:55,820 --> 00:43:59,440
这就是我确定的填充ViewModifier。 

994
00:43:59,440 --> 00:44:01,269
那么该代码对于协议来说是什么样的呢？ 

995
00:44:01,269 --> 00:44:03,811
这就是协议ViewModifier。 

996
00:44:03,811 --> 00:44:07,030
第一行关联类型Content。 

997
00:44:07,030 --> 00:44:10,940
再次，你们阅读了阅读作业，我希望

998
00:44:10,940 --> 00:44:13,175
并且您了解什么是关联类型内容

999
00:44:13,175 --> 00:44:16,539
是不在乎协议。 

1000
00:44:16,739 --> 00:44:19,609
协议，就像功能和类型一样

1001
00:44:19,610 --> 00:44:21,460
他们也不在乎， 

1002
00:44:21,659 --> 00:44:25,069
但它们的语法是关联类型Content， 

1003
00:44:25,070 --> 00:44:28,230
而不是您在struct上看到的尖括号。 

1004
00:44:28,230 --> 00:44:30,449
因此，ViewModifier协议不必关心

1005
00:44:30,449 --> 00:44:31,699
称为内容。 

1006
00:44:31,699 --> 00:44:34,956
真的不在乎Content是什么类型。 

1007
00:44:34,956 --> 00:44:36,609
好吧，现在，一旦您了解了， 

1008
00:44:36,610 --> 00:44:38,750
我们可以看一下ViewModifier中的唯一函数， 

1009
00:44:38,949 --> 00:44:40,480
这是身体。 

1010
00:44:40,480 --> 00:44:43,159
身体接受了无关紧要的内容， 

1011
00:44:43,159 --> 00:44:44,297
我们真的不在乎那是什么， 

1012
00:44:44,297 --> 00:44:47,842
它返回非常重要的一些视图。 

1013
00:44:48,809 --> 00:44:51,929
在那个身体里面，只需要吸收内容

1014
00:44:51,929 --> 00:44:52,762
那是给它的

1015
00:44:52,762 --> 00:44:56,449
然后以某种方式组成一个View并将其返回。 

1016
00:44:56,449 --> 00:45:00,899
现在，当您在View上调用点修饰符时， 

1017
00:45:00,900 --> 00:45:02,394
通过的内容

1018
00:45:02,394 --> 00:45:06,679
是将“发送点的视图”修改器发送到的视图，对吗？ 

1019
00:45:06,679 --> 00:45:08,829
您调用的点修饰符所在的视图， 

1020
00:45:08,829 --> 00:45:10,215
这就是内容。 

1021
00:45:10,215 --> 00:45:12,605
这样就可以使任何ViewModifier 

1022
00:45:12,605 --> 00:45:16,289
用点修饰符调用

1023
00:45:16,289 --> 00:45:19,559
将获得作为内容调用的视图。 

1024
00:45:19,559 --> 00:45:22,789
这就是为什么我们说它修改了该视图。 

1025
00:45:22,789 --> 00:45:23,971
它将创建一个新的视图

1026
00:45:23,972 --> 00:45:27,763
使用该视图，您会将其作为内容发送到。 

1027
00:45:29,000 --> 00:45:32,349
是的，让我们来看一个例子

1028
00:45:32,349 --> 00:45:35,150
使这一切更加具体。 

1029
00:45:35,150 --> 00:45:38,130
假设我想拥有一个ViewModifier 

1030
00:45:38,130 --> 00:45:41,420
像我们的文字幽灵一样使用任何视图

1031
00:45:41,420 --> 00:45:43,750
或任何查看图像的任何内容， 

1032
00:45:43,949 --> 00:45:47,239
并对其进行了修改，使其看起来像卡。 

1033
00:45:47,239 --> 00:45:50,694
基本上将其卡住。 

1034
00:45:50,695 --> 00:45:52,074
这就是我们想要构建的。 

1035
00:45:52,273 --> 00:45:55,799
现在听起来这是一个非常复杂的修饰符。 

1036
00:45:55,800 --> 00:45:58,250
这比仅在其周围填充填充更加复杂

1037
00:45:58,449 --> 00:46:00,299
或类似的东西。 

1038
00:46:00,300 --> 00:46:02,184
它实际上是一个非常简单的修饰符， 

1039
00:46:02,184 --> 00:46:04,260
但从概念上讲，这是有道理的。 

1040
00:46:04,260 --> 00:46:06,960
现在在我们的应用中，我们甚至不一定需要修饰符

1041
00:46:07,159 --> 00:46:10,460
之所以这样，是因为我们只有一种观点

1042
00:46:10,460 --> 00:46:12,134
曾经被证伪， 

1043
00:46:12,134 --> 00:46:14,980
但您可以想象一个应用中有一些卡片

1044
00:46:14,980 --> 00:46:17,300
上面有图片，有一些表情符号， 

1045
00:46:17,300 --> 00:46:19,327
有些只是文字或其他内容，其他抽认卡， 

1046
00:46:19,327 --> 00:46:21,610
但他们都有相同的卡。 

1047
00:46:21,610 --> 00:46:24,423
能够对任何视图进行梳理可能很有意义。 

1048
00:46:25,300 --> 00:46:26,490
这是代码的样子。 

1049
00:46:26,490 --> 00:46:28,360
第一行实际上是

1050
00:46:28,360 --> 00:46:30,690
我们如何称呼修饰符。 

1051
00:46:30,690 --> 00:46:32,202
例如，如果我们想进行卡片化

1052
00:46:32,202 --> 00:46:36,750
我们的幽灵文本，我们会说点修饰符， 

1053
00:46:36,750 --> 00:46:38,469
那个非常重要的View功能

1054
00:46:38,469 --> 00:46:40,809
参数是ViewModifier。 

1055
00:46:40,809 --> 00:46:42,659
现在我要叫我的ViewModifier， 

1056
00:46:42,659 --> 00:46:45,920
您可以在下一行看到struct Cardify结构。 

1057
00:46:45,920 --> 00:46:48,500
我将其称为Cardify，它实际上需要一个参数。 

1058
00:46:48,500 --> 00:46:49,800
我们将讨论这一点。 

1059
00:46:49,800 --> 00:46:52,706
但最终，尽管如此，我实际上还是想说

1060
00:46:52,706 --> 00:46:55,860
文字点成Cardify， 

1061
00:46:55,860 --> 00:46:58,690
就像我说的是点前景颜色，点填充

1062
00:46:58,889 --> 00:47:00,329
我想说点Cardify。 

1063
00:47:00,329 --> 00:47:02,469
我不想说点修饰符Cardify。 

1064
00:47:02,469 --> 00:47:03,302
所以在下一张幻灯片上

1065
00:47:03,302 --> 00:47:06,319
我们将展示如何从点修饰符Cardify得到

1066
00:47:06,320 --> 00:47:08,360
点Cardify。 

1067
00:47:08,360 --> 00:47:09,407
但现在，让我们专注于

1068
00:47:09,407 --> 00:47:12,769
我们将如何实现Cardify ViewModifier 

1069
00:47:12,769 --> 00:47:16,840
因为这一定要带上文字幽灵

1070
00:47:16,840 --> 00:47:19,269
并对其进行修改，将其转换为新的视图

1071
00:47:19,469 --> 00:47:20,489
看起来像卡。 

1072
00:47:20,489 --> 00:47:22,189
这就是这件事要做的。 

1073
00:47:23,039 --> 00:47:26,219
我想看的第一件事是Content参数

1074
00:47:26,219 --> 00:47:28,752
在ViewModifier中添加到该主体函数。 

1075
00:47:28,753 --> 00:47:32,503
我把它出现的所有地方都变黄了， 

1076
00:47:32,503 --> 00:47:34,016
这是对身体的争论。 

1077
00:47:34,215 --> 00:47:38,949
您可以在顶部看到Text鬼魂是那个Content是什么

1078
00:47:38,949 --> 00:47:41,649
然后也往下看ZStack 

1079
00:47:41,650 --> 00:47:45,010
我嵌入该内容，它是一个视图

1080
00:47:45,010 --> 00:47:47,320
并将其嵌入到我的ZStack中

1081
00:47:47,519 --> 00:47:51,070
在同一地方，我会将其放回旧代码中。 

1082
00:47:51,070 --> 00:47:54,320
所以现在要获取任何视图并将其嵌入到此处

1083
00:47:54,320 --> 00:47:58,130
在我的ZStack卡上。 

1084
00:47:58,329 --> 00:48:02,009
那么您是否知道这将如何修改视图

1085
00:48:02,010 --> 00:48:04,653
您将其发送到看起来像卡片。 

1086
00:48:05,780 --> 00:48:07,192
现在，这里要注意的一件事是

1087
00:48:07,391 --> 00:48:10,349
该ViewModifier需要一些信息， 

1088
00:48:10,349 --> 00:48:12,677
需要知道卡是面朝上还是面朝下。 

1089
00:48:12,677 --> 00:48:17,039
这是一个结构，所以我只添加一个var isFaceUp 

1090
00:48:17,039 --> 00:48:20,210
我们知道，如果您有一个var且未初始化， 

1091
00:48:20,210 --> 00:48:21,898
然后谁创建这个结构， 

1092
00:48:21,898 --> 00:48:24,389
在最上面

1093
00:48:24,389 --> 00:48:27,059
它需要指定它的值。 

1094
00:48:27,059 --> 00:48:29,719
所以希望这是您熟悉的样子

1095
00:48:29,719 --> 00:48:30,552
当您执行这些修饰符时， 

1096
00:48:30,552 --> 00:48:33,159
显然很多人都在争论

1097
00:48:33,159 --> 00:48:34,989
前景色采用一种颜色

1098
00:48:34,989 --> 00:48:38,410
填充可能会占用顶部或底部

1099
00:48:38,411 --> 00:48:42,000
以及要填充的点数和所有其他这些参数。 

1100
00:48:42,000 --> 00:48:45,230
这些只是要放在ViewModifier中进行填充， 

1101
00:48:45,230 --> 00:48:46,123
例如。 

1102
00:48:47,849 --> 00:48:51,413
所以点修饰符，那个函数，它返回一个View， 

1103
00:48:51,413 --> 00:48:53,663
返回符合View的内容

1104
00:48:53,663 --> 00:48:58,663
这将在这里使用身体的紫色内容

1105
00:48:59,034 --> 00:49:01,282
绘制视图。 

1106
00:49:02,280 --> 00:49:06,039
现在修饰符不会直接返回此紫色代码

1107
00:49:06,239 --> 00:49:08,436
返回另一个也是View的东西， 

1108
00:49:08,436 --> 00:49:09,269
但是那是另外一回事

1109
00:49:09,269 --> 00:49:12,192
将使用此紫色代码绘制绘制的内容。 

1110
00:49:13,309 --> 00:49:14,273
如此简单。 

1111
00:49:14,273 --> 00:49:18,069
点修饰符将仅用于使用ViewModifier， 

1112
00:49:18,070 --> 00:49:21,753
将其发送给身体的视图

1113
00:49:21,753 --> 00:49:25,371
它会得到任何必要的内置

1114
00:49:25,371 --> 00:49:27,690
并作为要使用的新视图返回。 

1115
00:49:27,690 --> 00:49:29,730
然后当然，因为那是一个视图， 

1116
00:49:29,730 --> 00:49:31,469
我们可以给它发送另一个修饰符

1117
00:49:31,469 --> 00:49:34,189
以及另一个修饰符，等等

1118
00:49:34,190 --> 00:49:36,539
斯威夫特在跟踪方面非常聪明

1119
00:49:36,539 --> 00:49:38,766
修改，修改，修改时

1120
00:49:38,766 --> 00:49:41,583
这样它就可以做动画之类的事情

1121
00:49:43,420 --> 00:49:47,119
那么我们如何从这种文本点修饰符语法中获得

1122
00:49:47,119 --> 00:49:48,563
点上Cardify， 

1123
00:49:48,563 --> 00:49:51,049
因为这就是我们想要点Cardify的原因。 

1124
00:49:51,050 --> 00:49:52,760
真的很容易，您实际上知道如何执行此操作。 

1125
00:49:52,760 --> 00:49:55,208
我将创建View协议的扩展， 

1126
00:49:55,407 --> 00:49:57,528
添加功能cardify 

1127
00:49:57,528 --> 00:50:00,400
卡片化显然会返回一些视图

1128
00:50:00,400 --> 00:50:03,190
它只会返回自我点修饰符

1129
00:50:03,190 --> 00:50:04,023
 Cardify的

1130
00:50:04,023 --> 00:50:05,170
请记住，这是View的扩展， 

1131
00:50:05,170 --> 00:50:06,534
所以自我就是观点。 

1132
00:50:06,534 --> 00:50:09,348
所以我当然可以在自身上调用点修饰符

1133
00:50:09,349 --> 00:50:11,730
并将其传递给正确的ViewModifier， 

1134
00:50:11,929 --> 00:50:13,230
在这种情况下，我们的Cardify。 

1135
00:50:15,980 --> 00:50:18,148
好吧，让我们去实现这个

1136
00:50:18,148 --> 00:50:21,042
在我们的记忆应用程序中。 

1137
00:50:22,300 --> 00:50:26,360
在此演示中，我们的目标是使所有View， 

1138
00:50:26,559 --> 00:50:31,259
包括我们的幽灵和吃豆人都可以被证成

1139
00:50:31,260 --> 00:50:34,820
这意味着当它面朝上时将其周围环绕

1140
00:50:35,019 --> 00:50:38,182
或者只是在面朝下时将其拉回。 

1141
00:50:39,190 --> 00:50:41,289
让我们通过想象开始这个演示

1142
00:50:41,489 --> 00:50:45,359
如果有这个修饰符，我们的代码将是什么样子。 

1143
00:50:45,360 --> 00:50:48,710
让我们在此处留出一些空间，以便我们了解发生了什么。 

1144
00:50:48,710 --> 00:50:53,460
我现在要把我们的卡的一部分

1145
00:50:53,460 --> 00:50:54,730
会被气化的

1146
00:50:54,730 --> 00:50:56,759
就是馅饼和文字。 

1147
00:50:56,759 --> 00:50:59,300
我们将把它们与代码分开

1148
00:50:59,300 --> 00:51:01,670
这实际上是在做卡片化。 

1149
00:51:01,869 --> 00:51:04,759
然后我们要拿这个ZStack 

1150
00:51:04,760 --> 00:51:07,230
里面有我们想要的东西， 

1151
00:51:07,230 --> 00:51:09,519
然后我要说点Cardify来进行卡片化。 

1152
00:51:09,519 --> 00:51:12,130
当然，持牌人需要知道

1153
00:51:12,130 --> 00:51:14,291
这个东西是否正视。 

1154
00:51:14,291 --> 00:51:17,980
所以我要过去那面朝上

1155
00:51:17,980 --> 00:51:21,179
我们将看到如何指定

1156
00:51:21,179 --> 00:51:22,300
一点点。 

1157
00:51:22,300 --> 00:51:24,489
现在这段代码就是这样

1158
00:51:24,489 --> 00:51:26,353
实际上是进行卡片化对吧？ 

1159
00:51:26,353 --> 00:51:28,902
将RoundedRectangles放在后面或前面。 

1160
00:51:28,902 --> 00:51:30,296
只是要把它剪下来

1161
00:51:30,297 --> 00:51:34,789
然后将其放入Cardify ViewModifier中。 

1162
00:51:34,989 --> 00:51:35,822
在我去那之前

1163
00:51:35,822 --> 00:51:38,569
我最终确实希望这样说， 

1164
00:51:38,570 --> 00:51:40,518
但是我们知道ViewModifiers 

1165
00:51:40,717 --> 00:51:44,679
正在调用称为修饰符的此View函数

1166
00:51:44,679 --> 00:51:48,239
那么您只需指定所需的ViewModifier。 

1167
00:51:48,239 --> 00:51:50,359
因此，我们将创建ViewModifier来做到这一点， 

1168
00:51:50,360 --> 00:51:51,530
我将其称为Cardify 

1169
00:51:51,530 --> 00:51:55,769
而且当然必须要把脸朝上

1170
00:51:55,769 --> 00:51:57,813
作为争论。 

1171
00:51:57,813 --> 00:52:01,733
这就是这个问题的解决者真正要做的

1172
00:52:01,733 --> 00:52:04,800
这最终将成为我们要创建的功能

1173
00:52:04,800 --> 00:52:07,610
只是这一行而已。 

1174
00:52:07,610 --> 00:52:10,440
所以我们将其注释掉并将其放回去

1175
00:52:10,639 --> 00:52:13,469
一旦我们添加了一个称为衬套的衬套。 

1176
00:52:13,469 --> 00:52:15,180
但这就是要做的

1177
00:52:15,181 --> 00:52:18,697
当然，它说未解析的标识符Cardify， 

1178
00:52:18,697 --> 00:52:23,578
我们必须编写执行此ViewModifier的代码。 

1179
00:52:23,579 --> 00:52:24,789
因此，让我们跳过去。 

1180
00:52:24,989 --> 00:52:26,392
文件，新文件。 

1181
00:52:27,690 --> 00:52:32,380
这不是SwiftUI视图，而是ViewModifier。 

1182
00:52:32,380 --> 00:52:34,724
因此，我们将点击此处，我​​们将转到此处， 

1183
00:52:34,724 --> 00:52:37,139
我将其称为Cardify 

1184
00:52:37,139 --> 00:52:39,190
那是我的新修饰符的名称。 

1185
00:52:39,190 --> 00:52:41,500
注意它没有放在正确的位置。 

1186
00:52:41,500 --> 00:52:43,159
这是一个很好的例子。 

1187
00:52:43,159 --> 00:52:45,480
我不想在顶部的这个蓝色的东西。 

1188
00:52:45,480 --> 00:52:48,039
我要在这里，这个黄色的文件夹

1189
00:52:48,239 --> 00:52:49,733
我希望这是同一个地方

1190
00:52:49,733 --> 00:52:53,309
这个黄色文件夹在这里。 

1191
00:52:53,309 --> 00:52:55,049
所以希望大家都记得这样做

1192
00:52:55,050 --> 00:52:57,610
这样您就不会到处都是文件

1193
00:52:57,610 --> 00:52:58,443
他们不应该。 

1194
00:52:58,443 --> 00:53:00,030
因此，创建Cardify。 

1195
00:53:00,030 --> 00:53:01,088
这是Cardify。 

1196
00:53:01,088 --> 00:53:05,960
现在，当然，ViewModifiers很大程度上是UI的东西， 

1197
00:53:05,960 --> 00:53:08,269
所以我们不说在那儿导入Foundation， 

1198
00:53:08,469 --> 00:53:11,010
并创建一个ViewModifier，非常简单。 

1199
00:53:11,010 --> 00:53:15,333
结构Cardify，这是一个ViewModifier 

1200
00:53:16,320 --> 00:53:18,920
当我们这样做时，我们将立即得到一个错误

1201
00:53:18,920 --> 00:53:22,974
表示Cardify不符合协议ViewModifier。 

1202
00:53:22,974 --> 00:53:26,150
该协议仅具有一个功能， 

1203
00:53:26,349 --> 00:53:30,275
它称为主体，它以内容为参数。 

1204
00:53:30,275 --> 00:53:34,230
此处的此内容是无关紧要的

1205
00:53:34,429 --> 00:53:37,109
从这个协议。 

1206
00:53:37,110 --> 00:53:39,230
因此协议也可以不在乎。 

1207
00:53:39,230 --> 00:53:43,010
他们使用该associatedtype语法指定它们

1208
00:53:43,010 --> 00:53:45,610
在阅读作业中读到的

1209
00:53:45,809 --> 00:53:47,369
所以这可以是任何东西。 

1210
00:53:47,369 --> 00:53:49,079
这不在乎。 

1211
00:53:49,079 --> 00:53:51,279
我们将在短短一秒钟内讨论一下。 

1212
00:53:51,280 --> 00:53:52,490
那当然是一个ViewModifier 

1213
00:53:52,490 --> 00:53:56,869
它正在修改一个视图，然后返回一些新的视图

1214
00:53:56,869 --> 00:54:00,069
那是它的修改版本。 

1215
00:54:00,070 --> 00:54:01,117
所以这个论点在这里， 

1216
00:54:01,117 --> 00:54:03,324
只是为了提醒您幻灯片

1217
00:54:03,324 --> 00:54:07,420
当我们在这里回叫修改器Cardify时， 

1218
00:54:07,420 --> 00:54:10,880
要求我们修改的内容

1219
00:54:10,880 --> 00:54:15,610
将成为我们称之为修改器的任何视图。 

1220
00:54:15,610 --> 00:54:17,920
因此，我们将在ZStack上调用修饰符。 

1221
00:54:18,119 --> 00:54:20,289
所以在这种情况下，我们的梳理机内部

1222
00:54:20,289 --> 00:54:22,579
内容将是ZStack。 

1223
00:54:22,579 --> 00:54:27,027
这始终是您在其上调用点修饰符的视图。 

1224
00:54:27,027 --> 00:54:28,789
那么，这里发生了什么？ 

1225
00:54:28,789 --> 00:54:31,889
在这里，我们只需要创建修改后的视图， 

1226
00:54:31,889 --> 00:54:33,440
换句话说，一个卡片化视图。 

1227
00:54:33,440 --> 00:54:37,710
所以我只是要粘贴我们以前拥有的东西

1228
00:54:37,710 --> 00:54:40,849
当然，这仍然必须在ZStack中

1229
00:54:40,849 --> 00:54:44,289
因为我们仍然有这些RoundedRectangles 

1230
00:54:44,289 --> 00:54:45,670
彼此堆叠。 

1231
00:54:45,670 --> 00:54:47,960
因此，让我们继续进行。 

1232
00:54:47,960 --> 00:54:51,369
我们这里有一些未定义的东西， 

1233
00:54:51,369 --> 00:54:53,799
如cornerRadius和edgeLineWidth。 

1234
00:54:53,800 --> 00:54:55,769
那些都在这里，那就是绘制常量。 

1235
00:54:55,969 --> 00:54:57,679
我们不再需要它们了

1236
00:54:57,679 --> 00:55:00,629
因为我们使用卡片化来制作卡片。 

1237
00:55:00,630 --> 00:55:03,378
因此，我们将其弹出此处。 

1238
00:55:03,378 --> 00:55:05,839
这解决了我们的大多数问题。 

1239
00:55:05,840 --> 00:55:09,324
我们确实知道我们必须通过这是空间

1240
00:55:09,324 --> 00:55:11,250
作为这里的一个论点

1241
00:55:11,449 --> 00:55:14,012
 Cardify需要知道它是否面朝上

1242
00:55:14,012 --> 00:55:17,822
所以它会有一个var isFaceUp这是一个布尔值

1243
00:55:17,822 --> 00:55:19,969
我不会把它设置为等于

1244
00:55:20,168 --> 00:55:23,259
因此，只要有人在这里创建Cardify， 

1245
00:55:23,260 --> 00:55:27,090
他们必须告诉我isFaceUp的价值是什么

1246
00:55:27,090 --> 00:55:29,833
然后我要在里面使用这个isFaceUp 

1247
00:55:29,833 --> 00:55:33,380
任何时候我想检查一下我是否正对面。 

1248
00:55:33,380 --> 00:55:35,123
现在，这是匹配的东西。 

1249
00:55:35,123 --> 00:55:39,809
 isMatched确实不属于Cardify。 

1250
00:55:39,809 --> 00:55:42,299
匹配与我们的纸牌游戏有关。 

1251
00:55:42,300 --> 00:55:45,070
此Cardify可以Cardify任何视图， 

1252
00:55:45,070 --> 00:55:47,250
不只是我们的纸牌游戏中的“观看次数”。 

1253
00:55:47,449 --> 00:55:51,250
这可以使卡面朝上，面朝下在任何视图上。 

1254
00:55:51,250 --> 00:55:53,289
所以我们想保持通用。 

1255
00:55:53,289 --> 00:55:56,840
我们不希望它与应用程序的其余部分绑定在一起。 

1256
00:55:56,840 --> 00:55:58,460
这是一件很好的可重用的事情

1257
00:55:58,460 --> 00:55:59,909
我们实际上可以使用其他游戏- 

1258
00:55:59,909 --> 00:56:02,029
假设我们写了其他游戏

1259
00:56:02,030 --> 00:56:05,097
卡片上有一些文字，卡片上有图像

1260
00:56:05,297 --> 00:56:08,429
卡上的表情符号和表情符号都混在同一个应用中。 

1261
00:56:08,429 --> 00:56:11,569
好吧，我们可以使用Cardify对所有这些东西进行Cardify。 

1262
00:56:11,570 --> 00:56:13,230
但是我们真的无法找到匹配项

1263
00:56:13,230 --> 00:56:17,182
因为匹配特定于此应用，所以请记住。 

1264
00:56:18,409 --> 00:56:19,860
然后我们要在这里做的最后一件事

1265
00:56:19,860 --> 00:56:23,023
显然，此内容需要在此处的某个位置。 

1266
00:56:23,023 --> 00:56:25,730
好吧，我要把它准确地放在以前的位置。 

1267
00:56:25,929 --> 00:56:26,818
只是为了内容。 

1268
00:56:26,818 --> 00:56:30,710
内容就是视图，ZStack 

1269
00:56:30,710 --> 00:56:33,318
该修饰符将被发送到此处。 

1270
00:56:33,318 --> 00:56:34,210
所以我要拿这个

1271
00:56:34,409 --> 00:56:37,349
它会在这里弹出。 

1272
00:56:37,349 --> 00:56:38,344
现在我完成了。 

1273
00:56:38,344 --> 00:56:41,519
这是一个使用此内容的ViewModifier， 

1274
00:56:41,519 --> 00:56:43,978
点修饰符发送到此处的任何视图

1275
00:56:43,978 --> 00:56:47,460
并将其与RoundedRectangles放在ZStack中

1276
00:56:47,460 --> 00:56:50,259
或者，如果它面朝上，就这样做，等等。 

1277
00:56:50,260 --> 00:56:55,013
这是使该内容有意义的东西。 

1278
00:56:56,699 --> 00:56:58,379
做了什么，让我们回到这里。 

1279
00:56:58,380 --> 00:57:01,963
让我们继续运行，看看是否可行。 

1280
00:57:05,018 --> 00:57:07,130
似乎卡的背面正在工作。 

1281
00:57:07,130 --> 00:57:09,369
让我们尝试一下。 

1282
00:57:09,369 --> 00:57:12,156
哦，这很好。 

1283
00:57:12,157 --> 00:57:14,775
现在这里有一个问题

1284
00:57:14,974 --> 00:57:16,902
如果我有比赛

1285
00:57:16,902 --> 00:57:20,476
然后我点击另一张卡片，哦，这些卡片不会消失。 

1286
00:57:20,476 --> 00:57:24,032
那是因为我从那里拿走了匹配的东西。 

1287
00:57:25,079 --> 00:57:26,880
因此，我们必须解决此问题。 

1288
00:57:26,880 --> 00:57:28,300
我们要解决的另一件事是

1289
00:57:28,300 --> 00:57:31,269
我们想要更好的语法点cardify。 

1290
00:57:31,269 --> 00:57:33,159
因此，让我们先修复更好的语法

1291
00:57:33,159 --> 00:57:35,750
然后我们将解决匹配卡的问题

1292
00:57:35,750 --> 00:57:37,610
仍被包括在这里

1293
00:57:37,610 --> 00:57:39,250
什么时候应该把它们拿走。 

1294
00:57:39,449 --> 00:57:41,609
可以证卡的功能

1295
00:57:41,610 --> 00:57:45,010
这只是我们将要添加的扩展名。 

1296
00:57:45,010 --> 00:57:46,690
这显然最有意义

1297
00:57:46,690 --> 00:57:48,400
把它放在这个文件中

1298
00:57:48,400 --> 00:57:51,197
因为这是Cardify ViewModifier所在的位置。 

1299
00:57:51,197 --> 00:57:54,799
所以这是我们想要扩展View的地方

1300
00:57:54,800 --> 00:57:57,210
具有func cardify的功能。 

1301
00:57:57,210 --> 00:57:59,387
现在cardify也将必须采取

1302
00:57:59,387 --> 00:58:01,349
是否面对面作为争论

1303
00:58:01,349 --> 00:58:04,989
只是要归还该卡片化视图

1304
00:58:04,989 --> 00:58:06,412
真的很容易实现。 

1305
00:58:06,413 --> 00:58:07,809
只会自称

1306
00:58:07,809 --> 00:58:10,061
 self是一个View，我们是View的扩展， 

1307
00:58:10,061 --> 00:58:13,327
修饰符，我们要给它一个Cardify 

1308
00:58:13,527 --> 00:58:18,527
 isFaceUp是传递给我们的isFaceUp。 

1309
00:58:18,817 --> 00:58:20,199
就是这样。 

1310
00:58:20,199 --> 00:58:21,462
简单如馅饼。 

1311
00:58:22,320 --> 00:58:23,650
无双关语。 

1312
00:58:23,650 --> 00:58:27,420
我们在这里将cardify变成了一个不错的小功能

1313
00:58:27,420 --> 00:58:30,606
我们可以像这样调用任何视图。 

1314
00:58:30,806 --> 00:58:35,199
您不需要这种稍微笨重的方式

1315
00:58:35,199 --> 00:58:37,946
这对您来说应该像字体

1316
00:58:37,947 --> 00:58:42,543
一些点largeTitle，前景色颜色。 

1317
00:58:43,429 --> 00:58:47,259
匹配的卡片没有消失的事实又如何呢？ 

1318
00:58:47,260 --> 00:58:51,150
我只要做这张整张卡片

1319
00:58:51,349 --> 00:58:56,349
如果卡面朝上或尚未匹配。 

1320
00:58:58,119 --> 00:59:00,460
该卡面朝上，或者我尚未匹配， 

1321
00:59:00,460 --> 00:59:02,920
然后繁荣，我要把这张卡放在那儿。 

1322
00:59:02,920 --> 00:59:05,769
不然我只想要空格

1323
00:59:05,969 --> 00:59:08,119
这正是我们以前所拥有的。 

1324
00:59:08,119 --> 00:59:09,772
现在这给了一个错误，说

1325
00:59:09,773 --> 00:59:13,710
函数声明了不透明的返回类型，是的，某些视图， 

1326
00:59:13,909 --> 00:59:15,989
但没有return return语句。 

1327
00:59:15,989 --> 00:59:16,849
哦是的

1328
00:59:16,849 --> 00:59:19,059
这里没有return语句。 

1329
00:59:19,059 --> 00:59:22,829
我想我可以说归还可以解决这个问题， 

1330
00:59:22,829 --> 00:59:25,219
但是在其他情况下呢？ 

1331
00:59:25,219 --> 00:59:27,169
如果没有，我们有这个

1332
00:59:27,170 --> 00:59:29,210
在这种情况下，我们不返回任何东西。 

1333
00:59:29,210 --> 00:59:32,809
所以那不好，我要解决这个问题

1334
00:59:32,809 --> 00:59:35,639
以一种新颖有趣的方式， 

1335
00:59:35,639 --> 00:59:38,862
我就是要把它变成一个ViewBuilder。 

1336
00:59:39,860 --> 00:59:41,900
如果我将此功能转换为ViewBuilder， 

1337
00:59:41,900 --> 00:59:46,639
那么现在它被解释为视图列表。 

1338
00:59:46,639 --> 00:59:49,806
是的，如果要确定某些视图是进入还是退出， 

1339
00:59:49,806 --> 00:59:52,629
但这是视图列表。 

1340
00:59:52,630 --> 00:59:55,289
要么成为ZStack，要么成为View， 

1341
00:59:55,289 --> 00:59:58,750
否则将为EmptyView。 

1342
00:59:58,750 --> 01:00:00,909
看起来没有错误，就这么简单。 

1343
01:00:00,909 --> 01:00:03,524
我们有ViewBuilder。 

1344
01:00:03,525 --> 01:00:04,820
在这里运行它，让我们尝试看看。 

1345
01:00:04,820 --> 01:00:06,380
可以了

1346
01:00:06,380 --> 01:00:09,869
让我们比赛，哦，拿走了他们

1347
01:00:09,869 --> 01:00:12,302
因为这不是真的，他们就走了。 

1348
01:00:13,760 --> 01:00:15,027
现在我们可以做的另一件事

1349
01:00:15,027 --> 01:00:18,052
并确保我们的cardify确实有效， 

1350
01:00:18,052 --> 01:00:21,809
让我们尝试其他一些视图，而不是使用ZStack。 

1351
01:00:21,809 --> 01:00:23,449
像个圆圈怎么样

1352
01:00:24,380 --> 01:00:27,289
让我们继续将画布带回此处。 

1353
01:00:27,489 --> 01:00:29,252
我们可以看到这一点。 

1354
01:00:33,329 --> 01:00:34,163
是的，看那个。 

1355
01:00:34,163 --> 01:00:35,690
这是放在卡片上的圆。 

1356
01:00:35,690 --> 01:00:36,820
我们甚至可以做圆

1357
01:00:36,820 --> 01:00:39,730
上面有一点填充，对吗？ 

1358
01:00:39,929 --> 01:00:42,639
或者，也许我们将在这里放入一个胶囊。 

1359
01:00:42,639 --> 01:00:44,549
那是另一个内置的Shape Capsule。 

1360
01:00:44,550 --> 01:00:47,380
如果您想知道的话，那就是胶囊形状。 

1361
01:00:47,579 --> 01:00:51,643
我们可以放一些类似Text的东西。 

1362
01:00:52,500 --> 01:00:57,500
世界，您好，看得出来。 

1363
01:00:57,750 --> 01:01:01,570
所以cardify是通用的修饰符ViewModifier 

1364
01:01:01,570 --> 01:01:04,093
我们构建的可以修改任何View的视图。 

1365
01:01:05,619 --> 01:01:07,480
好吧，这很好

1366
01:01:07,480 --> 01:01:10,630
我们已经完成了所有ViewModifier的工作

1367
01:01:10,630 --> 01:01:13,992
因为下一场我们要讲的动画

1368
01:01:13,992 --> 01:01:16,659
当涉及到动画视图时， 

1369
01:01:16,659 --> 01:01:20,519
不是像这个Pie那样的形状，而是为Views本身设置动画， 

1370
01:01:20,519 --> 01:01:22,442
都是关于ViewModifiers的。 

1371
01:01:22,443 --> 01:01:25,289
他们真的只是在给ViewModifiers动画， 

1372
01:01:25,489 --> 01:01:28,459
我们实际上并未为View本身设置动画。 

1373
01:01:28,460 --> 01:01:30,690
我们将在下一个讲座中研究

1374
01:01:30,690 --> 01:01:32,980
并了解如何为这张卡制作动画。 

1375
01:01:32,980 --> 01:01:35,440
卡上有很多他们想要的动画。 

1376
01:01:35,440 --> 01:01:37,559
例如，他们想翻身。 

1377
01:01:37,559 --> 01:01:39,889
那是一张卡片想要的好动画， 

1378
01:01:39,889 --> 01:01:42,297
所以我们把这张卡片化

1379
01:01:42,297 --> 01:01:46,130
到ViewModifier，以便我们下次对其进行动画处理。 

1380
01:01:46,130 --> 01:01:48,250
今天就是这样。 

1381
01:01:48,449 --> 01:01:49,649
那我再和你谈谈。 

1382
01:01:50,530 --> 01:01:55,530
 -[旁白]有关更多信息，请访问我们@ stanford.edu。 

